
 /****************************************************************************
 *                       THIS FILE WAS GENERATED                             *
 * Script: common/generate_packets.py                                        *
 * Input:  common/networking/packets.def                                     *
 *                       DO NOT CHANGE THIS FILE                             *
 ****************************************************************************/


#ifdef HAVE_CONFIG_H
#include <fc_config.h>
#endif

#include <string.h>

/* utility */
#include "bitvector.h"
#include "capability.h"
#include "genhash.h"
#include "log.h"
#include "mem.h"
#include "support.h"

/* common */
#include "capstr.h"
#include "connection.h"
#include "dataio.h"
#include "game.h"

#include "packets.h"

const char *const packet_functional_capability = "ids32 city-original rsdesc32";

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_const(const void *vkey)
{
  return 0;
}

static bool cmp_const(const void *vkey1, const void *vkey2)
{
  return TRUE;
}
#endif /* FREECIV_DELTA_PROTOCOL */
void delta_stats_report(void) {}

void delta_stats_reset(void) {}

const char *packet_name(enum packet_type type)
{
  static const char *const names[PACKET_LAST] = {
    "PACKET_PROCESSING_STARTED",
    "PACKET_PROCESSING_FINISHED",
    "unknown",
    "unknown",
    "PACKET_SERVER_JOIN_REQ",
    "PACKET_SERVER_JOIN_REPLY",
    "PACKET_AUTHENTICATION_REQ",
    "PACKET_AUTHENTICATION_REPLY",
    "PACKET_SERVER_SHUTDOWN",
    "PACKET_RULESET_TECH_CLASS",
    "PACKET_NATION_SELECT_REQ",
    "PACKET_PLAYER_READY",
    "PACKET_ENDGAME_REPORT",
    "PACKET_SCENARIO_DESCRIPTION",
    "PACKET_EDIT_SCENARIO_DESC",
    "PACKET_TILE_INFO",
    "PACKET_GAME_INFO",
    "PACKET_MAP_INFO",
    "PACKET_NUKE_TILE_INFO",
    "PACKET_TEAM_NAME_INFO",
    "unknown",
    "PACKET_INVESTIGATE_STARTED",
    "PACKET_INVESTIGATE_FINISHED",
    "unknown",
    "unknown",
    "PACKET_CHAT_MSG",
    "PACKET_CHAT_MSG_REQ",
    "PACKET_CONNECT_MSG",
    "PACKET_EARLY_CHAT_MSG",
    "PACKET_SERVER_INFO",
    "PACKET_CITY_REMOVE",
    "PACKET_CITY_INFO",
    "PACKET_CITY_SHORT_INFO",
    "PACKET_CITY_SELL",
    "PACKET_CITY_BUY",
    "PACKET_CITY_CHANGE",
    "PACKET_CITY_WORKLIST",
    "PACKET_CITY_MAKE_SPECIALIST",
    "PACKET_CITY_MAKE_WORKER",
    "PACKET_CITY_CHANGE_SPECIALIST",
    "PACKET_CITY_RENAME",
    "PACKET_CITY_OPTIONS_REQ",
    "PACKET_CITY_REFRESH",
    "PACKET_CITY_NAME_SUGGESTION_REQ",
    "PACKET_CITY_NAME_SUGGESTION_INFO",
    "PACKET_CITY_SABOTAGE_LIST",
    "PACKET_CITY_NATIONALITIES",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_PLAYER_REMOVE",
    "PACKET_PLAYER_INFO",
    "PACKET_PLAYER_PHASE_DONE",
    "PACKET_PLAYER_RATES",
    "PACKET_PLAYER_CHANGE_GOVERNMENT",
    "PACKET_PLAYER_RESEARCH",
    "PACKET_PLAYER_TECH_GOAL",
    "PACKET_PLAYER_ATTRIBUTE_BLOCK",
    "PACKET_PLAYER_ATTRIBUTE_CHUNK",
    "PACKET_PLAYER_DIPLSTATE",
    "PACKET_RESEARCH_INFO",
    "PACKET_PLAYER_PLACE_INFRA",
    "PACKET_UNIT_REMOVE",
    "PACKET_UNIT_INFO",
    "PACKET_UNIT_SHORT_INFO",
    "PACKET_UNIT_COMBAT_INFO",
    "PACKET_UNKNOWN_RESEARCH",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_UNIT_SSCS_SET",
    "unknown",
    "PACKET_UNIT_ORDERS",
    "PACKET_UNIT_SERVER_SIDE_AGENT_SET",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_UNIT_ACTION_QUERY",
    "PACKET_UNIT_TYPE_UPGRADE",
    "PACKET_UNIT_DO_ACTION",
    "PACKET_UNIT_ACTION_ANSWER",
    "unknown",
    "PACKET_UNIT_GET_ACTIONS",
    "PACKET_CONN_PING",
    "PACKET_CONN_PONG",
    "PACKET_UNIT_ACTIONS",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_DIPLOMACY_INIT_MEETING_REQ",
    "PACKET_DIPLOMACY_INIT_MEETING",
    "PACKET_DIPLOMACY_CANCEL_MEETING_REQ",
    "PACKET_DIPLOMACY_CANCEL_MEETING",
    "PACKET_DIPLOMACY_CREATE_CLAUSE_REQ",
    "PACKET_DIPLOMACY_CREATE_CLAUSE",
    "PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ",
    "PACKET_DIPLOMACY_REMOVE_CLAUSE",
    "PACKET_DIPLOMACY_ACCEPT_TREATY_REQ",
    "PACKET_DIPLOMACY_ACCEPT_TREATY",
    "PACKET_DIPLOMACY_CANCEL_PACT",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_PAGE_MSG",
    "PACKET_REPORT_REQ",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_CONN_INFO",
    "PACKET_CONN_PING_INFO",
    "unknown",
    "unknown",
    "PACKET_CLIENT_INFO",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_END_PHASE",
    "PACKET_START_PHASE",
    "PACKET_NEW_YEAR",
    "PACKET_BEGIN_TURN",
    "PACKET_END_TURN",
    "PACKET_FREEZE_CLIENT",
    "PACKET_THAW_CLIENT",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_SPACESHIP_LAUNCH",
    "PACKET_SPACESHIP_PLACE",
    "PACKET_SPACESHIP_INFO",
    "PACKET_CITY_RALLY_POINT",
    "unknown",
    "PACKET_RULESET_UNIT",
    "PACKET_RULESET_GAME",
    "PACKET_RULESET_SPECIALIST",
    "PACKET_RULESET_GOVERNMENT_RULER_TITLE",
    "PACKET_RULESET_TECH",
    "PACKET_RULESET_GOVERNMENT",
    "PACKET_RULESET_TERRAIN_CONTROL",
    "PACKET_RULESET_NATION_GROUPS",
    "PACKET_RULESET_NATION",
    "PACKET_RULESET_CITY",
    "PACKET_RULESET_BUILDING",
    "PACKET_RULESET_TERRAIN",
    "PACKET_RULESET_UNIT_CLASS",
    "PACKET_RULESET_BASE",
    "unknown",
    "PACKET_RULESET_CONTROL",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_SINGLE_WANT_HACK_REQ",
    "PACKET_SINGLE_WANT_HACK_REPLY",
    "PACKET_RULESET_CHOICES",
    "PACKET_GAME_LOAD",
    "PACKET_SERVER_SETTING_CONTROL",
    "PACKET_SERVER_SETTING_CONST",
    "PACKET_SERVER_SETTING_BOOL",
    "PACKET_SERVER_SETTING_INT",
    "PACKET_SERVER_SETTING_STR",
    "PACKET_SERVER_SETTING_ENUM",
    "PACKET_SERVER_SETTING_BITWISE",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_RULESET_EFFECT",
    "unknown",
    "PACKET_RULESET_RESOURCE",
    "unknown",
    "unknown",
    "PACKET_SCENARIO_INFO",
    "PACKET_SAVE_SCENARIO",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_VOTE_NEW",
    "PACKET_VOTE_UPDATE",
    "PACKET_VOTE_REMOVE",
    "PACKET_VOTE_RESOLVE",
    "PACKET_VOTE_SUBMIT",
    "PACKET_EDIT_MODE",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_EDIT_RECALCULATE_BORDERS",
    "PACKET_EDIT_CHECK_TILES",
    "PACKET_EDIT_TOGGLE_FOGOFWAR",
    "PACKET_EDIT_TILE_TERRAIN",
    "unknown",
    "PACKET_EDIT_TILE_EXTRA",
    "unknown",
    "PACKET_EDIT_STARTPOS",
    "PACKET_EDIT_STARTPOS_FULL",
    "PACKET_EDIT_TILE",
    "PACKET_EDIT_UNIT_CREATE",
    "PACKET_EDIT_UNIT_REMOVE",
    "PACKET_EDIT_UNIT_REMOVE_BY_ID",
    "PACKET_EDIT_UNIT",
    "PACKET_EDIT_CITY_CREATE",
    "PACKET_EDIT_CITY_REMOVE",
    "PACKET_EDIT_CITY",
    "PACKET_EDIT_PLAYER_CREATE",
    "PACKET_EDIT_PLAYER_REMOVE",
    "PACKET_EDIT_PLAYER",
    "PACKET_EDIT_PLAYER_VISION",
    "PACKET_EDIT_GAME",
    "PACKET_EDIT_OBJECT_CREATED",
    "PACKET_RULESET_ROAD",
    "unknown",
    "PACKET_UNIT_CHANGE_ACTIVITY",
    "PACKET_ENDGAME_PLAYER",
    "PACKET_RULESET_DISASTER",
    "PACKET_RULESETS_READY",
    "PACKET_RULESET_EXTRA_FLAG",
    "PACKET_RULESET_TRADE",
    "PACKET_RULESET_UNIT_BONUS",
    "PACKET_RULESET_UNIT_FLAG",
    "PACKET_RULESET_UNIT_CLASS_FLAG",
    "PACKET_RULESET_TERRAIN_FLAG",
    "PACKET_RULESET_EXTRA",
    "PACKET_RULESET_ACHIEVEMENT",
    "PACKET_RULESET_TECH_FLAG",
    "PACKET_RULESET_ACTION_ENABLER",
    "PACKET_RULESET_NATION_SETS",
    "PACKET_NATION_AVAILABILITY",
    "PACKET_ACHIEVEMENT_INFO",
    "PACKET_RULESET_STYLE",
    "PACKET_RULESET_MUSIC",
    "PACKET_WORKER_TASK",
    "PACKET_PLAYER_MULTIPLIER",
    "PACKET_RULESET_MULTIPLIER",
    "PACKET_TIMEOUT_INFO",
    "PACKET_PLAY_MUSIC",
    "PACKET_RULESET_ACTION",
    "PACKET_RULESET_DESCRIPTION_PART",
    "PACKET_RULESET_GOODS",
    "PACKET_TRADE_ROUTE_INFO",
    "PACKET_PAGE_MSG_PART",
    "PACKET_RULESET_SUMMARY",
    "PACKET_RULESET_ACTION_AUTO",
    "PACKET_SET_TOPOLOGY",
    "PACKET_CLIENT_HEARTBEAT",
    "PACKET_CALENDAR_INFO",
    "PACKET_WEB_CITY_INFO_ADDITION",
    "PACKET_WEB_PLAYER_INFO_ADDITION",
    "PACKET_WEB_RULESET_UNIT_ADDITION",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "unknown",
    "PACKET_RULESET_CLAUSE",
  };

  return (type < PACKET_LAST ? names[type] : "unknown");
}

bool packet_has_game_info_flag(enum packet_type type)
{
  static const bool flag[PACKET_LAST] = {
    FALSE, /* PACKET_PROCESSING_STARTED */
    FALSE, /* PACKET_PROCESSING_FINISHED */
    FALSE,
    FALSE,
    FALSE, /* PACKET_SERVER_JOIN_REQ */
    FALSE, /* PACKET_SERVER_JOIN_REPLY */
    FALSE, /* PACKET_AUTHENTICATION_REQ */
    FALSE, /* PACKET_AUTHENTICATION_REPLY */
    FALSE, /* PACKET_SERVER_SHUTDOWN */
    FALSE, /* PACKET_RULESET_TECH_CLASS */
    FALSE, /* PACKET_NATION_SELECT_REQ */
    FALSE, /* PACKET_PLAYER_READY */
    FALSE, /* PACKET_ENDGAME_REPORT */
    FALSE, /* PACKET_SCENARIO_DESCRIPTION */
    FALSE, /* PACKET_EDIT_SCENARIO_DESC */
    TRUE, /* PACKET_TILE_INFO */
    FALSE, /* PACKET_GAME_INFO */
    FALSE, /* PACKET_MAP_INFO */
    FALSE, /* PACKET_NUKE_TILE_INFO */
    FALSE, /* PACKET_TEAM_NAME_INFO */
    FALSE,
    FALSE, /* PACKET_INVESTIGATE_STARTED */
    FALSE, /* PACKET_INVESTIGATE_FINISHED */
    FALSE,
    FALSE,
    FALSE, /* PACKET_CHAT_MSG */
    FALSE, /* PACKET_CHAT_MSG_REQ */
    FALSE, /* PACKET_CONNECT_MSG */
    FALSE, /* PACKET_EARLY_CHAT_MSG */
    FALSE, /* PACKET_SERVER_INFO */
    FALSE, /* PACKET_CITY_REMOVE */
    TRUE, /* PACKET_CITY_INFO */
    TRUE, /* PACKET_CITY_SHORT_INFO */
    FALSE, /* PACKET_CITY_SELL */
    FALSE, /* PACKET_CITY_BUY */
    FALSE, /* PACKET_CITY_CHANGE */
    FALSE, /* PACKET_CITY_WORKLIST */
    FALSE, /* PACKET_CITY_MAKE_SPECIALIST */
    FALSE, /* PACKET_CITY_MAKE_WORKER */
    FALSE, /* PACKET_CITY_CHANGE_SPECIALIST */
    FALSE, /* PACKET_CITY_RENAME */
    FALSE, /* PACKET_CITY_OPTIONS_REQ */
    FALSE, /* PACKET_CITY_REFRESH */
    FALSE, /* PACKET_CITY_NAME_SUGGESTION_REQ */
    FALSE, /* PACKET_CITY_NAME_SUGGESTION_INFO */
    FALSE, /* PACKET_CITY_SABOTAGE_LIST */
    TRUE, /* PACKET_CITY_NATIONALITIES */
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_PLAYER_REMOVE */
    FALSE, /* PACKET_PLAYER_INFO */
    FALSE, /* PACKET_PLAYER_PHASE_DONE */
    FALSE, /* PACKET_PLAYER_RATES */
    FALSE, /* PACKET_PLAYER_CHANGE_GOVERNMENT */
    FALSE, /* PACKET_PLAYER_RESEARCH */
    FALSE, /* PACKET_PLAYER_TECH_GOAL */
    FALSE, /* PACKET_PLAYER_ATTRIBUTE_BLOCK */
    FALSE, /* PACKET_PLAYER_ATTRIBUTE_CHUNK */
    FALSE, /* PACKET_PLAYER_DIPLSTATE */
    TRUE, /* PACKET_RESEARCH_INFO */
    FALSE, /* PACKET_PLAYER_PLACE_INFRA */
    FALSE, /* PACKET_UNIT_REMOVE */
    TRUE, /* PACKET_UNIT_INFO */
    TRUE, /* PACKET_UNIT_SHORT_INFO */
    FALSE, /* PACKET_UNIT_COMBAT_INFO */
    TRUE, /* PACKET_UNKNOWN_RESEARCH */
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_UNIT_SSCS_SET */
    FALSE,
    FALSE, /* PACKET_UNIT_ORDERS */
    FALSE, /* PACKET_UNIT_SERVER_SIDE_AGENT_SET */
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_UNIT_ACTION_QUERY */
    FALSE, /* PACKET_UNIT_TYPE_UPGRADE */
    FALSE, /* PACKET_UNIT_DO_ACTION */
    FALSE, /* PACKET_UNIT_ACTION_ANSWER */
    FALSE,
    FALSE, /* PACKET_UNIT_GET_ACTIONS */
    FALSE, /* PACKET_CONN_PING */
    FALSE, /* PACKET_CONN_PONG */
    FALSE, /* PACKET_UNIT_ACTIONS */
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_DIPLOMACY_INIT_MEETING_REQ */
    FALSE, /* PACKET_DIPLOMACY_INIT_MEETING */
    FALSE, /* PACKET_DIPLOMACY_CANCEL_MEETING_REQ */
    FALSE, /* PACKET_DIPLOMACY_CANCEL_MEETING */
    FALSE, /* PACKET_DIPLOMACY_CREATE_CLAUSE_REQ */
    FALSE, /* PACKET_DIPLOMACY_CREATE_CLAUSE */
    FALSE, /* PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ */
    FALSE, /* PACKET_DIPLOMACY_REMOVE_CLAUSE */
    FALSE, /* PACKET_DIPLOMACY_ACCEPT_TREATY_REQ */
    FALSE, /* PACKET_DIPLOMACY_ACCEPT_TREATY */
    FALSE, /* PACKET_DIPLOMACY_CANCEL_PACT */
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_PAGE_MSG */
    FALSE, /* PACKET_REPORT_REQ */
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_CONN_INFO */
    FALSE, /* PACKET_CONN_PING_INFO */
    FALSE,
    FALSE,
    FALSE, /* PACKET_CLIENT_INFO */
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_END_PHASE */
    FALSE, /* PACKET_START_PHASE */
    FALSE, /* PACKET_NEW_YEAR */
    FALSE, /* PACKET_BEGIN_TURN */
    FALSE, /* PACKET_END_TURN */
    FALSE, /* PACKET_FREEZE_CLIENT */
    FALSE, /* PACKET_THAW_CLIENT */
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_SPACESHIP_LAUNCH */
    FALSE, /* PACKET_SPACESHIP_PLACE */
    TRUE, /* PACKET_SPACESHIP_INFO */
    TRUE, /* PACKET_CITY_RALLY_POINT */
    FALSE,
    FALSE, /* PACKET_RULESET_UNIT */
    FALSE, /* PACKET_RULESET_GAME */
    FALSE, /* PACKET_RULESET_SPECIALIST */
    FALSE, /* PACKET_RULESET_GOVERNMENT_RULER_TITLE */
    FALSE, /* PACKET_RULESET_TECH */
    FALSE, /* PACKET_RULESET_GOVERNMENT */
    FALSE, /* PACKET_RULESET_TERRAIN_CONTROL */
    FALSE, /* PACKET_RULESET_NATION_GROUPS */
    FALSE, /* PACKET_RULESET_NATION */
    FALSE, /* PACKET_RULESET_CITY */
    FALSE, /* PACKET_RULESET_BUILDING */
    FALSE, /* PACKET_RULESET_TERRAIN */
    FALSE, /* PACKET_RULESET_UNIT_CLASS */
    FALSE, /* PACKET_RULESET_BASE */
    FALSE,
    FALSE, /* PACKET_RULESET_CONTROL */
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_SINGLE_WANT_HACK_REQ */
    FALSE, /* PACKET_SINGLE_WANT_HACK_REPLY */
    FALSE, /* PACKET_RULESET_CHOICES */
    FALSE, /* PACKET_GAME_LOAD */
    FALSE, /* PACKET_SERVER_SETTING_CONTROL */
    FALSE, /* PACKET_SERVER_SETTING_CONST */
    FALSE, /* PACKET_SERVER_SETTING_BOOL */
    FALSE, /* PACKET_SERVER_SETTING_INT */
    FALSE, /* PACKET_SERVER_SETTING_STR */
    FALSE, /* PACKET_SERVER_SETTING_ENUM */
    FALSE, /* PACKET_SERVER_SETTING_BITWISE */
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_RULESET_EFFECT */
    FALSE,
    FALSE, /* PACKET_RULESET_RESOURCE */
    FALSE,
    FALSE,
    FALSE, /* PACKET_SCENARIO_INFO */
    FALSE, /* PACKET_SAVE_SCENARIO */
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_VOTE_NEW */
    FALSE, /* PACKET_VOTE_UPDATE */
    FALSE, /* PACKET_VOTE_REMOVE */
    FALSE, /* PACKET_VOTE_RESOLVE */
    FALSE, /* PACKET_VOTE_SUBMIT */
    FALSE, /* PACKET_EDIT_MODE */
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_EDIT_RECALCULATE_BORDERS */
    FALSE, /* PACKET_EDIT_CHECK_TILES */
    FALSE, /* PACKET_EDIT_TOGGLE_FOGOFWAR */
    FALSE, /* PACKET_EDIT_TILE_TERRAIN */
    FALSE,
    FALSE, /* PACKET_EDIT_TILE_EXTRA */
    FALSE,
    FALSE, /* PACKET_EDIT_STARTPOS */
    FALSE, /* PACKET_EDIT_STARTPOS_FULL */
    FALSE, /* PACKET_EDIT_TILE */
    FALSE, /* PACKET_EDIT_UNIT_CREATE */
    FALSE, /* PACKET_EDIT_UNIT_REMOVE */
    FALSE, /* PACKET_EDIT_UNIT_REMOVE_BY_ID */
    FALSE, /* PACKET_EDIT_UNIT */
    FALSE, /* PACKET_EDIT_CITY_CREATE */
    FALSE, /* PACKET_EDIT_CITY_REMOVE */
    FALSE, /* PACKET_EDIT_CITY */
    FALSE, /* PACKET_EDIT_PLAYER_CREATE */
    FALSE, /* PACKET_EDIT_PLAYER_REMOVE */
    FALSE, /* PACKET_EDIT_PLAYER */
    FALSE, /* PACKET_EDIT_PLAYER_VISION */
    FALSE, /* PACKET_EDIT_GAME */
    FALSE, /* PACKET_EDIT_OBJECT_CREATED */
    FALSE, /* PACKET_RULESET_ROAD */
    FALSE,
    FALSE, /* PACKET_UNIT_CHANGE_ACTIVITY */
    FALSE, /* PACKET_ENDGAME_PLAYER */
    FALSE, /* PACKET_RULESET_DISASTER */
    FALSE, /* PACKET_RULESETS_READY */
    FALSE, /* PACKET_RULESET_EXTRA_FLAG */
    FALSE, /* PACKET_RULESET_TRADE */
    FALSE, /* PACKET_RULESET_UNIT_BONUS */
    FALSE, /* PACKET_RULESET_UNIT_FLAG */
    FALSE, /* PACKET_RULESET_UNIT_CLASS_FLAG */
    FALSE, /* PACKET_RULESET_TERRAIN_FLAG */
    FALSE, /* PACKET_RULESET_EXTRA */
    FALSE, /* PACKET_RULESET_ACHIEVEMENT */
    FALSE, /* PACKET_RULESET_TECH_FLAG */
    FALSE, /* PACKET_RULESET_ACTION_ENABLER */
    FALSE, /* PACKET_RULESET_NATION_SETS */
    FALSE, /* PACKET_NATION_AVAILABILITY */
    FALSE, /* PACKET_ACHIEVEMENT_INFO */
    FALSE, /* PACKET_RULESET_STYLE */
    FALSE, /* PACKET_RULESET_MUSIC */
    FALSE, /* PACKET_WORKER_TASK */
    FALSE, /* PACKET_PLAYER_MULTIPLIER */
    FALSE, /* PACKET_RULESET_MULTIPLIER */
    FALSE, /* PACKET_TIMEOUT_INFO */
    FALSE, /* PACKET_PLAY_MUSIC */
    FALSE, /* PACKET_RULESET_ACTION */
    FALSE, /* PACKET_RULESET_DESCRIPTION_PART */
    FALSE, /* PACKET_RULESET_GOODS */
    FALSE, /* PACKET_TRADE_ROUTE_INFO */
    FALSE, /* PACKET_PAGE_MSG_PART */
    FALSE, /* PACKET_RULESET_SUMMARY */
    FALSE, /* PACKET_RULESET_ACTION_AUTO */
    FALSE, /* PACKET_SET_TOPOLOGY */
    FALSE, /* PACKET_CLIENT_HEARTBEAT */
    FALSE, /* PACKET_CALENDAR_INFO */
    TRUE, /* PACKET_WEB_CITY_INFO_ADDITION */
    FALSE, /* PACKET_WEB_PLAYER_INFO_ADDITION */
    FALSE, /* PACKET_WEB_RULESET_UNIT_ADDITION */
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE,
    FALSE, /* PACKET_RULESET_CLAUSE */
  };

  return (type < PACKET_LAST ? flag[type] : FALSE);
}

static struct packet_processing_started *receive_packet_processing_started_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_processing_started, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_processing_started_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_processing_started_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_PROCESSING_STARTED);

  log_packet_detailed("packet_processing_started_100: sending info about ()");
  SEND_PACKET_END(PACKET_PROCESSING_STARTED);
}

int send_packet_processing_started(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PROCESSING_STARTED].no_packet != NULL, -1,
                        "Handler for PACKET_PROCESSING_STARTED not installed");
  return pc->phs.handlers->send[PACKET_PROCESSING_STARTED].no_packet(pc);
}

static struct packet_processing_finished *receive_packet_processing_finished_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_processing_finished, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_processing_finished_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_processing_finished_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_PROCESSING_FINISHED);

  log_packet_detailed("packet_processing_finished_100: sending info about ()");
  SEND_PACKET_END(PACKET_PROCESSING_FINISHED);
}

int send_packet_processing_finished(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PROCESSING_FINISHED].no_packet != NULL, -1,
                        "Handler for PACKET_PROCESSING_FINISHED not installed");
  return pc->phs.handlers->send[PACKET_PROCESSING_FINISHED].no_packet(pc);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_investigate_started_100 hash_const

#define cmp_packet_investigate_started_100 cmp_const

BV_DEFINE(packet_investigate_started_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_investigate_started *receive_packet_investigate_started_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_investigate_started_100_fields fields;
  struct packet_investigate_started *old;
  struct genhash **hash = pc->phs.received + PACKET_INVESTIGATE_STARTED;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_investigate_started, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }

#endif
  log_packet_detailed("packet_investigate_started_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_investigate_started_100, cmp_packet_investigate_started_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_investigate_started_100(struct connection *pc, const struct packet_investigate_started *packet)
{
  const struct packet_investigate_started *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_investigate_started_100_fields fields;
  struct packet_investigate_started *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_INVESTIGATE_STARTED;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_INVESTIGATE_STARTED);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_investigate_started_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_investigate_started_100, cmp_packet_investigate_started_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id32 != real_packet->unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);

#endif
  SEND_PACKET_END(PACKET_INVESTIGATE_STARTED);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_investigate_started_101 hash_const

#define cmp_packet_investigate_started_101 cmp_const

BV_DEFINE(packet_investigate_started_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_investigate_started *receive_packet_investigate_started_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_investigate_started_101_fields fields;
  struct packet_investigate_started *old;
  struct genhash **hash = pc->phs.received + PACKET_INVESTIGATE_STARTED;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_investigate_started, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }

#endif
  log_packet_detailed("packet_investigate_started_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_investigate_started_101, cmp_packet_investigate_started_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_investigate_started_101(struct connection *pc, const struct packet_investigate_started *packet)
{
  const struct packet_investigate_started *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_investigate_started_101_fields fields;
  struct packet_investigate_started *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_INVESTIGATE_STARTED;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_INVESTIGATE_STARTED);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_investigate_started_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_investigate_started_101, cmp_packet_investigate_started_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id16 != real_packet->unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);

#endif
  SEND_PACKET_END(PACKET_INVESTIGATE_STARTED);
}

int send_packet_investigate_started(struct connection *pc, const struct packet_investigate_started *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_INVESTIGATE_STARTED].packet != NULL, -1,
                        "Handler for PACKET_INVESTIGATE_STARTED not installed");
  return pc->phs.handlers->send[PACKET_INVESTIGATE_STARTED].packet(pc, packet);
}

int dsend_packet_investigate_started(struct connection *pc, int unit_id16, int unit_id32, int city_id16, int city_id32)
{
  struct packet_investigate_started packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  
  return send_packet_investigate_started(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_investigate_finished_100 hash_const

#define cmp_packet_investigate_finished_100 cmp_const

BV_DEFINE(packet_investigate_finished_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_investigate_finished *receive_packet_investigate_finished_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_investigate_finished_100_fields fields;
  struct packet_investigate_finished *old;
  struct genhash **hash = pc->phs.received + PACKET_INVESTIGATE_FINISHED;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_investigate_finished, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }

#endif
  log_packet_detailed("packet_investigate_finished_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_investigate_finished_100, cmp_packet_investigate_finished_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_investigate_finished_100(struct connection *pc, const struct packet_investigate_finished *packet)
{
  const struct packet_investigate_finished *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_investigate_finished_100_fields fields;
  struct packet_investigate_finished *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_INVESTIGATE_FINISHED;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_INVESTIGATE_FINISHED);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_investigate_finished_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_investigate_finished_100, cmp_packet_investigate_finished_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id32 != real_packet->unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);

#endif
  SEND_PACKET_END(PACKET_INVESTIGATE_FINISHED);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_investigate_finished_101 hash_const

#define cmp_packet_investigate_finished_101 cmp_const

BV_DEFINE(packet_investigate_finished_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_investigate_finished *receive_packet_investigate_finished_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_investigate_finished_101_fields fields;
  struct packet_investigate_finished *old;
  struct genhash **hash = pc->phs.received + PACKET_INVESTIGATE_FINISHED;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_investigate_finished, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }

#endif
  log_packet_detailed("packet_investigate_finished_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_investigate_finished_101, cmp_packet_investigate_finished_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_investigate_finished_101(struct connection *pc, const struct packet_investigate_finished *packet)
{
  const struct packet_investigate_finished *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_investigate_finished_101_fields fields;
  struct packet_investigate_finished *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_INVESTIGATE_FINISHED;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_INVESTIGATE_FINISHED);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_investigate_finished_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_investigate_finished_101, cmp_packet_investigate_finished_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id16 != real_packet->unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);

#endif
  SEND_PACKET_END(PACKET_INVESTIGATE_FINISHED);
}

int send_packet_investigate_finished(struct connection *pc, const struct packet_investigate_finished *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_INVESTIGATE_FINISHED].packet != NULL, -1,
                        "Handler for PACKET_INVESTIGATE_FINISHED not installed");
  return pc->phs.handlers->send[PACKET_INVESTIGATE_FINISHED].packet(pc, packet);
}

int dsend_packet_investigate_finished(struct connection *pc, int unit_id16, int unit_id32, int city_id16, int city_id32)
{
  struct packet_investigate_finished packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  
  return send_packet_investigate_finished(pc, real_packet);
}

static struct packet_server_join_req *receive_packet_server_join_req_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_server_join_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */
#if 1 /* To match endif */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->username, sizeof(real_packet->username))) {
    RECEIVE_PACKET_FIELD_ERROR(username);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capability";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->capability, sizeof(real_packet->capability))) {
    RECEIVE_PACKET_FIELD_ERROR(capability);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version_label";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->version_label, sizeof(real_packet->version_label))) {
    RECEIVE_PACKET_FIELD_ERROR(version_label);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "major_version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->major_version)) {
    RECEIVE_PACKET_FIELD_ERROR(major_version);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "minor_version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->minor_version)) {
    RECEIVE_PACKET_FIELD_ERROR(minor_version);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "patch_version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->patch_version)) {
    RECEIVE_PACKET_FIELD_ERROR(patch_version);
  }

#endif
  log_packet_detailed("packet_server_join_req_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_join_req_100(struct connection *pc, const struct packet_server_join_req *packet)
{
  const struct packet_server_join_req *real_packet = packet;
  SEND_PACKET_START(PACKET_SERVER_JOIN_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_join_req_100: sending info about ()");
#if 1 /* To match endif */
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->username);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capability";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->capability);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version_label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->version_label);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "major_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->major_version);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "minor_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->minor_version);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "patch_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->patch_version);

#endif
  SEND_PACKET_END(PACKET_SERVER_JOIN_REQ);
}

int send_packet_server_join_req(struct connection *pc, const struct packet_server_join_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_JOIN_REQ].packet != NULL, -1,
                        "Handler for PACKET_SERVER_JOIN_REQ not installed");
  return pc->phs.handlers->send[PACKET_SERVER_JOIN_REQ].packet(pc, packet);
}

int dsend_packet_server_join_req(struct connection *pc, const char *username, const char *capability, const char *version_label, int major_version, int minor_version, int patch_version)
{
  struct packet_server_join_req packet, *real_packet = &packet;

  sz_strlcpy(real_packet->username, username);
  sz_strlcpy(real_packet->capability, capability);
  sz_strlcpy(real_packet->version_label, version_label);
  real_packet->major_version = major_version;
  real_packet->minor_version = minor_version;
  real_packet->patch_version = patch_version;
  
  return send_packet_server_join_req(pc, real_packet);
}

static struct packet_server_join_reply *receive_packet_server_join_reply_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_server_join_reply, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */
#if 1 /* To match endif */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "you_can_join";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->you_can_join)) {
    RECEIVE_PACKET_FIELD_ERROR(you_can_join);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
    RECEIVE_PACKET_FIELD_ERROR(message);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capability";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->capability, sizeof(real_packet->capability))) {
    RECEIVE_PACKET_FIELD_ERROR(capability);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "challenge_file";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->challenge_file, sizeof(real_packet->challenge_file))) {
    RECEIVE_PACKET_FIELD_ERROR(challenge_file);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->conn_id)) {
    RECEIVE_PACKET_FIELD_ERROR(conn_id);
  }

#endif
  log_packet_detailed("packet_server_join_reply_100: got info about ()");
  post_receive_packet_server_join_reply(pc, real_packet);
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_join_reply_100(struct connection *pc, const struct packet_server_join_reply *packet)
{
  const struct packet_server_join_reply *real_packet = packet;
  SEND_PACKET_START(PACKET_SERVER_JOIN_REPLY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_join_reply_100: sending info about ()");
#if 1 /* To match endif */
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "you_can_join";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->you_can_join);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->message);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capability";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->capability);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "challenge_file";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->challenge_file);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->conn_id);

#endif
  post_send_packet_server_join_reply(pc, real_packet);
  SEND_PACKET_END(PACKET_SERVER_JOIN_REPLY);
}

int send_packet_server_join_reply(struct connection *pc, const struct packet_server_join_reply *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_JOIN_REPLY].packet != NULL, -1,
                        "Handler for PACKET_SERVER_JOIN_REPLY not installed");
  return pc->phs.handlers->send[PACKET_SERVER_JOIN_REPLY].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_authentication_req_100 hash_const

#define cmp_packet_authentication_req_100 cmp_const

BV_DEFINE(packet_authentication_req_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_authentication_req *receive_packet_authentication_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_authentication_req_100_fields fields;
  struct packet_authentication_req *old;
  struct genhash **hash = pc->phs.received + PACKET_AUTHENTICATION_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_authentication_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
    RECEIVE_PACKET_FIELD_ERROR(message);
  }

#endif
  log_packet_detailed("packet_authentication_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_authentication_req_100, cmp_packet_authentication_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'message'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "message";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
      RECEIVE_PACKET_FIELD_ERROR(message);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_authentication_req_100(struct connection *pc, const struct packet_authentication_req *packet)
{
  const struct packet_authentication_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_authentication_req_100_fields fields;
  struct packet_authentication_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_AUTHENTICATION_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_AUTHENTICATION_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_authentication_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_authentication_req_100, cmp_packet_authentication_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->message, real_packet->message) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'message' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->message);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->message);

#endif
  SEND_PACKET_END(PACKET_AUTHENTICATION_REQ);
}

int send_packet_authentication_req(struct connection *pc, const struct packet_authentication_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_AUTHENTICATION_REQ].packet != NULL, -1,
                        "Handler for PACKET_AUTHENTICATION_REQ not installed");
  return pc->phs.handlers->send[PACKET_AUTHENTICATION_REQ].packet(pc, packet);
}

int dsend_packet_authentication_req(struct connection *pc, enum authentication_type type, const char *message)
{
  struct packet_authentication_req packet, *real_packet = &packet;

  real_packet->type = type;
  sz_strlcpy(real_packet->message, message);
  
  return send_packet_authentication_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_authentication_reply_100 hash_const

#define cmp_packet_authentication_reply_100 cmp_const

BV_DEFINE(packet_authentication_reply_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_authentication_reply *receive_packet_authentication_reply_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_authentication_reply_100_fields fields;
  struct packet_authentication_reply *old;
  struct genhash **hash = pc->phs.received + PACKET_AUTHENTICATION_REPLY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_authentication_reply, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "password";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->password, sizeof(real_packet->password))) {
    RECEIVE_PACKET_FIELD_ERROR(password);
  }

#endif
  log_packet_detailed("packet_authentication_reply_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_authentication_reply_100, cmp_packet_authentication_reply_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'password'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "password";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->password, sizeof(real_packet->password))) {
      RECEIVE_PACKET_FIELD_ERROR(password);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_authentication_reply_100(struct connection *pc, const struct packet_authentication_reply *packet)
{
  const struct packet_authentication_reply *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_authentication_reply_100_fields fields;
  struct packet_authentication_reply *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_AUTHENTICATION_REPLY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_AUTHENTICATION_REPLY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_authentication_reply_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_authentication_reply_100, cmp_packet_authentication_reply_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->password, real_packet->password) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'password' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "password";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->password);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "password";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->password);

#endif
  SEND_PACKET_END(PACKET_AUTHENTICATION_REPLY);
}

int send_packet_authentication_reply(struct connection *pc, const struct packet_authentication_reply *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_AUTHENTICATION_REPLY].packet != NULL, -1,
                        "Handler for PACKET_AUTHENTICATION_REPLY not installed");
  return pc->phs.handlers->send[PACKET_AUTHENTICATION_REPLY].packet(pc, packet);
}

static struct packet_server_shutdown *receive_packet_server_shutdown_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_server_shutdown, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_server_shutdown_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_shutdown_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_SERVER_SHUTDOWN);

  log_packet_detailed("packet_server_shutdown_100: sending info about ()");
  SEND_PACKET_END(PACKET_SERVER_SHUTDOWN);
}

int send_packet_server_shutdown(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_SHUTDOWN].no_packet != NULL, -1,
                        "Handler for PACKET_SERVER_SHUTDOWN not installed");
  return pc->phs.handlers->send[PACKET_SERVER_SHUTDOWN].no_packet(pc);
}

void lsend_packet_server_shutdown(struct conn_list *dest)
{
  conn_list_iterate(dest, pconn) {
    send_packet_server_shutdown(pconn);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_nation_select_req_100 hash_const

#define cmp_packet_nation_select_req_100 cmp_const

BV_DEFINE(packet_nation_select_req_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_nation_select_req *receive_packet_nation_select_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_nation_select_req_100_fields fields;
  struct packet_nation_select_req *old;
  struct genhash **hash = pc->phs.received + PACKET_NATION_SELECT_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_nation_select_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_no";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_no)) {
    RECEIVE_PACKET_FIELD_ERROR(player_no);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_no";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(nation_no);
    }
    real_packet->nation_no = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_male";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_male)) {
    RECEIVE_PACKET_FIELD_ERROR(is_male);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
    RECEIVE_PACKET_FIELD_ERROR(style);
  }

#endif
  log_packet_detailed("packet_nation_select_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_nation_select_req_100, cmp_packet_nation_select_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'player_no'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "player_no";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_no)) {
      RECEIVE_PACKET_FIELD_ERROR(player_no);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'nation_no'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation_no";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(nation_no);
      }
      real_packet->nation_no = readin;
    }
  }
  real_packet->is_male = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
      RECEIVE_PACKET_FIELD_ERROR(style);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_nation_select_req_100(struct connection *pc, const struct packet_nation_select_req *packet)
{
  const struct packet_nation_select_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_nation_select_req_100_fields fields;
  struct packet_nation_select_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_NATION_SELECT_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_NATION_SELECT_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_nation_select_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_nation_select_req_100, cmp_packet_nation_select_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->player_no != real_packet->player_no);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->nation_no != real_packet->nation_no);
  if (differ) {
    BV_SET(fields, 1);
  }

  if (packet->is_male) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->style != real_packet->style);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'player_no' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_no);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'nation_no' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nation_no);
  }
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_no);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nation_no);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_male";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_male);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);

#endif
  SEND_PACKET_END(PACKET_NATION_SELECT_REQ);
}

int send_packet_nation_select_req(struct connection *pc, const struct packet_nation_select_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_NATION_SELECT_REQ].packet != NULL, -1,
                        "Handler for PACKET_NATION_SELECT_REQ not installed");
  return pc->phs.handlers->send[PACKET_NATION_SELECT_REQ].packet(pc, packet);
}

int dsend_packet_nation_select_req(struct connection *pc, int player_no, Nation_type_id nation_no, bool is_male, const char *name, int style)
{
  struct packet_nation_select_req packet, *real_packet = &packet;

  real_packet->player_no = player_no;
  real_packet->nation_no = nation_no;
  real_packet->is_male = is_male;
  sz_strlcpy(real_packet->name, name);
  real_packet->style = style;
  
  return send_packet_nation_select_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_player_ready_100 hash_const

#define cmp_packet_player_ready_100 cmp_const

BV_DEFINE(packet_player_ready_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_ready *receive_packet_player_ready_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_ready_100_fields fields;
  struct packet_player_ready *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_READY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_ready, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_no";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_no)) {
    RECEIVE_PACKET_FIELD_ERROR(player_no);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_ready";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_ready)) {
    RECEIVE_PACKET_FIELD_ERROR(is_ready);
  }

#endif
  log_packet_detailed("packet_player_ready_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_ready_100, cmp_packet_player_ready_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'player_no'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "player_no";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_no)) {
      RECEIVE_PACKET_FIELD_ERROR(player_no);
    }
  }
  real_packet->is_ready = BV_ISSET(fields, 1);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_ready_100(struct connection *pc, const struct packet_player_ready *packet)
{
  const struct packet_player_ready *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_ready_100_fields fields;
  struct packet_player_ready *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_READY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_READY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_ready_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_ready_100, cmp_packet_player_ready_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->player_no != real_packet->player_no);
  if (differ) {
    BV_SET(fields, 0);
  }

  if (packet->is_ready) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'player_no' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_no);
  }
  /* field 1 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_no);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_ready";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_ready);

#endif
  SEND_PACKET_END(PACKET_PLAYER_READY);
}

int send_packet_player_ready(struct connection *pc, const struct packet_player_ready *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_READY].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_READY not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_READY].packet(pc, packet);
}

int dsend_packet_player_ready(struct connection *pc, int player_no, bool is_ready)
{
  struct packet_player_ready packet, *real_packet = &packet;

  real_packet->player_no = player_no;
  real_packet->is_ready = is_ready;
  
  return send_packet_player_ready(pc, real_packet);
}

static struct packet_endgame_report *receive_packet_endgame_report_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_endgame_report, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */
#if 1 /* To match endif */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->category_num)) {
    RECEIVE_PACKET_FIELD_ERROR(category_num);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_name";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->category_num > 32) {
      RECEIVE_PACKET_FIELD_ERROR(category_name, ": truncation array");
    }
    for (i = 0; i < real_packet->category_num; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->category_name[i], sizeof(real_packet->category_name[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(category_name);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_num)) {
    RECEIVE_PACKET_FIELD_ERROR(player_num);
  }

#endif
  log_packet_detailed("packet_endgame_report_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_endgame_report_100(struct connection *pc, const struct packet_endgame_report *packet)
{
  const struct packet_endgame_report *real_packet = packet;
  SEND_PACKET_START(PACKET_ENDGAME_REPORT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_endgame_report_100: sending info about ()");
#if 1 /* To match endif */
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->category_num);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_name";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->category_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->category_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->category_name[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_num);

#endif
  SEND_PACKET_END(PACKET_ENDGAME_REPORT);
}

int send_packet_endgame_report(struct connection *pc, const struct packet_endgame_report *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_ENDGAME_REPORT].packet != NULL, -1,
                        "Handler for PACKET_ENDGAME_REPORT not installed");
  return pc->phs.handlers->send[PACKET_ENDGAME_REPORT].packet(pc, packet);
}

void lsend_packet_endgame_report(struct conn_list *dest, const struct packet_endgame_report *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_endgame_report(pconn, packet);
  } conn_list_iterate_end;
}

static struct packet_endgame_player *receive_packet_endgame_player_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_endgame_player, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */
#if 1 /* To match endif */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->category_num)) {
    RECEIVE_PACKET_FIELD_ERROR(category_num);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_id)) {
    RECEIVE_PACKET_FIELD_ERROR(player_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "score";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->score)) {
    RECEIVE_PACKET_FIELD_ERROR(score);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_score";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->category_num > 32) {
      RECEIVE_PACKET_FIELD_ERROR(category_score, ": truncation array");
    }
    for (i = 0; i < real_packet->category_num; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint32, &din, &field_addr, &real_packet->category_score[i])) {
        RECEIVE_PACKET_FIELD_ERROR(category_score);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "winner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->winner)) {
    RECEIVE_PACKET_FIELD_ERROR(winner);
  }

#endif
  log_packet_detailed("packet_endgame_player_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_endgame_player_100(struct connection *pc, const struct packet_endgame_player *packet)
{
  const struct packet_endgame_player *real_packet = packet;
  SEND_PACKET_START(PACKET_ENDGAME_PLAYER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_endgame_player_100: sending info about ()");
#if 1 /* To match endif */
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->category_num);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "score";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->score);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_score";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->category_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->category_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->category_score[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "winner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->winner);

#endif
  SEND_PACKET_END(PACKET_ENDGAME_PLAYER);
}

int send_packet_endgame_player(struct connection *pc, const struct packet_endgame_player *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_ENDGAME_PLAYER].packet != NULL, -1,
                        "Handler for PACKET_ENDGAME_PLAYER not installed");
  return pc->phs.handlers->send[PACKET_ENDGAME_PLAYER].packet(pc, packet);
}

void lsend_packet_endgame_player(struct conn_list *dest, const struct packet_endgame_player *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_endgame_player(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_tile_info_100(const void *vkey)
{
  const struct packet_tile_info *key = (const struct packet_tile_info *) vkey;

  return key->tile;
}

static bool cmp_packet_tile_info_100(const void *vkey1, const void *vkey2)
{
  const struct packet_tile_info *key1 = (const struct packet_tile_info *) vkey1;
  const struct packet_tile_info *key2 = (const struct packet_tile_info *) vkey2;

  return key1->tile == key2->tile;
}
BV_DEFINE(packet_tile_info_100_fields, 12);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_tile_info *receive_packet_tile_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_tile_info_100_fields fields;
  struct packet_tile_info *old;
  struct genhash **hash = pc->phs.received + PACKET_TILE_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_tile_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "continent";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(continent);
    }
    real_packet->continent = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "known";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(known);
    }
    real_packet->known = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras_owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->extras_owner)) {
    RECEIVE_PACKET_FIELD_ERROR(extras_owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worked32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->worked32)) {
    RECEIVE_PACKET_FIELD_ERROR(worked32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(terrain);
    }
    real_packet->terrain = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resource";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(resource);
    }
    real_packet->resource = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->extras)) {
    RECEIVE_PACKET_FIELD_ERROR(extras);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "placing";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->placing)) {
    RECEIVE_PACKET_FIELD_ERROR(placing);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "place_turn";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->place_turn)) {
    RECEIVE_PACKET_FIELD_ERROR(place_turn);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "spec_sprite";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->spec_sprite, sizeof(real_packet->spec_sprite))) {
    RECEIVE_PACKET_FIELD_ERROR(spec_sprite);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "label";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->label, sizeof(real_packet->label))) {
    RECEIVE_PACKET_FIELD_ERROR(label);
  }

#endif
  log_packet_detailed("packet_tile_info_100: got info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_tile_info_100, cmp_packet_tile_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int tile = real_packet->tile;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->tile = tile;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'continent'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "continent";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(continent);
      }
      real_packet->continent = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'known'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "known";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(known);
      }
      real_packet->known = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'extras_owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "extras_owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->extras_owner)) {
      RECEIVE_PACKET_FIELD_ERROR(extras_owner);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'worked32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "worked32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->worked32)) {
      RECEIVE_PACKET_FIELD_ERROR(worked32);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'terrain'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "terrain";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(terrain);
      }
      real_packet->terrain = readin;
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'resource'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "resource";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(resource);
      }
      real_packet->resource = readin;
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'extras'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "extras";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->extras)) {
      RECEIVE_PACKET_FIELD_ERROR(extras);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'placing'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "placing";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->placing)) {
      RECEIVE_PACKET_FIELD_ERROR(placing);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'place_turn'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "place_turn";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->place_turn)) {
      RECEIVE_PACKET_FIELD_ERROR(place_turn);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'spec_sprite'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "spec_sprite";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->spec_sprite, sizeof(real_packet->spec_sprite))) {
      RECEIVE_PACKET_FIELD_ERROR(spec_sprite);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'label'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "label";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->label, sizeof(real_packet->label))) {
      RECEIVE_PACKET_FIELD_ERROR(label);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_tile_info_100(struct connection *pc, const struct packet_tile_info *packet)
{
  const struct packet_tile_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_tile_info_100_fields fields;
  struct packet_tile_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_TILE_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_TILE_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_tile_info_100: sending info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_tile_info_100, cmp_packet_tile_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->continent != real_packet->continent);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->known != real_packet->known);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->extras_owner != real_packet->extras_owner);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->worked32 != real_packet->worked32);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->terrain != real_packet->terrain);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->resource != real_packet->resource);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = !BV_ARE_EQUAL(old->extras, real_packet->extras);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }

  differ = (old->placing != real_packet->placing);
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }

  differ = (old->place_turn != real_packet->place_turn);
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }

  differ = (strcmp(old->spec_sprite, real_packet->spec_sprite) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (strcmp(old->label, real_packet->label) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'continent' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "continent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->continent);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'known' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "known";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->known);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'extras_owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras_owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->extras_owner);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'worked32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worked32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->worked32);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'terrain' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'resource' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resource";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->resource);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'extras' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->extras);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'placing' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "placing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->placing);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'place_turn' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "place_turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->place_turn);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'spec_sprite' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "spec_sprite";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->spec_sprite);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'label' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->label);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "continent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->continent);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "known";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->known);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras_owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->extras_owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worked32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->worked32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resource";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->resource);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->extras);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "placing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->placing);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "place_turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->place_turn);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "spec_sprite";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->spec_sprite);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->label);

#endif
  SEND_PACKET_END(PACKET_TILE_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_tile_info_101(const void *vkey)
{
  const struct packet_tile_info *key = (const struct packet_tile_info *) vkey;

  return key->tile;
}

static bool cmp_packet_tile_info_101(const void *vkey1, const void *vkey2)
{
  const struct packet_tile_info *key1 = (const struct packet_tile_info *) vkey1;
  const struct packet_tile_info *key2 = (const struct packet_tile_info *) vkey2;

  return key1->tile == key2->tile;
}
BV_DEFINE(packet_tile_info_101_fields, 12);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_tile_info *receive_packet_tile_info_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_tile_info_101_fields fields;
  struct packet_tile_info *old;
  struct genhash **hash = pc->phs.received + PACKET_TILE_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_tile_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "continent";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(continent);
    }
    real_packet->continent = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "known";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(known);
    }
    real_packet->known = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras_owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->extras_owner)) {
    RECEIVE_PACKET_FIELD_ERROR(extras_owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worked16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->worked16)) {
    RECEIVE_PACKET_FIELD_ERROR(worked16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(terrain);
    }
    real_packet->terrain = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resource";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(resource);
    }
    real_packet->resource = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->extras)) {
    RECEIVE_PACKET_FIELD_ERROR(extras);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "placing";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->placing)) {
    RECEIVE_PACKET_FIELD_ERROR(placing);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "place_turn";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->place_turn)) {
    RECEIVE_PACKET_FIELD_ERROR(place_turn);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "spec_sprite";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->spec_sprite, sizeof(real_packet->spec_sprite))) {
    RECEIVE_PACKET_FIELD_ERROR(spec_sprite);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "label";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->label, sizeof(real_packet->label))) {
    RECEIVE_PACKET_FIELD_ERROR(label);
  }

#endif
  log_packet_detailed("packet_tile_info_101: got info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_tile_info_101, cmp_packet_tile_info_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int tile = real_packet->tile;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->tile = tile;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'continent'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "continent";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(continent);
      }
      real_packet->continent = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'known'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "known";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(known);
      }
      real_packet->known = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'extras_owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "extras_owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->extras_owner)) {
      RECEIVE_PACKET_FIELD_ERROR(extras_owner);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'worked16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "worked16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->worked16)) {
      RECEIVE_PACKET_FIELD_ERROR(worked16);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'terrain'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "terrain";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(terrain);
      }
      real_packet->terrain = readin;
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'resource'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "resource";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(resource);
      }
      real_packet->resource = readin;
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'extras'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "extras";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->extras)) {
      RECEIVE_PACKET_FIELD_ERROR(extras);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'placing'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "placing";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->placing)) {
      RECEIVE_PACKET_FIELD_ERROR(placing);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'place_turn'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "place_turn";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->place_turn)) {
      RECEIVE_PACKET_FIELD_ERROR(place_turn);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'spec_sprite'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "spec_sprite";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->spec_sprite, sizeof(real_packet->spec_sprite))) {
      RECEIVE_PACKET_FIELD_ERROR(spec_sprite);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'label'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "label";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->label, sizeof(real_packet->label))) {
      RECEIVE_PACKET_FIELD_ERROR(label);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_tile_info_101(struct connection *pc, const struct packet_tile_info *packet)
{
  const struct packet_tile_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_tile_info_101_fields fields;
  struct packet_tile_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_TILE_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_TILE_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_tile_info_101: sending info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_tile_info_101, cmp_packet_tile_info_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->continent != real_packet->continent);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->known != real_packet->known);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->extras_owner != real_packet->extras_owner);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->worked16 != real_packet->worked16);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->terrain != real_packet->terrain);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->resource != real_packet->resource);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = !BV_ARE_EQUAL(old->extras, real_packet->extras);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }

  differ = (old->placing != real_packet->placing);
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }

  differ = (old->place_turn != real_packet->place_turn);
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }

  differ = (strcmp(old->spec_sprite, real_packet->spec_sprite) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (strcmp(old->label, real_packet->label) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'continent' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "continent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->continent);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'known' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "known";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->known);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'extras_owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras_owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->extras_owner);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'worked16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worked16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->worked16);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'terrain' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'resource' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resource";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->resource);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'extras' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->extras);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'placing' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "placing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->placing);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'place_turn' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "place_turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->place_turn);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'spec_sprite' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "spec_sprite";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->spec_sprite);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'label' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->label);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "continent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->continent);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "known";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->known);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras_owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->extras_owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worked16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->worked16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resource";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->resource);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->extras);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "placing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->placing);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "place_turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->place_turn);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "spec_sprite";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->spec_sprite);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->label);

#endif
  SEND_PACKET_END(PACKET_TILE_INFO);
}

int send_packet_tile_info(struct connection *pc, const struct packet_tile_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_TILE_INFO].packet != NULL, -1,
                        "Handler for PACKET_TILE_INFO not installed");
  return pc->phs.handlers->send[PACKET_TILE_INFO].packet(pc, packet);
}

void lsend_packet_tile_info(struct conn_list *dest, const struct packet_tile_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_tile_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_game_info_100 hash_const

#define cmp_packet_game_info_100 cmp_const

BV_DEFINE(packet_game_info_100_fields, 131);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_game_info *receive_packet_game_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_game_info_100_fields fields;
  struct packet_game_info *old;
  struct genhash **hash = pc->phs.received + PACKET_GAME_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_game_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "add_to_size_limit";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->add_to_size_limit)) {
    RECEIVE_PACKET_FIELD_ERROR(add_to_size_limit);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "aifill";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->aifill)) {
    RECEIVE_PACKET_FIELD_ERROR(aifill);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "persistent_ready";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(persistent_ready);
    }
    real_packet->persistent_ready = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlifting_style";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(airlifting_style);
    }
    real_packet->airlifting_style = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift_from_always_enabled";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->airlift_from_always_enabled)) {
    RECEIVE_PACKET_FIELD_ERROR(airlift_from_always_enabled);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift_to_always_enabled";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->airlift_to_always_enabled)) {
    RECEIVE_PACKET_FIELD_ERROR(airlift_to_always_enabled);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "angrycitizen";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->angrycitizen)) {
    RECEIVE_PACKET_FIELD_ERROR(angrycitizen);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_pollution";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->base_pollution)) {
    RECEIVE_PACKET_FIELD_ERROR(base_pollution);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_tech_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->base_tech_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(base_tech_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_leak_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech_leak_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_leak_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_city_radius_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->border_city_radius_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(border_city_radius_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_size_effect";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->border_size_effect)) {
    RECEIVE_PACKET_FIELD_ERROR(border_size_effect);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_city_permanent_radius_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->border_city_permanent_radius_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(border_city_permanent_radius_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "borders";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(borders);
    }
    real_packet->borders = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_bribe_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->base_bribe_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(base_bribe_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_bonus_style";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(caravan_bonus_style);
    }
    real_packet->caravan_bonus_style = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture_vic_points";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture_vic_points)) {
    RECEIVE_PACKET_FIELD_ERROR(culture_vic_points);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture_vic_lead";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->culture_vic_lead)) {
    RECEIVE_PACKET_FIELD_ERROR(culture_vic_lead);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture_migration_pml";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->culture_migration_pml)) {
    RECEIVE_PACKET_FIELD_ERROR(culture_migration_pml);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history_interest_pml";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->history_interest_pml)) {
    RECEIVE_PACKET_FIELD_ERROR(history_interest_pml);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "celebratesize";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->celebratesize)) {
    RECEIVE_PACKET_FIELD_ERROR(celebratesize);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changable_tax";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->changable_tax)) {
    RECEIVE_PACKET_FIELD_ERROR(changable_tax);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pop_report_zeroes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->pop_report_zeroes)) {
    RECEIVE_PACKET_FIELD_ERROR(pop_report_zeroes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_nationality";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->citizen_nationality)) {
    RECEIVE_PACKET_FIELD_ERROR(citizen_nationality);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_convert_speed";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->citizen_convert_speed)) {
    RECEIVE_PACKET_FIELD_ERROR(citizen_convert_speed);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conquest_convert_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->conquest_convert_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(conquest_convert_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_partisans_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->citizen_partisans_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(citizen_partisans_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citymindist";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->citymindist)) {
    RECEIVE_PACKET_FIELD_ERROR(citymindist);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cooling";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->cooling)) {
    RECEIVE_PACKET_FIELD_ERROR(cooling);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "coolinglevel";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->coolinglevel)) {
    RECEIVE_PACKET_FIELD_ERROR(coolinglevel);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplchance_initial_odds";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->diplchance_initial_odds)) {
    RECEIVE_PACKET_FIELD_ERROR(diplchance_initial_odds);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomacy";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(diplomacy);
    }
    real_packet->diplomacy = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fogofwar";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->fogofwar)) {
    RECEIVE_PACKET_FIELD_ERROR(fogofwar);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->food_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(food_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "foodbox";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->foodbox)) {
    RECEIVE_PACKET_FIELD_ERROR(foodbox);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "forced_gold";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->forced_gold)) {
    RECEIVE_PACKET_FIELD_ERROR(forced_gold);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "forced_luxury";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->forced_luxury)) {
    RECEIVE_PACKET_FIELD_ERROR(forced_luxury);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "forced_science";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->forced_science)) {
    RECEIVE_PACKET_FIELD_ERROR(forced_science);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fulltradesize";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fulltradesize)) {
    RECEIVE_PACKET_FIELD_ERROR(fulltradesize);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_world_rel_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_world_rel_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(trade_world_rel_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_trade_route_val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->min_trade_route_val)) {
    RECEIVE_PACKET_FIELD_ERROR(min_trade_route_val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goods_selection";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(goods_selection);
    }
    real_packet->goods_selection = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_advance_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->global_advance_count)) {
    RECEIVE_PACKET_FIELD_ERROR(global_advance_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_advances";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
    for (i = 0; i < A_LAST; i++) {
      if (!DIO_GET(bool8, &din, &field_addr, &real_packet->global_advances[i])) {
        RECEIVE_PACKET_FIELD_ERROR(global_advances);
      }
    }
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_warming";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->global_warming)) {
    RECEIVE_PACKET_FIELD_ERROR(global_warming);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "globalwarming";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->globalwarming)) {
    RECEIVE_PACKET_FIELD_ERROR(globalwarming);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->gold)) {
    RECEIVE_PACKET_FIELD_ERROR(gold);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold_upkeep_style";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(gold_upkeep_style);
    }
    real_packet->gold_upkeep_style = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infrapoints";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->infrapoints)) {
    RECEIVE_PACKET_FIELD_ERROR(infrapoints);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "revolentype";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(revolentype);
    }
    real_packet->revolentype = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_government_id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(default_government_id);
    }
    real_packet->default_government_id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government_during_revolution_id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(government_during_revolution_id);
    }
    real_packet->government_during_revolution_id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_food_inc";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granary_food_inc)) {
    RECEIVE_PACKET_FIELD_ERROR(granary_food_inc);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_food_ini";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < MAX_GRANARY_INIS; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granary_food_ini[i])) {
        RECEIVE_PACKET_FIELD_ERROR(granary_food_ini);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_num_inis";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->granary_num_inis)) {
    RECEIVE_PACKET_FIELD_ERROR(granary_num_inis);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "great_wonder_owners";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
    for (i = 0; i < B_LAST; i++) {
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->great_wonder_owners[i])) {
        RECEIVE_PACKET_FIELD_ERROR(great_wonder_owners);
      }
    }
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->happy_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(happy_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happyborders";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(happyborders);
    }
    real_packet->happyborders = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "heating";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->heating)) {
    RECEIVE_PACKET_FIELD_ERROR(heating);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_base_factor";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_base_factor)) {
    RECEIVE_PACKET_FIELD_ERROR(illness_base_factor);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_min_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->illness_min_size)) {
    RECEIVE_PACKET_FIELD_ERROR(illness_min_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_on";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->illness_on)) {
    RECEIVE_PACKET_FIELD_ERROR(illness_on);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_pollution_factor";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_pollution_factor)) {
    RECEIVE_PACKET_FIELD_ERROR(illness_pollution_factor);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade_infection";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade_infection)) {
    RECEIVE_PACKET_FIELD_ERROR(illness_trade_infection);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_city_radius_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_city_radius_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(init_city_radius_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_edit_mode";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_edit_mode)) {
    RECEIVE_PACKET_FIELD_ERROR(is_edit_mode);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_new_game";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_new_game)) {
    RECEIVE_PACKET_FIELD_ERROR(is_new_game);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "killcitizen";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->killcitizen)) {
    RECEIVE_PACKET_FIELD_ERROR(killcitizen);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "killstack";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->killstack)) {
    RECEIVE_PACKET_FIELD_ERROR(killstack);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "only_killing_makes_veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->only_killing_makes_veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(only_killing_makes_veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "only_real_fight_makes_veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->only_real_fight_makes_veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(only_real_fight_makes_veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "combat_odds_scaled_veterancy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->combat_odds_scaled_veterancy)) {
    RECEIVE_PACKET_FIELD_ERROR(combat_odds_scaled_veterancy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "damage_reduces_bombard_rate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->damage_reduces_bombard_rate)) {
    RECEIVE_PACKET_FIELD_ERROR(damage_reduces_bombard_rate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_badwallattacker";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->low_firepower_badwallattacker)) {
    RECEIVE_PACKET_FIELD_ERROR(low_firepower_badwallattacker);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_pearl_harbour";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->low_firepower_pearl_harbour)) {
    RECEIVE_PACKET_FIELD_ERROR(low_firepower_pearl_harbour);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_combat_bonus";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->low_firepower_combat_bonus)) {
    RECEIVE_PACKET_FIELD_ERROR(low_firepower_combat_bonus);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_nonnat_bombard";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->low_firepower_nonnat_bombard)) {
    RECEIVE_PACKET_FIELD_ERROR(low_firepower_nonnat_bombard);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuke_pop_loss_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nuke_pop_loss_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(nuke_pop_loss_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuke_defender_survival_chance_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nuke_defender_survival_chance_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(nuke_defender_survival_chance_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_city_center_output";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->min_city_center_output[i])) {
        RECEIVE_PACKET_FIELD_ERROR(min_city_center_output);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "muuk_food_wipe";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->muuk_food_wipe)) {
    RECEIVE_PACKET_FIELD_ERROR(muuk_food_wipe);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "muuk_gold_wipe";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->muuk_gold_wipe)) {
    RECEIVE_PACKET_FIELD_ERROR(muuk_gold_wipe);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "muuk_shield_wipe";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->muuk_shield_wipe)) {
    RECEIVE_PACKET_FIELD_ERROR(muuk_shield_wipe);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "notradesize";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->notradesize)) {
    RECEIVE_PACKET_FIELD_ERROR(notradesize);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuclear_winter";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->nuclear_winter)) {
    RECEIVE_PACKET_FIELD_ERROR(nuclear_winter);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuclearwinter";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->nuclearwinter)) {
    RECEIVE_PACKET_FIELD_ERROR(nuclearwinter);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->phase)) {
    RECEIVE_PACKET_FIELD_ERROR(phase);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase_mode";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(phase_mode);
    }
    real_packet->phase_mode = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pillage_select";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->pillage_select)) {
    RECEIVE_PACKET_FIELD_ERROR(pillage_select);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal_maps_reveals_all_cities";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->steal_maps_reveals_all_cities)) {
    RECEIVE_PACKET_FIELD_ERROR(steal_maps_reveals_all_cities);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "poison_empties_food_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->poison_empties_food_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(poison_empties_food_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_steal_allow_holes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->tech_steal_allow_holes)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_steal_allow_holes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_trade_allow_holes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->tech_trade_allow_holes)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_trade_allow_holes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_trade_loss_allow_holes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->tech_trade_loss_allow_holes)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_trade_loss_allow_holes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_parasite_allow_holes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->tech_parasite_allow_holes)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_parasite_allow_holes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_loss_allow_holes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->tech_loss_allow_holes)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_loss_allow_holes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rapturedelay";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->rapturedelay)) {
    RECEIVE_PACKET_FIELD_ERROR(rapturedelay);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disasters";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disasters)) {
    RECEIVE_PACKET_FIELD_ERROR(disasters);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "restrictinfra";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->restrictinfra)) {
    RECEIVE_PACKET_FIELD_ERROR(restrictinfra);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unreachable_protects";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->unreachable_protects)) {
    RECEIVE_PACKET_FIELD_ERROR(unreachable_protects);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sciencebox";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->sciencebox)) {
    RECEIVE_PACKET_FIELD_ERROR(sciencebox);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shieldbox";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->shieldbox)) {
    RECEIVE_PACKET_FIELD_ERROR(shieldbox);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "skill_level";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(skill_level);
    }
    real_packet->skill_level = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "victory_conditions";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(victory_conditions);
    }
    real_packet->victory_conditions = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team_pooled_research";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->team_pooled_research)) {
    RECEIVE_PACKET_FIELD_ERROR(team_pooled_research);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->tech)) {
    RECEIVE_PACKET_FIELD_ERROR(tech);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_cost_style";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(tech_cost_style);
    }
    real_packet->tech_cost_style = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_leakage";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(tech_leakage);
    }
    real_packet->tech_leakage = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_upkeep_divider";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tech_upkeep_divider)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_upkeep_divider);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_upkeep_style";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(tech_upkeep_style);
    }
    real_packet->tech_upkeep_style = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "techloss_forgiveness";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->techloss_forgiveness)) {
    RECEIVE_PACKET_FIELD_ERROR(techloss_forgiveness);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "free_tech_method";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(free_tech_method);
    }
    real_packet->free_tech_method = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gameloss_style";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(gameloss_style);
    }
    real_packet->gameloss_style = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "timeout";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->timeout)) {
    RECEIVE_PACKET_FIELD_ERROR(timeout);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first_timeout";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->first_timeout)) {
    RECEIVE_PACKET_FIELD_ERROR(first_timeout);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tired_attack";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->tired_attack)) {
    RECEIVE_PACKET_FIELD_ERROR(tired_attack);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trademindist";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->trademindist)) {
    RECEIVE_PACKET_FIELD_ERROR(trademindist);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_revenue_style";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(trade_revenue_style);
    }
    real_packet->trade_revenue_style = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trading_city";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->trading_city)) {
    RECEIVE_PACKET_FIELD_ERROR(trading_city);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trading_gold";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->trading_gold)) {
    RECEIVE_PACKET_FIELD_ERROR(trading_gold);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trading_tech";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->trading_tech)) {
    RECEIVE_PACKET_FIELD_ERROR(trading_tech);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
    RECEIVE_PACKET_FIELD_ERROR(turn);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "warminglevel";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->warminglevel)) {
    RECEIVE_PACKET_FIELD_ERROR(warminglevel);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "year";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->year)) {
    RECEIVE_PACKET_FIELD_ERROR(year);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "year_0_hack";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->year_0_hack)) {
    RECEIVE_PACKET_FIELD_ERROR(year_0_hack);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fragment_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->fragment_count)) {
    RECEIVE_PACKET_FIELD_ERROR(fragment_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "civil_war_enabled";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->civil_war_enabled)) {
    RECEIVE_PACKET_FIELD_ERROR(civil_war_enabled);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "civil_war_bonus_celebrating";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->civil_war_bonus_celebrating)) {
    RECEIVE_PACKET_FIELD_ERROR(civil_war_bonus_celebrating);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "civil_war_bonus_unhappy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->civil_war_bonus_unhappy)) {
    RECEIVE_PACKET_FIELD_ERROR(civil_war_bonus_unhappy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granularity";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granularity)) {
    RECEIVE_PACKET_FIELD_ERROR(granularity);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "small_wonder_visibility";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(small_wonder_visibility);
    }
    real_packet->small_wonder_visibility = readin;
  }

#endif
  log_packet_detailed("packet_game_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_game_info_100, cmp_packet_game_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'add_to_size_limit'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "add_to_size_limit";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->add_to_size_limit)) {
      RECEIVE_PACKET_FIELD_ERROR(add_to_size_limit);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'aifill'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "aifill";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->aifill)) {
      RECEIVE_PACKET_FIELD_ERROR(aifill);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'persistent_ready'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "persistent_ready";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(persistent_ready);
      }
      real_packet->persistent_ready = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'airlifting_style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "airlifting_style";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(airlifting_style);
      }
      real_packet->airlifting_style = readin;
    }
  }
  real_packet->airlift_from_always_enabled = BV_ISSET(fields, 4);
  real_packet->airlift_to_always_enabled = BV_ISSET(fields, 5);
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'angrycitizen'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "angrycitizen";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->angrycitizen)) {
      RECEIVE_PACKET_FIELD_ERROR(angrycitizen);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'base_pollution'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "base_pollution";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->base_pollution)) {
      RECEIVE_PACKET_FIELD_ERROR(base_pollution);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'base_tech_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "base_tech_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->base_tech_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(base_tech_cost);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'tech_leak_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech_leak_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech_leak_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(tech_leak_pct);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'border_city_radius_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "border_city_radius_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->border_city_radius_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(border_city_radius_sq);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'border_size_effect'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "border_size_effect";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->border_size_effect)) {
      RECEIVE_PACKET_FIELD_ERROR(border_size_effect);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'border_city_permanent_radius_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "border_city_permanent_radius_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->border_city_permanent_radius_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(border_city_permanent_radius_sq);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'borders'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "borders";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(borders);
      }
      real_packet->borders = readin;
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'base_bribe_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "base_bribe_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->base_bribe_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(base_bribe_cost);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'caravan_bonus_style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "caravan_bonus_style";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(caravan_bonus_style);
      }
      real_packet->caravan_bonus_style = readin;
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'culture_vic_points'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "culture_vic_points";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture_vic_points)) {
      RECEIVE_PACKET_FIELD_ERROR(culture_vic_points);
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'culture_vic_lead'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "culture_vic_lead";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->culture_vic_lead)) {
      RECEIVE_PACKET_FIELD_ERROR(culture_vic_lead);
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'culture_migration_pml'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "culture_migration_pml";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->culture_migration_pml)) {
      RECEIVE_PACKET_FIELD_ERROR(culture_migration_pml);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'history_interest_pml'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "history_interest_pml";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->history_interest_pml)) {
      RECEIVE_PACKET_FIELD_ERROR(history_interest_pml);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'celebratesize'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "celebratesize";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->celebratesize)) {
      RECEIVE_PACKET_FIELD_ERROR(celebratesize);
    }
  }
  real_packet->changable_tax = BV_ISSET(fields, 21);
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'pop_report_zeroes'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "pop_report_zeroes";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->pop_report_zeroes)) {
      RECEIVE_PACKET_FIELD_ERROR(pop_report_zeroes);
    }
  }
  real_packet->citizen_nationality = BV_ISSET(fields, 23);
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'citizen_convert_speed'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "citizen_convert_speed";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->citizen_convert_speed)) {
      RECEIVE_PACKET_FIELD_ERROR(citizen_convert_speed);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'conquest_convert_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "conquest_convert_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->conquest_convert_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(conquest_convert_pct);
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'citizen_partisans_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "citizen_partisans_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->citizen_partisans_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(citizen_partisans_pct);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'citymindist'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "citymindist";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->citymindist)) {
      RECEIVE_PACKET_FIELD_ERROR(citymindist);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'cooling'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cooling";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->cooling)) {
      RECEIVE_PACKET_FIELD_ERROR(cooling);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'coolinglevel'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "coolinglevel";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->coolinglevel)) {
      RECEIVE_PACKET_FIELD_ERROR(coolinglevel);
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'diplchance_initial_odds'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "diplchance_initial_odds";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->diplchance_initial_odds)) {
      RECEIVE_PACKET_FIELD_ERROR(diplchance_initial_odds);
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  got field 'diplomacy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "diplomacy";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(diplomacy);
      }
      real_packet->diplomacy = readin;
    }
  }
  real_packet->fogofwar = BV_ISSET(fields, 32);
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'food_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "food_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->food_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(food_cost);
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'foodbox'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "foodbox";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->foodbox)) {
      RECEIVE_PACKET_FIELD_ERROR(foodbox);
    }
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  got field 'forced_gold'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "forced_gold";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->forced_gold)) {
      RECEIVE_PACKET_FIELD_ERROR(forced_gold);
    }
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  got field 'forced_luxury'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "forced_luxury";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->forced_luxury)) {
      RECEIVE_PACKET_FIELD_ERROR(forced_luxury);
    }
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  got field 'forced_science'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "forced_science";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->forced_science)) {
      RECEIVE_PACKET_FIELD_ERROR(forced_science);
    }
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  got field 'fulltradesize'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "fulltradesize";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fulltradesize)) {
      RECEIVE_PACKET_FIELD_ERROR(fulltradesize);
    }
  }
  if (BV_ISSET(fields, 39)) {
    log_packet_detailed("  got field 'trade_world_rel_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "trade_world_rel_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_world_rel_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(trade_world_rel_pct);
    }
  }
  if (BV_ISSET(fields, 40)) {
    log_packet_detailed("  got field 'min_trade_route_val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "min_trade_route_val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->min_trade_route_val)) {
      RECEIVE_PACKET_FIELD_ERROR(min_trade_route_val);
    }
  }
  if (BV_ISSET(fields, 41)) {
    log_packet_detailed("  got field 'goods_selection'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "goods_selection";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(goods_selection);
      }
      real_packet->goods_selection = readin;
    }
  }
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  got field 'global_advance_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "global_advance_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->global_advance_count)) {
      RECEIVE_PACKET_FIELD_ERROR(global_advance_count);
    }
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  got field 'global_advances'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "global_advances";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
    #ifdef FREECIV_JSON_CONNECTION
    int count;
    
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
    
    for (count = 0;; count++) {
      int i;
    
      field_addr.sub_location->number = count;
    
      /* Enter diff array element (start at the index address). */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
    #else /* FREECIV_JSON_CONNECTION */
    while (TRUE) {
      int i;
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (!DIO_GET(uint8, &din, &field_addr, &i)) {
        RECEIVE_PACKET_FIELD_ERROR(global_advances);
      }
      if (i == 255) {
    #ifdef FREECIV_JSON_CONNECTION
        /* Exit diff array element. */
        free(field_addr.sub_location->sub_location);
        field_addr.sub_location->sub_location = NULL;
    
        /* Exit diff array. */
        free(field_addr.sub_location);
        field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    
        break;
      }
      if (i > A_LAST) {
        RECEIVE_PACKET_FIELD_ERROR(global_advances,
                                   ": unexpected value %d "
                                   "(> A_LAST) in array diff",
                                   i);
      } else {
    #ifdef FREECIV_JSON_CONNECTION
        /* Content address. */
        field_addr.sub_location->sub_location->number = 1;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(bool8, &din, &field_addr, &real_packet->global_advances[i])) {
          RECEIVE_PACKET_FIELD_ERROR(global_advances);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
    
    #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  real_packet->global_warming = BV_ISSET(fields, 44);
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  got field 'globalwarming'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "globalwarming";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->globalwarming)) {
      RECEIVE_PACKET_FIELD_ERROR(globalwarming);
    }
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  got field 'gold'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gold";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->gold)) {
      RECEIVE_PACKET_FIELD_ERROR(gold);
    }
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  got field 'gold_upkeep_style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gold_upkeep_style";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(gold_upkeep_style);
      }
      real_packet->gold_upkeep_style = readin;
    }
  }
  if (BV_ISSET(fields, 48)) {
    log_packet_detailed("  got field 'infrapoints'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "infrapoints";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->infrapoints)) {
      RECEIVE_PACKET_FIELD_ERROR(infrapoints);
    }
  }
  if (BV_ISSET(fields, 49)) {
    log_packet_detailed("  got field 'revolentype'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "revolentype";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(revolentype);
      }
      real_packet->revolentype = readin;
    }
  }
  if (BV_ISSET(fields, 50)) {
    log_packet_detailed("  got field 'default_government_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "default_government_id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(default_government_id);
      }
      real_packet->default_government_id = readin;
    }
  }
  if (BV_ISSET(fields, 51)) {
    log_packet_detailed("  got field 'government_during_revolution_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "government_during_revolution_id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(government_during_revolution_id);
      }
      real_packet->government_during_revolution_id = readin;
    }
  }
  if (BV_ISSET(fields, 52)) {
    log_packet_detailed("  got field 'granary_food_inc'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "granary_food_inc";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granary_food_inc)) {
      RECEIVE_PACKET_FIELD_ERROR(granary_food_inc);
    }
  }
  if (BV_ISSET(fields, 53)) {
    log_packet_detailed("  got field 'granary_food_ini'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "granary_food_ini";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < MAX_GRANARY_INIS; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granary_food_ini[i])) {
          RECEIVE_PACKET_FIELD_ERROR(granary_food_ini);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 54)) {
    log_packet_detailed("  got field 'granary_num_inis'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "granary_num_inis";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->granary_num_inis)) {
      RECEIVE_PACKET_FIELD_ERROR(granary_num_inis);
    }
  }
  if (BV_ISSET(fields, 55)) {
    log_packet_detailed("  got field 'great_wonder_owners'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "great_wonder_owners";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
    #ifdef FREECIV_JSON_CONNECTION
    int count;
    
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
    
    for (count = 0;; count++) {
      int i;
    
      field_addr.sub_location->number = count;
    
      /* Enter diff array element (start at the index address). */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
    #else /* FREECIV_JSON_CONNECTION */
    while (TRUE) {
      int i;
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (!DIO_GET(uint8, &din, &field_addr, &i)) {
        RECEIVE_PACKET_FIELD_ERROR(great_wonder_owners);
      }
      if (i == 255) {
    #ifdef FREECIV_JSON_CONNECTION
        /* Exit diff array element. */
        free(field_addr.sub_location->sub_location);
        field_addr.sub_location->sub_location = NULL;
    
        /* Exit diff array. */
        free(field_addr.sub_location);
        field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    
        break;
      }
      if (i > B_LAST) {
        RECEIVE_PACKET_FIELD_ERROR(great_wonder_owners,
                                   ": unexpected value %d "
                                   "(> B_LAST) in array diff",
                                   i);
      } else {
    #ifdef FREECIV_JSON_CONNECTION
        /* Content address. */
        field_addr.sub_location->sub_location->number = 1;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->great_wonder_owners[i])) {
          RECEIVE_PACKET_FIELD_ERROR(great_wonder_owners);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
    
    #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 56)) {
    log_packet_detailed("  got field 'happy_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "happy_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->happy_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(happy_cost);
    }
  }
  if (BV_ISSET(fields, 57)) {
    log_packet_detailed("  got field 'happyborders'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "happyborders";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(happyborders);
      }
      real_packet->happyborders = readin;
    }
  }
  if (BV_ISSET(fields, 58)) {
    log_packet_detailed("  got field 'heating'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "heating";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->heating)) {
      RECEIVE_PACKET_FIELD_ERROR(heating);
    }
  }
  if (BV_ISSET(fields, 59)) {
    log_packet_detailed("  got field 'illness_base_factor'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "illness_base_factor";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_base_factor)) {
      RECEIVE_PACKET_FIELD_ERROR(illness_base_factor);
    }
  }
  if (BV_ISSET(fields, 60)) {
    log_packet_detailed("  got field 'illness_min_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "illness_min_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->illness_min_size)) {
      RECEIVE_PACKET_FIELD_ERROR(illness_min_size);
    }
  }
  real_packet->illness_on = BV_ISSET(fields, 61);
  if (BV_ISSET(fields, 62)) {
    log_packet_detailed("  got field 'illness_pollution_factor'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "illness_pollution_factor";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_pollution_factor)) {
      RECEIVE_PACKET_FIELD_ERROR(illness_pollution_factor);
    }
  }
  if (BV_ISSET(fields, 63)) {
    log_packet_detailed("  got field 'illness_trade_infection'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "illness_trade_infection";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade_infection)) {
      RECEIVE_PACKET_FIELD_ERROR(illness_trade_infection);
    }
  }
  if (BV_ISSET(fields, 64)) {
    log_packet_detailed("  got field 'init_city_radius_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "init_city_radius_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_city_radius_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(init_city_radius_sq);
    }
  }
  real_packet->is_edit_mode = BV_ISSET(fields, 65);
  real_packet->is_new_game = BV_ISSET(fields, 66);
  real_packet->killcitizen = BV_ISSET(fields, 67);
  real_packet->killstack = BV_ISSET(fields, 68);
  real_packet->only_killing_makes_veteran = BV_ISSET(fields, 69);
  real_packet->only_real_fight_makes_veteran = BV_ISSET(fields, 70);
  real_packet->combat_odds_scaled_veterancy = BV_ISSET(fields, 71);
  real_packet->damage_reduces_bombard_rate = BV_ISSET(fields, 72);
  if (BV_ISSET(fields, 73)) {
    log_packet_detailed("  got field 'low_firepower_badwallattacker'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "low_firepower_badwallattacker";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->low_firepower_badwallattacker)) {
      RECEIVE_PACKET_FIELD_ERROR(low_firepower_badwallattacker);
    }
  }
  if (BV_ISSET(fields, 74)) {
    log_packet_detailed("  got field 'low_firepower_pearl_harbour'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "low_firepower_pearl_harbour";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->low_firepower_pearl_harbour)) {
      RECEIVE_PACKET_FIELD_ERROR(low_firepower_pearl_harbour);
    }
  }
  if (BV_ISSET(fields, 75)) {
    log_packet_detailed("  got field 'low_firepower_combat_bonus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "low_firepower_combat_bonus";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->low_firepower_combat_bonus)) {
      RECEIVE_PACKET_FIELD_ERROR(low_firepower_combat_bonus);
    }
  }
  if (BV_ISSET(fields, 76)) {
    log_packet_detailed("  got field 'low_firepower_nonnat_bombard'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "low_firepower_nonnat_bombard";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->low_firepower_nonnat_bombard)) {
      RECEIVE_PACKET_FIELD_ERROR(low_firepower_nonnat_bombard);
    }
  }
  if (BV_ISSET(fields, 77)) {
    log_packet_detailed("  got field 'nuke_pop_loss_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nuke_pop_loss_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nuke_pop_loss_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(nuke_pop_loss_pct);
    }
  }
  if (BV_ISSET(fields, 78)) {
    log_packet_detailed("  got field 'nuke_defender_survival_chance_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nuke_defender_survival_chance_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nuke_defender_survival_chance_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(nuke_defender_survival_chance_pct);
    }
  }
  if (BV_ISSET(fields, 79)) {
    log_packet_detailed("  got field 'min_city_center_output'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "min_city_center_output";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->min_city_center_output[i])) {
          RECEIVE_PACKET_FIELD_ERROR(min_city_center_output);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  real_packet->muuk_food_wipe = BV_ISSET(fields, 80);
  real_packet->muuk_gold_wipe = BV_ISSET(fields, 81);
  real_packet->muuk_shield_wipe = BV_ISSET(fields, 82);
  if (BV_ISSET(fields, 83)) {
    log_packet_detailed("  got field 'notradesize'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "notradesize";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->notradesize)) {
      RECEIVE_PACKET_FIELD_ERROR(notradesize);
    }
  }
  real_packet->nuclear_winter = BV_ISSET(fields, 84);
  if (BV_ISSET(fields, 85)) {
    log_packet_detailed("  got field 'nuclearwinter'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nuclearwinter";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->nuclearwinter)) {
      RECEIVE_PACKET_FIELD_ERROR(nuclearwinter);
    }
  }
  if (BV_ISSET(fields, 86)) {
    log_packet_detailed("  got field 'phase'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "phase";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->phase)) {
      RECEIVE_PACKET_FIELD_ERROR(phase);
    }
  }
  if (BV_ISSET(fields, 87)) {
    log_packet_detailed("  got field 'phase_mode'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "phase_mode";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(phase_mode);
      }
      real_packet->phase_mode = readin;
    }
  }
  real_packet->pillage_select = BV_ISSET(fields, 88);
  real_packet->steal_maps_reveals_all_cities = BV_ISSET(fields, 89);
  real_packet->poison_empties_food_stock = BV_ISSET(fields, 90);
  real_packet->tech_steal_allow_holes = BV_ISSET(fields, 91);
  real_packet->tech_trade_allow_holes = BV_ISSET(fields, 92);
  real_packet->tech_trade_loss_allow_holes = BV_ISSET(fields, 93);
  real_packet->tech_parasite_allow_holes = BV_ISSET(fields, 94);
  real_packet->tech_loss_allow_holes = BV_ISSET(fields, 95);
  if (BV_ISSET(fields, 96)) {
    log_packet_detailed("  got field 'rapturedelay'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rapturedelay";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->rapturedelay)) {
      RECEIVE_PACKET_FIELD_ERROR(rapturedelay);
    }
  }
  if (BV_ISSET(fields, 97)) {
    log_packet_detailed("  got field 'disasters'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "disasters";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disasters)) {
      RECEIVE_PACKET_FIELD_ERROR(disasters);
    }
  }
  real_packet->restrictinfra = BV_ISSET(fields, 98);
  real_packet->unreachable_protects = BV_ISSET(fields, 99);
  if (BV_ISSET(fields, 100)) {
    log_packet_detailed("  got field 'sciencebox'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sciencebox";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->sciencebox)) {
      RECEIVE_PACKET_FIELD_ERROR(sciencebox);
    }
  }
  if (BV_ISSET(fields, 101)) {
    log_packet_detailed("  got field 'shieldbox'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "shieldbox";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->shieldbox)) {
      RECEIVE_PACKET_FIELD_ERROR(shieldbox);
    }
  }
  if (BV_ISSET(fields, 102)) {
    log_packet_detailed("  got field 'skill_level'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "skill_level";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(skill_level);
      }
      real_packet->skill_level = readin;
    }
  }
  if (BV_ISSET(fields, 103)) {
    log_packet_detailed("  got field 'victory_conditions'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "victory_conditions";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(victory_conditions);
      }
      real_packet->victory_conditions = readin;
    }
  }
  real_packet->team_pooled_research = BV_ISSET(fields, 104);
  if (BV_ISSET(fields, 105)) {
    log_packet_detailed("  got field 'tech'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->tech)) {
      RECEIVE_PACKET_FIELD_ERROR(tech);
    }
  }
  if (BV_ISSET(fields, 106)) {
    log_packet_detailed("  got field 'tech_cost_style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech_cost_style";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(tech_cost_style);
      }
      real_packet->tech_cost_style = readin;
    }
  }
  if (BV_ISSET(fields, 107)) {
    log_packet_detailed("  got field 'tech_leakage'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech_leakage";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(tech_leakage);
      }
      real_packet->tech_leakage = readin;
    }
  }
  if (BV_ISSET(fields, 108)) {
    log_packet_detailed("  got field 'tech_upkeep_divider'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech_upkeep_divider";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tech_upkeep_divider)) {
      RECEIVE_PACKET_FIELD_ERROR(tech_upkeep_divider);
    }
  }
  if (BV_ISSET(fields, 109)) {
    log_packet_detailed("  got field 'tech_upkeep_style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech_upkeep_style";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(tech_upkeep_style);
      }
      real_packet->tech_upkeep_style = readin;
    }
  }
  if (BV_ISSET(fields, 110)) {
    log_packet_detailed("  got field 'techloss_forgiveness'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "techloss_forgiveness";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->techloss_forgiveness)) {
      RECEIVE_PACKET_FIELD_ERROR(techloss_forgiveness);
    }
  }
  if (BV_ISSET(fields, 111)) {
    log_packet_detailed("  got field 'free_tech_method'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "free_tech_method";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(free_tech_method);
      }
      real_packet->free_tech_method = readin;
    }
  }
  if (BV_ISSET(fields, 112)) {
    log_packet_detailed("  got field 'gameloss_style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gameloss_style";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(gameloss_style);
      }
      real_packet->gameloss_style = readin;
    }
  }
  if (BV_ISSET(fields, 113)) {
    log_packet_detailed("  got field 'timeout'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "timeout";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->timeout)) {
      RECEIVE_PACKET_FIELD_ERROR(timeout);
    }
  }
  if (BV_ISSET(fields, 114)) {
    log_packet_detailed("  got field 'first_timeout'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "first_timeout";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->first_timeout)) {
      RECEIVE_PACKET_FIELD_ERROR(first_timeout);
    }
  }
  real_packet->tired_attack = BV_ISSET(fields, 115);
  if (BV_ISSET(fields, 116)) {
    log_packet_detailed("  got field 'trademindist'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "trademindist";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->trademindist)) {
      RECEIVE_PACKET_FIELD_ERROR(trademindist);
    }
  }
  if (BV_ISSET(fields, 117)) {
    log_packet_detailed("  got field 'trade_revenue_style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "trade_revenue_style";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(trade_revenue_style);
      }
      real_packet->trade_revenue_style = readin;
    }
  }
  real_packet->trading_city = BV_ISSET(fields, 118);
  real_packet->trading_gold = BV_ISSET(fields, 119);
  real_packet->trading_tech = BV_ISSET(fields, 120);
  if (BV_ISSET(fields, 121)) {
    log_packet_detailed("  got field 'turn'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
      RECEIVE_PACKET_FIELD_ERROR(turn);
    }
  }
  if (BV_ISSET(fields, 122)) {
    log_packet_detailed("  got field 'warminglevel'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "warminglevel";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->warminglevel)) {
      RECEIVE_PACKET_FIELD_ERROR(warminglevel);
    }
  }
  if (BV_ISSET(fields, 123)) {
    log_packet_detailed("  got field 'year'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "year";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->year)) {
      RECEIVE_PACKET_FIELD_ERROR(year);
    }
  }
  real_packet->year_0_hack = BV_ISSET(fields, 124);
  if (BV_ISSET(fields, 125)) {
    log_packet_detailed("  got field 'fragment_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "fragment_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->fragment_count)) {
      RECEIVE_PACKET_FIELD_ERROR(fragment_count);
    }
  }
  real_packet->civil_war_enabled = BV_ISSET(fields, 126);
  if (BV_ISSET(fields, 127)) {
    log_packet_detailed("  got field 'civil_war_bonus_celebrating'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "civil_war_bonus_celebrating";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->civil_war_bonus_celebrating)) {
      RECEIVE_PACKET_FIELD_ERROR(civil_war_bonus_celebrating);
    }
  }
  if (BV_ISSET(fields, 128)) {
    log_packet_detailed("  got field 'civil_war_bonus_unhappy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "civil_war_bonus_unhappy";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->civil_war_bonus_unhappy)) {
      RECEIVE_PACKET_FIELD_ERROR(civil_war_bonus_unhappy);
    }
  }
  if (BV_ISSET(fields, 129)) {
    log_packet_detailed("  got field 'granularity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "granularity";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granularity)) {
      RECEIVE_PACKET_FIELD_ERROR(granularity);
    }
  }
  if (BV_ISSET(fields, 130)) {
    log_packet_detailed("  got field 'small_wonder_visibility'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "small_wonder_visibility";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(small_wonder_visibility);
      }
      real_packet->small_wonder_visibility = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_game_info_100(struct connection *pc, const struct packet_game_info *packet)
{
  const struct packet_game_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_game_info_100_fields fields;
  struct packet_game_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_GAME_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_GAME_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_game_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_game_info_100, cmp_packet_game_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->add_to_size_limit != real_packet->add_to_size_limit);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->aifill != real_packet->aifill);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->persistent_ready != real_packet->persistent_ready);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->airlifting_style != real_packet->airlifting_style);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->airlift_from_always_enabled != real_packet->airlift_from_always_enabled);
  if (differ) {
    different++;
  }
  if (packet->airlift_from_always_enabled) {
    BV_SET(fields, 4);
  }

  differ = (old->airlift_to_always_enabled != real_packet->airlift_to_always_enabled);
  if (differ) {
    different++;
  }
  if (packet->airlift_to_always_enabled) {
    BV_SET(fields, 5);
  }

  differ = (old->angrycitizen != real_packet->angrycitizen);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (old->base_pollution != real_packet->base_pollution);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }

  differ = (old->base_tech_cost != real_packet->base_tech_cost);
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }

  differ = (old->tech_leak_pct != real_packet->tech_leak_pct);
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }

  differ = (old->border_city_radius_sq != real_packet->border_city_radius_sq);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (old->border_size_effect != real_packet->border_size_effect);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }

  differ = (old->border_city_permanent_radius_sq != real_packet->border_city_permanent_radius_sq);
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }

  differ = (old->borders != real_packet->borders);
  if (differ) {
    different++;
    BV_SET(fields, 13);
  }

  differ = (old->base_bribe_cost != real_packet->base_bribe_cost);
  if (differ) {
    different++;
    BV_SET(fields, 14);
  }

  differ = (old->caravan_bonus_style != real_packet->caravan_bonus_style);
  if (differ) {
    different++;
    BV_SET(fields, 15);
  }

  differ = (old->culture_vic_points != real_packet->culture_vic_points);
  if (differ) {
    different++;
    BV_SET(fields, 16);
  }

  differ = (old->culture_vic_lead != real_packet->culture_vic_lead);
  if (differ) {
    different++;
    BV_SET(fields, 17);
  }

  differ = (old->culture_migration_pml != real_packet->culture_migration_pml);
  if (differ) {
    different++;
    BV_SET(fields, 18);
  }

  differ = (old->history_interest_pml != real_packet->history_interest_pml);
  if (differ) {
    different++;
    BV_SET(fields, 19);
  }

  differ = (old->celebratesize != real_packet->celebratesize);
  if (differ) {
    different++;
    BV_SET(fields, 20);
  }

  differ = (old->changable_tax != real_packet->changable_tax);
  if (differ) {
    different++;
  }
  if (packet->changable_tax) {
    BV_SET(fields, 21);
  }

  differ = (old->pop_report_zeroes != real_packet->pop_report_zeroes);
  if (differ) {
    different++;
    BV_SET(fields, 22);
  }

  differ = (old->citizen_nationality != real_packet->citizen_nationality);
  if (differ) {
    different++;
  }
  if (packet->citizen_nationality) {
    BV_SET(fields, 23);
  }

  differ = (old->citizen_convert_speed != real_packet->citizen_convert_speed);
  if (differ) {
    different++;
    BV_SET(fields, 24);
  }

  differ = (old->conquest_convert_pct != real_packet->conquest_convert_pct);
  if (differ) {
    different++;
    BV_SET(fields, 25);
  }

  differ = (old->citizen_partisans_pct != real_packet->citizen_partisans_pct);
  if (differ) {
    different++;
    BV_SET(fields, 26);
  }

  differ = (old->citymindist != real_packet->citymindist);
  if (differ) {
    different++;
    BV_SET(fields, 27);
  }

  differ = (old->cooling != real_packet->cooling);
  if (differ) {
    different++;
    BV_SET(fields, 28);
  }

  differ = (old->coolinglevel != real_packet->coolinglevel);
  if (differ) {
    different++;
    BV_SET(fields, 29);
  }

  differ = !BV_ARE_EQUAL(old->diplchance_initial_odds, real_packet->diplchance_initial_odds);
  if (differ) {
    different++;
    BV_SET(fields, 30);
  }

  differ = (old->diplomacy != real_packet->diplomacy);
  if (differ) {
    different++;
    BV_SET(fields, 31);
  }

  differ = (old->fogofwar != real_packet->fogofwar);
  if (differ) {
    different++;
  }
  if (packet->fogofwar) {
    BV_SET(fields, 32);
  }

  differ = (old->food_cost != real_packet->food_cost);
  if (differ) {
    different++;
    BV_SET(fields, 33);
  }

  differ = (old->foodbox != real_packet->foodbox);
  if (differ) {
    different++;
    BV_SET(fields, 34);
  }

  differ = (old->forced_gold != real_packet->forced_gold);
  if (differ) {
    different++;
    BV_SET(fields, 35);
  }

  differ = (old->forced_luxury != real_packet->forced_luxury);
  if (differ) {
    different++;
    BV_SET(fields, 36);
  }

  differ = (old->forced_science != real_packet->forced_science);
  if (differ) {
    different++;
    BV_SET(fields, 37);
  }

  differ = (old->fulltradesize != real_packet->fulltradesize);
  if (differ) {
    different++;
    BV_SET(fields, 38);
  }

  differ = (old->trade_world_rel_pct != real_packet->trade_world_rel_pct);
  if (differ) {
    different++;
    BV_SET(fields, 39);
  }

  differ = (old->min_trade_route_val != real_packet->min_trade_route_val);
  if (differ) {
    different++;
    BV_SET(fields, 40);
  }

  differ = (old->goods_selection != real_packet->goods_selection);
  if (differ) {
    different++;
    BV_SET(fields, 41);
  }

  differ = (old->global_advance_count != real_packet->global_advance_count);
  if (differ) {
    different++;
    BV_SET(fields, 42);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < A_LAST; i++) {
          if (old->global_advances[i] != real_packet->global_advances[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 43);
  }

  differ = (old->global_warming != real_packet->global_warming);
  if (differ) {
    different++;
  }
  if (packet->global_warming) {
    BV_SET(fields, 44);
  }

  differ = (old->globalwarming != real_packet->globalwarming);
  if (differ) {
    different++;
    BV_SET(fields, 45);
  }

  differ = (old->gold != real_packet->gold);
  if (differ) {
    different++;
    BV_SET(fields, 46);
  }

  differ = (old->gold_upkeep_style != real_packet->gold_upkeep_style);
  if (differ) {
    different++;
    BV_SET(fields, 47);
  }

  differ = (old->infrapoints != real_packet->infrapoints);
  if (differ) {
    different++;
    BV_SET(fields, 48);
  }

  differ = (old->revolentype != real_packet->revolentype);
  if (differ) {
    different++;
    BV_SET(fields, 49);
  }

  differ = (old->default_government_id != real_packet->default_government_id);
  if (differ) {
    different++;
    BV_SET(fields, 50);
  }

  differ = (old->government_during_revolution_id != real_packet->government_during_revolution_id);
  if (differ) {
    different++;
    BV_SET(fields, 51);
  }

  differ = (old->granary_food_inc != real_packet->granary_food_inc);
  if (differ) {
    different++;
    BV_SET(fields, 52);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < MAX_GRANARY_INIS; i++) {
          if (old->granary_food_ini[i] != real_packet->granary_food_ini[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 53);
  }

  differ = (old->granary_num_inis != real_packet->granary_num_inis);
  if (differ) {
    different++;
    BV_SET(fields, 54);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < B_LAST; i++) {
          if (old->great_wonder_owners[i] != real_packet->great_wonder_owners[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 55);
  }

  differ = (old->happy_cost != real_packet->happy_cost);
  if (differ) {
    different++;
    BV_SET(fields, 56);
  }

  differ = (old->happyborders != real_packet->happyborders);
  if (differ) {
    different++;
    BV_SET(fields, 57);
  }

  differ = (old->heating != real_packet->heating);
  if (differ) {
    different++;
    BV_SET(fields, 58);
  }

  differ = (old->illness_base_factor != real_packet->illness_base_factor);
  if (differ) {
    different++;
    BV_SET(fields, 59);
  }

  differ = (old->illness_min_size != real_packet->illness_min_size);
  if (differ) {
    different++;
    BV_SET(fields, 60);
  }

  differ = (old->illness_on != real_packet->illness_on);
  if (differ) {
    different++;
  }
  if (packet->illness_on) {
    BV_SET(fields, 61);
  }

  differ = (old->illness_pollution_factor != real_packet->illness_pollution_factor);
  if (differ) {
    different++;
    BV_SET(fields, 62);
  }

  differ = (old->illness_trade_infection != real_packet->illness_trade_infection);
  if (differ) {
    different++;
    BV_SET(fields, 63);
  }

  differ = (old->init_city_radius_sq != real_packet->init_city_radius_sq);
  if (differ) {
    different++;
    BV_SET(fields, 64);
  }

  differ = (old->is_edit_mode != real_packet->is_edit_mode);
  if (differ) {
    different++;
  }
  if (packet->is_edit_mode) {
    BV_SET(fields, 65);
  }

  differ = (old->is_new_game != real_packet->is_new_game);
  if (differ) {
    different++;
  }
  if (packet->is_new_game) {
    BV_SET(fields, 66);
  }

  differ = (old->killcitizen != real_packet->killcitizen);
  if (differ) {
    different++;
  }
  if (packet->killcitizen) {
    BV_SET(fields, 67);
  }

  differ = (old->killstack != real_packet->killstack);
  if (differ) {
    different++;
  }
  if (packet->killstack) {
    BV_SET(fields, 68);
  }

  differ = (old->only_killing_makes_veteran != real_packet->only_killing_makes_veteran);
  if (differ) {
    different++;
  }
  if (packet->only_killing_makes_veteran) {
    BV_SET(fields, 69);
  }

  differ = (old->only_real_fight_makes_veteran != real_packet->only_real_fight_makes_veteran);
  if (differ) {
    different++;
  }
  if (packet->only_real_fight_makes_veteran) {
    BV_SET(fields, 70);
  }

  differ = (old->combat_odds_scaled_veterancy != real_packet->combat_odds_scaled_veterancy);
  if (differ) {
    different++;
  }
  if (packet->combat_odds_scaled_veterancy) {
    BV_SET(fields, 71);
  }

  differ = (old->damage_reduces_bombard_rate != real_packet->damage_reduces_bombard_rate);
  if (differ) {
    different++;
  }
  if (packet->damage_reduces_bombard_rate) {
    BV_SET(fields, 72);
  }

  differ = (old->low_firepower_badwallattacker != real_packet->low_firepower_badwallattacker);
  if (differ) {
    different++;
    BV_SET(fields, 73);
  }

  differ = (old->low_firepower_pearl_harbour != real_packet->low_firepower_pearl_harbour);
  if (differ) {
    different++;
    BV_SET(fields, 74);
  }

  differ = (old->low_firepower_combat_bonus != real_packet->low_firepower_combat_bonus);
  if (differ) {
    different++;
    BV_SET(fields, 75);
  }

  differ = (old->low_firepower_nonnat_bombard != real_packet->low_firepower_nonnat_bombard);
  if (differ) {
    different++;
    BV_SET(fields, 76);
  }

  differ = (old->nuke_pop_loss_pct != real_packet->nuke_pop_loss_pct);
  if (differ) {
    different++;
    BV_SET(fields, 77);
  }

  differ = (old->nuke_defender_survival_chance_pct != real_packet->nuke_defender_survival_chance_pct);
  if (differ) {
    different++;
    BV_SET(fields, 78);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->min_city_center_output[i] != real_packet->min_city_center_output[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 79);
  }

  differ = (old->muuk_food_wipe != real_packet->muuk_food_wipe);
  if (differ) {
    different++;
  }
  if (packet->muuk_food_wipe) {
    BV_SET(fields, 80);
  }

  differ = (old->muuk_gold_wipe != real_packet->muuk_gold_wipe);
  if (differ) {
    different++;
  }
  if (packet->muuk_gold_wipe) {
    BV_SET(fields, 81);
  }

  differ = (old->muuk_shield_wipe != real_packet->muuk_shield_wipe);
  if (differ) {
    different++;
  }
  if (packet->muuk_shield_wipe) {
    BV_SET(fields, 82);
  }

  differ = (old->notradesize != real_packet->notradesize);
  if (differ) {
    different++;
    BV_SET(fields, 83);
  }

  differ = (old->nuclear_winter != real_packet->nuclear_winter);
  if (differ) {
    different++;
  }
  if (packet->nuclear_winter) {
    BV_SET(fields, 84);
  }

  differ = (old->nuclearwinter != real_packet->nuclearwinter);
  if (differ) {
    different++;
    BV_SET(fields, 85);
  }

  differ = (old->phase != real_packet->phase);
  if (differ) {
    different++;
    BV_SET(fields, 86);
  }

  differ = (old->phase_mode != real_packet->phase_mode);
  if (differ) {
    different++;
    BV_SET(fields, 87);
  }

  differ = (old->pillage_select != real_packet->pillage_select);
  if (differ) {
    different++;
  }
  if (packet->pillage_select) {
    BV_SET(fields, 88);
  }

  differ = (old->steal_maps_reveals_all_cities != real_packet->steal_maps_reveals_all_cities);
  if (differ) {
    different++;
  }
  if (packet->steal_maps_reveals_all_cities) {
    BV_SET(fields, 89);
  }

  differ = (old->poison_empties_food_stock != real_packet->poison_empties_food_stock);
  if (differ) {
    different++;
  }
  if (packet->poison_empties_food_stock) {
    BV_SET(fields, 90);
  }

  differ = (old->tech_steal_allow_holes != real_packet->tech_steal_allow_holes);
  if (differ) {
    different++;
  }
  if (packet->tech_steal_allow_holes) {
    BV_SET(fields, 91);
  }

  differ = (old->tech_trade_allow_holes != real_packet->tech_trade_allow_holes);
  if (differ) {
    different++;
  }
  if (packet->tech_trade_allow_holes) {
    BV_SET(fields, 92);
  }

  differ = (old->tech_trade_loss_allow_holes != real_packet->tech_trade_loss_allow_holes);
  if (differ) {
    different++;
  }
  if (packet->tech_trade_loss_allow_holes) {
    BV_SET(fields, 93);
  }

  differ = (old->tech_parasite_allow_holes != real_packet->tech_parasite_allow_holes);
  if (differ) {
    different++;
  }
  if (packet->tech_parasite_allow_holes) {
    BV_SET(fields, 94);
  }

  differ = (old->tech_loss_allow_holes != real_packet->tech_loss_allow_holes);
  if (differ) {
    different++;
  }
  if (packet->tech_loss_allow_holes) {
    BV_SET(fields, 95);
  }

  differ = (old->rapturedelay != real_packet->rapturedelay);
  if (differ) {
    different++;
    BV_SET(fields, 96);
  }

  differ = (old->disasters != real_packet->disasters);
  if (differ) {
    different++;
    BV_SET(fields, 97);
  }

  differ = (old->restrictinfra != real_packet->restrictinfra);
  if (differ) {
    different++;
  }
  if (packet->restrictinfra) {
    BV_SET(fields, 98);
  }

  differ = (old->unreachable_protects != real_packet->unreachable_protects);
  if (differ) {
    different++;
  }
  if (packet->unreachable_protects) {
    BV_SET(fields, 99);
  }

  differ = (old->sciencebox != real_packet->sciencebox);
  if (differ) {
    different++;
    BV_SET(fields, 100);
  }

  differ = (old->shieldbox != real_packet->shieldbox);
  if (differ) {
    different++;
    BV_SET(fields, 101);
  }

  differ = (old->skill_level != real_packet->skill_level);
  if (differ) {
    different++;
    BV_SET(fields, 102);
  }

  differ = (old->victory_conditions != real_packet->victory_conditions);
  if (differ) {
    different++;
    BV_SET(fields, 103);
  }

  differ = (old->team_pooled_research != real_packet->team_pooled_research);
  if (differ) {
    different++;
  }
  if (packet->team_pooled_research) {
    BV_SET(fields, 104);
  }

  differ = (old->tech != real_packet->tech);
  if (differ) {
    different++;
    BV_SET(fields, 105);
  }

  differ = (old->tech_cost_style != real_packet->tech_cost_style);
  if (differ) {
    different++;
    BV_SET(fields, 106);
  }

  differ = (old->tech_leakage != real_packet->tech_leakage);
  if (differ) {
    different++;
    BV_SET(fields, 107);
  }

  differ = (old->tech_upkeep_divider != real_packet->tech_upkeep_divider);
  if (differ) {
    different++;
    BV_SET(fields, 108);
  }

  differ = (old->tech_upkeep_style != real_packet->tech_upkeep_style);
  if (differ) {
    different++;
    BV_SET(fields, 109);
  }

  differ = (old->techloss_forgiveness != real_packet->techloss_forgiveness);
  if (differ) {
    different++;
    BV_SET(fields, 110);
  }

  differ = (old->free_tech_method != real_packet->free_tech_method);
  if (differ) {
    different++;
    BV_SET(fields, 111);
  }

  differ = (old->gameloss_style != real_packet->gameloss_style);
  if (differ) {
    different++;
    BV_SET(fields, 112);
  }

  differ = (old->timeout != real_packet->timeout);
  if (differ) {
    different++;
    BV_SET(fields, 113);
  }

  differ = (old->first_timeout != real_packet->first_timeout);
  if (differ) {
    different++;
    BV_SET(fields, 114);
  }

  differ = (old->tired_attack != real_packet->tired_attack);
  if (differ) {
    different++;
  }
  if (packet->tired_attack) {
    BV_SET(fields, 115);
  }

  differ = (old->trademindist != real_packet->trademindist);
  if (differ) {
    different++;
    BV_SET(fields, 116);
  }

  differ = (old->trade_revenue_style != real_packet->trade_revenue_style);
  if (differ) {
    different++;
    BV_SET(fields, 117);
  }

  differ = (old->trading_city != real_packet->trading_city);
  if (differ) {
    different++;
  }
  if (packet->trading_city) {
    BV_SET(fields, 118);
  }

  differ = (old->trading_gold != real_packet->trading_gold);
  if (differ) {
    different++;
  }
  if (packet->trading_gold) {
    BV_SET(fields, 119);
  }

  differ = (old->trading_tech != real_packet->trading_tech);
  if (differ) {
    different++;
  }
  if (packet->trading_tech) {
    BV_SET(fields, 120);
  }

  differ = (old->turn != real_packet->turn);
  if (differ) {
    different++;
    BV_SET(fields, 121);
  }

  differ = (old->warminglevel != real_packet->warminglevel);
  if (differ) {
    different++;
    BV_SET(fields, 122);
  }

  differ = (old->year != real_packet->year);
  if (differ) {
    different++;
    BV_SET(fields, 123);
  }

  differ = (old->year_0_hack != real_packet->year_0_hack);
  if (differ) {
    different++;
  }
  if (packet->year_0_hack) {
    BV_SET(fields, 124);
  }

  differ = (old->fragment_count != real_packet->fragment_count);
  if (differ) {
    different++;
    BV_SET(fields, 125);
  }

  differ = (old->civil_war_enabled != real_packet->civil_war_enabled);
  if (differ) {
    different++;
  }
  if (packet->civil_war_enabled) {
    BV_SET(fields, 126);
  }

  differ = (old->civil_war_bonus_celebrating != real_packet->civil_war_bonus_celebrating);
  if (differ) {
    different++;
    BV_SET(fields, 127);
  }

  differ = (old->civil_war_bonus_unhappy != real_packet->civil_war_bonus_unhappy);
  if (differ) {
    different++;
    BV_SET(fields, 128);
  }

  differ = (old->granularity != real_packet->granularity);
  if (differ) {
    different++;
    BV_SET(fields, 129);
  }

  differ = (old->small_wonder_visibility != real_packet->small_wonder_visibility);
  if (differ) {
    different++;
    BV_SET(fields, 130);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'add_to_size_limit' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "add_to_size_limit";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->add_to_size_limit);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'aifill' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "aifill";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->aifill);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'persistent_ready' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "persistent_ready";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->persistent_ready);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'airlifting_style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlifting_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlifting_style);
  }
  /* field 4 is folded into the header */
  /* field 5 is folded into the header */
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'angrycitizen' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "angrycitizen";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->angrycitizen);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'base_pollution' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->base_pollution);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'base_tech_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_tech_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->base_tech_cost);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'tech_leak_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_leak_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_leak_pct);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'border_city_radius_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->border_city_radius_sq);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'border_size_effect' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_size_effect";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->border_size_effect);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'border_city_permanent_radius_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_city_permanent_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->border_city_permanent_radius_sq);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'borders' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "borders";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->borders);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'base_bribe_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_bribe_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->base_bribe_cost);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'caravan_bonus_style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_bonus_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->caravan_bonus_style);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'culture_vic_points' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture_vic_points";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture_vic_points);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'culture_vic_lead' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture_vic_lead";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->culture_vic_lead);
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'culture_migration_pml' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture_migration_pml";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->culture_migration_pml);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'history_interest_pml' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history_interest_pml";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->history_interest_pml);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'celebratesize' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "celebratesize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->celebratesize);
  }
  /* field 21 is folded into the header */
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'pop_report_zeroes' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pop_report_zeroes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->pop_report_zeroes);
  }
  /* field 23 is folded into the header */
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'citizen_convert_speed' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_convert_speed";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->citizen_convert_speed);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'conquest_convert_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conquest_convert_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->conquest_convert_pct);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'citizen_partisans_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_partisans_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->citizen_partisans_pct);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'citymindist' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citymindist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->citymindist);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'cooling' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cooling";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->cooling);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'coolinglevel' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "coolinglevel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->coolinglevel);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'diplchance_initial_odds' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplchance_initial_odds";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->diplchance_initial_odds);
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  field 'diplomacy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomacy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->diplomacy);
  }
  /* field 32 is folded into the header */
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'food_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->food_cost);
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'foodbox' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "foodbox";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->foodbox);
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  field 'forced_gold' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "forced_gold";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->forced_gold);
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  field 'forced_luxury' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "forced_luxury";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->forced_luxury);
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  field 'forced_science' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "forced_science";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->forced_science);
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  field 'fulltradesize' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fulltradesize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fulltradesize);
  }
  if (BV_ISSET(fields, 39)) {
    log_packet_detailed("  field 'trade_world_rel_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_world_rel_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_world_rel_pct);
  }
  if (BV_ISSET(fields, 40)) {
    log_packet_detailed("  field 'min_trade_route_val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_trade_route_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->min_trade_route_val);
  }
  if (BV_ISSET(fields, 41)) {
    log_packet_detailed("  field 'goods_selection' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goods_selection";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->goods_selection);
  }
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  field 'global_advance_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_advance_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->global_advance_count);
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  field 'global_advances' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_advances";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      int count = 0;

      for (i = 0; i < A_LAST; i++) {
        if (old->global_advances[i] != real_packet->global_advances[i]) {
          count++;
        }
      }
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, count + 1);

      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);

      count = 0;
#endif /* FREECIV_JSON_CONNECTION */

      fc_assert(A_LAST < 255);

      for (i = 0; i < A_LAST; i++) {
        if (old->global_advances[i] != real_packet->global_advances[i]) {
#ifdef FREECIV_JSON_CONNECTION
          /* Next diff array element. */
          field_addr.sub_location->number = count - 1;

          /* Create the diff array element. */
          DIO_PUT(farray, &dout, &field_addr, 2);

          /* Enter diff array element (start at the index address). */
          field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(uint8, &dout, &field_addr, i);

#ifdef FREECIV_JSON_CONNECTION
          /* Content address. */
          field_addr.sub_location->sub_location->number = 1;
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(bool8, &dout, &field_addr, real_packet->global_advances[i]);

#ifdef FREECIV_JSON_CONNECTION
          /* Exit diff array element. */
          free(field_addr.sub_location->sub_location);
          field_addr.sub_location->sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
        }
      }
#ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = count - 1;

      /* Create the diff array element. */
      DIO_PUT(farray, &dout, &field_addr, A_LAST);

      /* Enter diff array element. Point to index address. */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
      DIO_PUT(uint8, &dout, &field_addr, 255);

#ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;

      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  /* field 44 is folded into the header */
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  field 'globalwarming' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "globalwarming";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->globalwarming);
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  field 'gold' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->gold);
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  field 'gold_upkeep_style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold_upkeep_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gold_upkeep_style);
  }
  if (BV_ISSET(fields, 48)) {
    log_packet_detailed("  field 'infrapoints' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infrapoints";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->infrapoints);
  }
  if (BV_ISSET(fields, 49)) {
    log_packet_detailed("  field 'revolentype' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "revolentype";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->revolentype);
  }
  if (BV_ISSET(fields, 50)) {
    log_packet_detailed("  field 'default_government_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_government_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->default_government_id);
  }
  if (BV_ISSET(fields, 51)) {
    log_packet_detailed("  field 'government_during_revolution_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government_during_revolution_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->government_during_revolution_id);
  }
  if (BV_ISSET(fields, 52)) {
    log_packet_detailed("  field 'granary_food_inc' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_food_inc";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->granary_food_inc);
  }
  if (BV_ISSET(fields, 53)) {
    log_packet_detailed("  field 'granary_food_ini' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_food_ini";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_GRANARY_INIS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_GRANARY_INIS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->granary_food_ini[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 54)) {
    log_packet_detailed("  field 'granary_num_inis' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_num_inis";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->granary_num_inis);
  }
  if (BV_ISSET(fields, 55)) {
    log_packet_detailed("  field 'great_wonder_owners' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "great_wonder_owners";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      int count = 0;

      for (i = 0; i < B_LAST; i++) {
        if (old->great_wonder_owners[i] != real_packet->great_wonder_owners[i]) {
          count++;
        }
      }
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, count + 1);

      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);

      count = 0;
#endif /* FREECIV_JSON_CONNECTION */

      fc_assert(B_LAST < 255);

      for (i = 0; i < B_LAST; i++) {
        if (old->great_wonder_owners[i] != real_packet->great_wonder_owners[i]) {
#ifdef FREECIV_JSON_CONNECTION
          /* Next diff array element. */
          field_addr.sub_location->number = count - 1;

          /* Create the diff array element. */
          DIO_PUT(farray, &dout, &field_addr, 2);

          /* Enter diff array element (start at the index address). */
          field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(uint8, &dout, &field_addr, i);

#ifdef FREECIV_JSON_CONNECTION
          /* Content address. */
          field_addr.sub_location->sub_location->number = 1;
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(uint16, &dout, &field_addr, real_packet->great_wonder_owners[i]);

#ifdef FREECIV_JSON_CONNECTION
          /* Exit diff array element. */
          free(field_addr.sub_location->sub_location);
          field_addr.sub_location->sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
        }
      }
#ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = count - 1;

      /* Create the diff array element. */
      DIO_PUT(farray, &dout, &field_addr, B_LAST);

      /* Enter diff array element. Point to index address. */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
      DIO_PUT(uint8, &dout, &field_addr, 255);

#ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;

      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 56)) {
    log_packet_detailed("  field 'happy_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->happy_cost);
  }
  if (BV_ISSET(fields, 57)) {
    log_packet_detailed("  field 'happyborders' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happyborders";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->happyborders);
  }
  if (BV_ISSET(fields, 58)) {
    log_packet_detailed("  field 'heating' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "heating";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->heating);
  }
  if (BV_ISSET(fields, 59)) {
    log_packet_detailed("  field 'illness_base_factor' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_base_factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_base_factor);
  }
  if (BV_ISSET(fields, 60)) {
    log_packet_detailed("  field 'illness_min_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_min_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->illness_min_size);
  }
  /* field 61 is folded into the header */
  if (BV_ISSET(fields, 62)) {
    log_packet_detailed("  field 'illness_pollution_factor' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_pollution_factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_pollution_factor);
  }
  if (BV_ISSET(fields, 63)) {
    log_packet_detailed("  field 'illness_trade_infection' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade_infection";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade_infection);
  }
  if (BV_ISSET(fields, 64)) {
    log_packet_detailed("  field 'init_city_radius_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->init_city_radius_sq);
  }
  /* field 65 is folded into the header */
  /* field 66 is folded into the header */
  /* field 67 is folded into the header */
  /* field 68 is folded into the header */
  /* field 69 is folded into the header */
  /* field 70 is folded into the header */
  /* field 71 is folded into the header */
  /* field 72 is folded into the header */
  if (BV_ISSET(fields, 73)) {
    log_packet_detailed("  field 'low_firepower_badwallattacker' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_badwallattacker";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->low_firepower_badwallattacker);
  }
  if (BV_ISSET(fields, 74)) {
    log_packet_detailed("  field 'low_firepower_pearl_harbour' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_pearl_harbour";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->low_firepower_pearl_harbour);
  }
  if (BV_ISSET(fields, 75)) {
    log_packet_detailed("  field 'low_firepower_combat_bonus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_combat_bonus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->low_firepower_combat_bonus);
  }
  if (BV_ISSET(fields, 76)) {
    log_packet_detailed("  field 'low_firepower_nonnat_bombard' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_nonnat_bombard";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->low_firepower_nonnat_bombard);
  }
  if (BV_ISSET(fields, 77)) {
    log_packet_detailed("  field 'nuke_pop_loss_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuke_pop_loss_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nuke_pop_loss_pct);
  }
  if (BV_ISSET(fields, 78)) {
    log_packet_detailed("  field 'nuke_defender_survival_chance_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuke_defender_survival_chance_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nuke_defender_survival_chance_pct);
  }
  if (BV_ISSET(fields, 79)) {
    log_packet_detailed("  field 'min_city_center_output' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_city_center_output";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->min_city_center_output[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  /* field 80 is folded into the header */
  /* field 81 is folded into the header */
  /* field 82 is folded into the header */
  if (BV_ISSET(fields, 83)) {
    log_packet_detailed("  field 'notradesize' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "notradesize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->notradesize);
  }
  /* field 84 is folded into the header */
  if (BV_ISSET(fields, 85)) {
    log_packet_detailed("  field 'nuclearwinter' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuclearwinter";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->nuclearwinter);
  }
  if (BV_ISSET(fields, 86)) {
    log_packet_detailed("  field 'phase' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->phase);
  }
  if (BV_ISSET(fields, 87)) {
    log_packet_detailed("  field 'phase_mode' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase_mode";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->phase_mode);
  }
  /* field 88 is folded into the header */
  /* field 89 is folded into the header */
  /* field 90 is folded into the header */
  /* field 91 is folded into the header */
  /* field 92 is folded into the header */
  /* field 93 is folded into the header */
  /* field 94 is folded into the header */
  /* field 95 is folded into the header */
  if (BV_ISSET(fields, 96)) {
    log_packet_detailed("  field 'rapturedelay' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rapturedelay";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->rapturedelay);
  }
  if (BV_ISSET(fields, 97)) {
    log_packet_detailed("  field 'disasters' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disasters";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disasters);
  }
  /* field 98 is folded into the header */
  /* field 99 is folded into the header */
  if (BV_ISSET(fields, 100)) {
    log_packet_detailed("  field 'sciencebox' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sciencebox";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->sciencebox);
  }
  if (BV_ISSET(fields, 101)) {
    log_packet_detailed("  field 'shieldbox' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shieldbox";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->shieldbox);
  }
  if (BV_ISSET(fields, 102)) {
    log_packet_detailed("  field 'skill_level' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "skill_level";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->skill_level);
  }
  if (BV_ISSET(fields, 103)) {
    log_packet_detailed("  field 'victory_conditions' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "victory_conditions";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->victory_conditions);
  }
  /* field 104 is folded into the header */
  if (BV_ISSET(fields, 105)) {
    log_packet_detailed("  field 'tech' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->tech);
  }
  if (BV_ISSET(fields, 106)) {
    log_packet_detailed("  field 'tech_cost_style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_cost_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_cost_style);
  }
  if (BV_ISSET(fields, 107)) {
    log_packet_detailed("  field 'tech_leakage' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_leakage";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_leakage);
  }
  if (BV_ISSET(fields, 108)) {
    log_packet_detailed("  field 'tech_upkeep_divider' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_upkeep_divider";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->tech_upkeep_divider);
  }
  if (BV_ISSET(fields, 109)) {
    log_packet_detailed("  field 'tech_upkeep_style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_upkeep_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_upkeep_style);
  }
  if (BV_ISSET(fields, 110)) {
    log_packet_detailed("  field 'techloss_forgiveness' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "techloss_forgiveness";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->techloss_forgiveness);
  }
  if (BV_ISSET(fields, 111)) {
    log_packet_detailed("  field 'free_tech_method' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "free_tech_method";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->free_tech_method);
  }
  if (BV_ISSET(fields, 112)) {
    log_packet_detailed("  field 'gameloss_style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gameloss_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gameloss_style);
  }
  if (BV_ISSET(fields, 113)) {
    log_packet_detailed("  field 'timeout' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "timeout";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->timeout);
  }
  if (BV_ISSET(fields, 114)) {
    log_packet_detailed("  field 'first_timeout' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first_timeout";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->first_timeout);
  }
  /* field 115 is folded into the header */
  if (BV_ISSET(fields, 116)) {
    log_packet_detailed("  field 'trademindist' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trademindist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->trademindist);
  }
  if (BV_ISSET(fields, 117)) {
    log_packet_detailed("  field 'trade_revenue_style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_revenue_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_revenue_style);
  }
  /* field 118 is folded into the header */
  /* field 119 is folded into the header */
  /* field 120 is folded into the header */
  if (BV_ISSET(fields, 121)) {
    log_packet_detailed("  field 'turn' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);
  }
  if (BV_ISSET(fields, 122)) {
    log_packet_detailed("  field 'warminglevel' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "warminglevel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->warminglevel);
  }
  if (BV_ISSET(fields, 123)) {
    log_packet_detailed("  field 'year' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "year";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->year);
  }
  /* field 124 is folded into the header */
  if (BV_ISSET(fields, 125)) {
    log_packet_detailed("  field 'fragment_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fragment_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->fragment_count);
  }
  /* field 126 is folded into the header */
  if (BV_ISSET(fields, 127)) {
    log_packet_detailed("  field 'civil_war_bonus_celebrating' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "civil_war_bonus_celebrating";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->civil_war_bonus_celebrating);
  }
  if (BV_ISSET(fields, 128)) {
    log_packet_detailed("  field 'civil_war_bonus_unhappy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "civil_war_bonus_unhappy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->civil_war_bonus_unhappy);
  }
  if (BV_ISSET(fields, 129)) {
    log_packet_detailed("  field 'granularity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granularity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->granularity);
  }
  if (BV_ISSET(fields, 130)) {
    log_packet_detailed("  field 'small_wonder_visibility' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "small_wonder_visibility";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->small_wonder_visibility);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "add_to_size_limit";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->add_to_size_limit);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "aifill";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->aifill);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "persistent_ready";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->persistent_ready);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlifting_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlifting_style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift_from_always_enabled";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->airlift_from_always_enabled);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift_to_always_enabled";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->airlift_to_always_enabled);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "angrycitizen";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->angrycitizen);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->base_pollution);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_tech_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->base_tech_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_leak_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_leak_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->border_city_radius_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_size_effect";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->border_size_effect);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_city_permanent_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->border_city_permanent_radius_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "borders";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->borders);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_bribe_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->base_bribe_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_bonus_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->caravan_bonus_style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture_vic_points";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture_vic_points);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture_vic_lead";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->culture_vic_lead);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture_migration_pml";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->culture_migration_pml);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history_interest_pml";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->history_interest_pml);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "celebratesize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->celebratesize);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changable_tax";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->changable_tax);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pop_report_zeroes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->pop_report_zeroes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_nationality";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->citizen_nationality);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_convert_speed";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->citizen_convert_speed);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conquest_convert_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->conquest_convert_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_partisans_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->citizen_partisans_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citymindist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->citymindist);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cooling";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->cooling);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "coolinglevel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->coolinglevel);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplchance_initial_odds";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->diplchance_initial_odds);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomacy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->diplomacy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fogofwar";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->fogofwar);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->food_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "foodbox";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->foodbox);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "forced_gold";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->forced_gold);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "forced_luxury";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->forced_luxury);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "forced_science";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->forced_science);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fulltradesize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fulltradesize);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_world_rel_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_world_rel_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_trade_route_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->min_trade_route_val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goods_selection";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->goods_selection);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_advance_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->global_advance_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_advances";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, A_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < A_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->global_advances[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_warming";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->global_warming);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "globalwarming";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->globalwarming);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->gold);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold_upkeep_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gold_upkeep_style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infrapoints";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->infrapoints);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "revolentype";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->revolentype);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_government_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->default_government_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government_during_revolution_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->government_during_revolution_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_food_inc";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->granary_food_inc);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_food_ini";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_GRANARY_INIS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_GRANARY_INIS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->granary_food_ini[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_num_inis";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->granary_num_inis);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "great_wonder_owners";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, B_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < B_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->great_wonder_owners[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->happy_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happyborders";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->happyborders);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "heating";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->heating);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_base_factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_base_factor);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_min_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->illness_min_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_on";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->illness_on);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_pollution_factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_pollution_factor);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade_infection";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade_infection);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->init_city_radius_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_edit_mode";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_edit_mode);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_new_game";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_new_game);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "killcitizen";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->killcitizen);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "killstack";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->killstack);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "only_killing_makes_veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->only_killing_makes_veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "only_real_fight_makes_veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->only_real_fight_makes_veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "combat_odds_scaled_veterancy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->combat_odds_scaled_veterancy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "damage_reduces_bombard_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->damage_reduces_bombard_rate);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_badwallattacker";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->low_firepower_badwallattacker);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_pearl_harbour";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->low_firepower_pearl_harbour);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_combat_bonus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->low_firepower_combat_bonus);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "low_firepower_nonnat_bombard";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->low_firepower_nonnat_bombard);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuke_pop_loss_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nuke_pop_loss_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuke_defender_survival_chance_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nuke_defender_survival_chance_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_city_center_output";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->min_city_center_output[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "muuk_food_wipe";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->muuk_food_wipe);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "muuk_gold_wipe";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->muuk_gold_wipe);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "muuk_shield_wipe";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->muuk_shield_wipe);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "notradesize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->notradesize);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuclear_winter";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->nuclear_winter);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nuclearwinter";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->nuclearwinter);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->phase);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase_mode";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->phase_mode);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pillage_select";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->pillage_select);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal_maps_reveals_all_cities";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->steal_maps_reveals_all_cities);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "poison_empties_food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->poison_empties_food_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_steal_allow_holes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->tech_steal_allow_holes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_trade_allow_holes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->tech_trade_allow_holes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_trade_loss_allow_holes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->tech_trade_loss_allow_holes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_parasite_allow_holes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->tech_parasite_allow_holes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_loss_allow_holes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->tech_loss_allow_holes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rapturedelay";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->rapturedelay);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disasters";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disasters);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "restrictinfra";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->restrictinfra);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unreachable_protects";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->unreachable_protects);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sciencebox";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->sciencebox);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shieldbox";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->shieldbox);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "skill_level";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->skill_level);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "victory_conditions";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->victory_conditions);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team_pooled_research";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->team_pooled_research);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->tech);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_cost_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_cost_style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_leakage";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_leakage);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_upkeep_divider";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->tech_upkeep_divider);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_upkeep_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_upkeep_style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "techloss_forgiveness";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->techloss_forgiveness);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "free_tech_method";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->free_tech_method);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gameloss_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gameloss_style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "timeout";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->timeout);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first_timeout";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->first_timeout);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tired_attack";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->tired_attack);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trademindist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->trademindist);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_revenue_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_revenue_style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trading_city";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->trading_city);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trading_gold";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->trading_gold);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trading_tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->trading_tech);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "warminglevel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->warminglevel);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "year";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->year);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "year_0_hack";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->year_0_hack);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fragment_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->fragment_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "civil_war_enabled";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->civil_war_enabled);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "civil_war_bonus_celebrating";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->civil_war_bonus_celebrating);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "civil_war_bonus_unhappy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->civil_war_bonus_unhappy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granularity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->granularity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "small_wonder_visibility";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->small_wonder_visibility);

#endif
  SEND_PACKET_END(PACKET_GAME_INFO);
}

int send_packet_game_info(struct connection *pc, const struct packet_game_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_GAME_INFO].packet != NULL, -1,
                        "Handler for PACKET_GAME_INFO not installed");
  return pc->phs.handlers->send[PACKET_GAME_INFO].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_calendar_info_100 hash_const

#define cmp_packet_calendar_info_100 cmp_const

BV_DEFINE(packet_calendar_info_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_calendar_info *receive_packet_calendar_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_calendar_info_100_fields fields;
  struct packet_calendar_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CALENDAR_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_calendar_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "positive_year_label";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->positive_year_label, sizeof(real_packet->positive_year_label))) {
    RECEIVE_PACKET_FIELD_ERROR(positive_year_label);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "negative_year_label";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->negative_year_label, sizeof(real_packet->negative_year_label))) {
    RECEIVE_PACKET_FIELD_ERROR(negative_year_label);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "calendar_fragments";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->calendar_fragments)) {
    RECEIVE_PACKET_FIELD_ERROR(calendar_fragments);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "calendar_fragment_name";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < MAX_CALENDAR_FRAGMENTS; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->calendar_fragment_name[i], sizeof(real_packet->calendar_fragment_name[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(calendar_fragment_name);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "calendar_skip_0";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->calendar_skip_0)) {
    RECEIVE_PACKET_FIELD_ERROR(calendar_skip_0);
  }

#endif
  log_packet_detailed("packet_calendar_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_calendar_info_100, cmp_packet_calendar_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'positive_year_label'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "positive_year_label";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->positive_year_label, sizeof(real_packet->positive_year_label))) {
      RECEIVE_PACKET_FIELD_ERROR(positive_year_label);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'negative_year_label'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "negative_year_label";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->negative_year_label, sizeof(real_packet->negative_year_label))) {
      RECEIVE_PACKET_FIELD_ERROR(negative_year_label);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'calendar_fragments'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "calendar_fragments";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->calendar_fragments)) {
      RECEIVE_PACKET_FIELD_ERROR(calendar_fragments);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'calendar_fragment_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "calendar_fragment_name";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < MAX_CALENDAR_FRAGMENTS; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->calendar_fragment_name[i], sizeof(real_packet->calendar_fragment_name[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(calendar_fragment_name);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  real_packet->calendar_skip_0 = BV_ISSET(fields, 4);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_calendar_info_100(struct connection *pc, const struct packet_calendar_info *packet)
{
  const struct packet_calendar_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_calendar_info_100_fields fields;
  struct packet_calendar_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CALENDAR_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CALENDAR_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_calendar_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_calendar_info_100, cmp_packet_calendar_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (strcmp(old->positive_year_label, real_packet->positive_year_label) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->negative_year_label, real_packet->negative_year_label) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->calendar_fragments != real_packet->calendar_fragments);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < MAX_CALENDAR_FRAGMENTS; i++) {
          if (strcmp(old->calendar_fragment_name[i], real_packet->calendar_fragment_name[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->calendar_skip_0 != real_packet->calendar_skip_0);
  if (differ) {
    different++;
  }
  if (packet->calendar_skip_0) {
    BV_SET(fields, 4);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'positive_year_label' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "positive_year_label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->positive_year_label);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'negative_year_label' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "negative_year_label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->negative_year_label);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'calendar_fragments' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "calendar_fragments";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->calendar_fragments);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'calendar_fragment_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "calendar_fragment_name";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_CALENDAR_FRAGMENTS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_CALENDAR_FRAGMENTS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->calendar_fragment_name[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  /* field 4 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "positive_year_label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->positive_year_label);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "negative_year_label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->negative_year_label);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "calendar_fragments";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->calendar_fragments);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "calendar_fragment_name";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_CALENDAR_FRAGMENTS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_CALENDAR_FRAGMENTS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->calendar_fragment_name[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "calendar_skip_0";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->calendar_skip_0);

#endif
  SEND_PACKET_END(PACKET_CALENDAR_INFO);
}

int send_packet_calendar_info(struct connection *pc, const struct packet_calendar_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CALENDAR_INFO].packet != NULL, -1,
                        "Handler for PACKET_CALENDAR_INFO not installed");
  return pc->phs.handlers->send[PACKET_CALENDAR_INFO].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_timeout_info_100 hash_const

#define cmp_packet_timeout_info_100 cmp_const

BV_DEFINE(packet_timeout_info_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_timeout_info *receive_packet_timeout_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_timeout_info_100_fields fields;
  struct packet_timeout_info *old;
  struct genhash **hash = pc->phs.received + PACKET_TIMEOUT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_timeout_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "seconds_to_phasedone";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sfloat, &din, &field_addr, &real_packet->seconds_to_phasedone, 100)) {
    RECEIVE_PACKET_FIELD_ERROR(seconds_to_phasedone);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turn_change_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sfloat, &din, &field_addr, &real_packet->last_turn_change_time, 100)) {
    RECEIVE_PACKET_FIELD_ERROR(last_turn_change_time);
  }

#endif
  log_packet_detailed("packet_timeout_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_timeout_info_100, cmp_packet_timeout_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'seconds_to_phasedone'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "seconds_to_phasedone";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sfloat, &din, &field_addr, &real_packet->seconds_to_phasedone, 100)) {
      RECEIVE_PACKET_FIELD_ERROR(seconds_to_phasedone);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'last_turn_change_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "last_turn_change_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sfloat, &din, &field_addr, &real_packet->last_turn_change_time, 100)) {
      RECEIVE_PACKET_FIELD_ERROR(last_turn_change_time);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_timeout_info_100(struct connection *pc, const struct packet_timeout_info *packet)
{
  const struct packet_timeout_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_timeout_info_100_fields fields;
  struct packet_timeout_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_TIMEOUT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_TIMEOUT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_timeout_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_timeout_info_100, cmp_packet_timeout_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->seconds_to_phasedone != real_packet->seconds_to_phasedone);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->last_turn_change_time != real_packet->last_turn_change_time);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'seconds_to_phasedone' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "seconds_to_phasedone";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sfloat, &dout, &field_addr, real_packet->seconds_to_phasedone, 100);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'last_turn_change_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turn_change_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sfloat, &dout, &field_addr, real_packet->last_turn_change_time, 100);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "seconds_to_phasedone";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sfloat, &dout, &field_addr, real_packet->seconds_to_phasedone, 100);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turn_change_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sfloat, &dout, &field_addr, real_packet->last_turn_change_time, 100);

#endif
  SEND_PACKET_END(PACKET_TIMEOUT_INFO);
}

int send_packet_timeout_info(struct connection *pc, const struct packet_timeout_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_TIMEOUT_INFO].packet != NULL, -1,
                        "Handler for PACKET_TIMEOUT_INFO not installed");
  return pc->phs.handlers->send[PACKET_TIMEOUT_INFO].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_map_info_100 hash_const

#define cmp_packet_map_info_100 cmp_const

BV_DEFINE(packet_map_info_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_map_info *receive_packet_map_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_map_info_100_fields fields;
  struct packet_map_info *old;
  struct genhash **hash = pc->phs.received + PACKET_MAP_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_map_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "xsize";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->xsize)) {
    RECEIVE_PACKET_FIELD_ERROR(xsize);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ysize";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->ysize)) {
    RECEIVE_PACKET_FIELD_ERROR(ysize);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "topology_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->topology_id)) {
    RECEIVE_PACKET_FIELD_ERROR(topology_id);
  }

#endif
  log_packet_detailed("packet_map_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_map_info_100, cmp_packet_map_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'xsize'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "xsize";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->xsize)) {
      RECEIVE_PACKET_FIELD_ERROR(xsize);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'ysize'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ysize";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->ysize)) {
      RECEIVE_PACKET_FIELD_ERROR(ysize);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'topology_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "topology_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->topology_id)) {
      RECEIVE_PACKET_FIELD_ERROR(topology_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_map_info_100(struct connection *pc, const struct packet_map_info *packet)
{
  const struct packet_map_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_map_info_100_fields fields;
  struct packet_map_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_MAP_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_MAP_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_map_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_map_info_100, cmp_packet_map_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->xsize != real_packet->xsize);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->ysize != real_packet->ysize);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->topology_id != real_packet->topology_id);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'xsize' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "xsize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->xsize);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'ysize' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ysize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->ysize);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'topology_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "topology_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->topology_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "xsize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->xsize);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ysize";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->ysize);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "topology_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->topology_id);

#endif
  SEND_PACKET_END(PACKET_MAP_INFO);
}

int send_packet_map_info(struct connection *pc, const struct packet_map_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_MAP_INFO].packet != NULL, -1,
                        "Handler for PACKET_MAP_INFO not installed");
  return pc->phs.handlers->send[PACKET_MAP_INFO].packet(pc, packet);
}

void lsend_packet_map_info(struct conn_list *dest, const struct packet_map_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_map_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_nuke_tile_info_100 hash_const

#define cmp_packet_nuke_tile_info_100 cmp_const

BV_DEFINE(packet_nuke_tile_info_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_nuke_tile_info *receive_packet_nuke_tile_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_nuke_tile_info_100_fields fields;
  struct packet_nuke_tile_info *old;
  struct genhash **hash = pc->phs.received + PACKET_NUKE_TILE_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_nuke_tile_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }

#endif
  log_packet_detailed("packet_nuke_tile_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_nuke_tile_info_100, cmp_packet_nuke_tile_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_nuke_tile_info_100(struct connection *pc, const struct packet_nuke_tile_info *packet)
{
  const struct packet_nuke_tile_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_nuke_tile_info_100_fields fields;
  struct packet_nuke_tile_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_NUKE_TILE_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_NUKE_TILE_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_nuke_tile_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_nuke_tile_info_100, cmp_packet_nuke_tile_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->tile != real_packet->tile);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);

#endif
  SEND_PACKET_END(PACKET_NUKE_TILE_INFO);
}

int send_packet_nuke_tile_info(struct connection *pc, const struct packet_nuke_tile_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_NUKE_TILE_INFO].packet != NULL, -1,
                        "Handler for PACKET_NUKE_TILE_INFO not installed");
  return pc->phs.handlers->send[PACKET_NUKE_TILE_INFO].packet(pc, packet);
}

void lsend_packet_nuke_tile_info(struct conn_list *dest, const struct packet_nuke_tile_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_nuke_tile_info(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_nuke_tile_info(struct connection *pc, int tile)
{
  struct packet_nuke_tile_info packet, *real_packet = &packet;

  real_packet->tile = tile;
  
  return send_packet_nuke_tile_info(pc, real_packet);
}

void dlsend_packet_nuke_tile_info(struct conn_list *dest, int tile)
{
  struct packet_nuke_tile_info packet, *real_packet = &packet;

  real_packet->tile = tile;
  
  lsend_packet_nuke_tile_info(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_team_name_info_100(const void *vkey)
{
  const struct packet_team_name_info *key = (const struct packet_team_name_info *) vkey;

  return key->team_id;
}

static bool cmp_packet_team_name_info_100(const void *vkey1, const void *vkey2)
{
  const struct packet_team_name_info *key1 = (const struct packet_team_name_info *) vkey1;
  const struct packet_team_name_info *key2 = (const struct packet_team_name_info *) vkey2;

  return key1->team_id == key2->team_id;
}
BV_DEFINE(packet_team_name_info_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_team_name_info *receive_packet_team_name_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_team_name_info_100_fields fields;
  struct packet_team_name_info *old;
  struct genhash **hash = pc->phs.received + PACKET_TEAM_NAME_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_team_name_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->team_id)) {
    RECEIVE_PACKET_FIELD_ERROR(team_id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->team_id)) {
    RECEIVE_PACKET_FIELD_ERROR(team_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->team_name, sizeof(real_packet->team_name))) {
    RECEIVE_PACKET_FIELD_ERROR(team_name);
  }

#endif
  log_packet_detailed("packet_team_name_info_100: got info about (%d)",
    real_packet->team_id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_team_name_info_100, cmp_packet_team_name_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int team_id = real_packet->team_id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->team_id = team_id;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'team_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "team_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->team_name, sizeof(real_packet->team_name))) {
      RECEIVE_PACKET_FIELD_ERROR(team_name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_team_name_info_100(struct connection *pc, const struct packet_team_name_info *packet)
{
  const struct packet_team_name_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_team_name_info_100_fields fields;
  struct packet_team_name_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_TEAM_NAME_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_TEAM_NAME_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_team_name_info_100: sending info about (%d)",
    real_packet->team_id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_team_name_info_100, cmp_packet_team_name_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->team_name, real_packet->team_name) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->team_id);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'team_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->team_name);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->team_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->team_name);

#endif
  SEND_PACKET_END(PACKET_TEAM_NAME_INFO);
}

int send_packet_team_name_info(struct connection *pc, const struct packet_team_name_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_TEAM_NAME_INFO].packet != NULL, -1,
                        "Handler for PACKET_TEAM_NAME_INFO not installed");
  return pc->phs.handlers->send[PACKET_TEAM_NAME_INFO].packet(pc, packet);
}

void lsend_packet_team_name_info(struct conn_list *dest, const struct packet_team_name_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_team_name_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_achievement_info_100 hash_const

#define cmp_packet_achievement_info_100 cmp_const

BV_DEFINE(packet_achievement_info_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_achievement_info *receive_packet_achievement_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_achievement_info_100_fields fields;
  struct packet_achievement_info *old;
  struct genhash **hash = pc->phs.received + PACKET_ACHIEVEMENT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_achievement_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gained";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->gained)) {
    RECEIVE_PACKET_FIELD_ERROR(gained);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->first)) {
    RECEIVE_PACKET_FIELD_ERROR(first);
  }

#endif
  log_packet_detailed("packet_achievement_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_achievement_info_100, cmp_packet_achievement_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  real_packet->gained = BV_ISSET(fields, 1);
  real_packet->first = BV_ISSET(fields, 2);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_achievement_info_100(struct connection *pc, const struct packet_achievement_info *packet)
{
  const struct packet_achievement_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_achievement_info_100_fields fields;
  struct packet_achievement_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_ACHIEVEMENT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_ACHIEVEMENT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_achievement_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_achievement_info_100, cmp_packet_achievement_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  if (packet->gained) {
    BV_SET(fields, 1);
  }

  if (packet->first) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  /* field 1 is folded into the header */
  /* field 2 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gained";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->gained);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->first);

#endif
  SEND_PACKET_END(PACKET_ACHIEVEMENT_INFO);
}

int send_packet_achievement_info(struct connection *pc, const struct packet_achievement_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_ACHIEVEMENT_INFO].packet != NULL, -1,
                        "Handler for PACKET_ACHIEVEMENT_INFO not installed");
  return pc->phs.handlers->send[PACKET_ACHIEVEMENT_INFO].packet(pc, packet);
}

void lsend_packet_achievement_info(struct conn_list *dest, const struct packet_achievement_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_achievement_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_chat_msg_100 hash_const

#define cmp_packet_chat_msg_100 cmp_const

BV_DEFINE(packet_chat_msg_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_chat_msg *receive_packet_chat_msg_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_chat_msg_100_fields fields;
  struct packet_chat_msg *old;
  struct genhash **hash = pc->phs.received + PACKET_CHAT_MSG;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_chat_msg, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
    RECEIVE_PACKET_FIELD_ERROR(message);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "event";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(event);
    }
    real_packet->event = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
    RECEIVE_PACKET_FIELD_ERROR(turn);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->phase)) {
    RECEIVE_PACKET_FIELD_ERROR(phase);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->conn_id)) {
    RECEIVE_PACKET_FIELD_ERROR(conn_id);
  }

#endif
  log_packet_detailed("packet_chat_msg_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_chat_msg_100, cmp_packet_chat_msg_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'message'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "message";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
      RECEIVE_PACKET_FIELD_ERROR(message);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'event'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "event";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(event);
      }
      real_packet->event = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'turn'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
      RECEIVE_PACKET_FIELD_ERROR(turn);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'phase'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "phase";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->phase)) {
      RECEIVE_PACKET_FIELD_ERROR(phase);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'conn_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "conn_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->conn_id)) {
      RECEIVE_PACKET_FIELD_ERROR(conn_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_chat_msg_100(struct connection *pc, const struct packet_chat_msg *packet)
{
  const struct packet_chat_msg *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_chat_msg_100_fields fields;
  struct packet_chat_msg *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CHAT_MSG;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CHAT_MSG);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_chat_msg_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_chat_msg_100, cmp_packet_chat_msg_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->message, real_packet->message) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->event != real_packet->event);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->turn != real_packet->turn);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->phase != real_packet->phase);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->conn_id != real_packet->conn_id);
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'message' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->message);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'event' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "event";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->event);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'turn' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'phase' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->phase);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'conn_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->conn_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->message);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "event";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->event);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->phase);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->conn_id);

#endif
  SEND_PACKET_END(PACKET_CHAT_MSG);
}

int send_packet_chat_msg(struct connection *pc, const struct packet_chat_msg *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CHAT_MSG].packet != NULL, -1,
                        "Handler for PACKET_CHAT_MSG not installed");
  return pc->phs.handlers->send[PACKET_CHAT_MSG].packet(pc, packet);
}

void lsend_packet_chat_msg(struct conn_list *dest, const struct packet_chat_msg *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_chat_msg(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_early_chat_msg_100 hash_const

#define cmp_packet_early_chat_msg_100 cmp_const

BV_DEFINE(packet_early_chat_msg_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_early_chat_msg *receive_packet_early_chat_msg_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_early_chat_msg_100_fields fields;
  struct packet_early_chat_msg *old;
  struct genhash **hash = pc->phs.received + PACKET_EARLY_CHAT_MSG;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_early_chat_msg, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
    RECEIVE_PACKET_FIELD_ERROR(message);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "event";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(event);
    }
    real_packet->event = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
    RECEIVE_PACKET_FIELD_ERROR(turn);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->phase)) {
    RECEIVE_PACKET_FIELD_ERROR(phase);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->conn_id)) {
    RECEIVE_PACKET_FIELD_ERROR(conn_id);
  }

#endif
  log_packet_detailed("packet_early_chat_msg_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_early_chat_msg_100, cmp_packet_early_chat_msg_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'message'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "message";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
      RECEIVE_PACKET_FIELD_ERROR(message);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'event'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "event";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(event);
      }
      real_packet->event = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'turn'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
      RECEIVE_PACKET_FIELD_ERROR(turn);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'phase'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "phase";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->phase)) {
      RECEIVE_PACKET_FIELD_ERROR(phase);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'conn_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "conn_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->conn_id)) {
      RECEIVE_PACKET_FIELD_ERROR(conn_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_early_chat_msg_100(struct connection *pc, const struct packet_early_chat_msg *packet)
{
  const struct packet_early_chat_msg *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_early_chat_msg_100_fields fields;
  struct packet_early_chat_msg *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EARLY_CHAT_MSG;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EARLY_CHAT_MSG);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_early_chat_msg_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_early_chat_msg_100, cmp_packet_early_chat_msg_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->message, real_packet->message) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->event != real_packet->event);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->turn != real_packet->turn);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->phase != real_packet->phase);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->conn_id != real_packet->conn_id);
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'message' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->message);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'event' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "event";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->event);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'turn' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'phase' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->phase);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'conn_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->conn_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->message);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "event";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->event);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->phase);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->conn_id);

#endif
  SEND_PACKET_END(PACKET_EARLY_CHAT_MSG);
}

int send_packet_early_chat_msg(struct connection *pc, const struct packet_early_chat_msg *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EARLY_CHAT_MSG].packet != NULL, -1,
                        "Handler for PACKET_EARLY_CHAT_MSG not installed");
  return pc->phs.handlers->send[PACKET_EARLY_CHAT_MSG].packet(pc, packet);
}

void lsend_packet_early_chat_msg(struct conn_list *dest, const struct packet_early_chat_msg *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_early_chat_msg(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_chat_msg_req_100 hash_const

#define cmp_packet_chat_msg_req_100 cmp_const

BV_DEFINE(packet_chat_msg_req_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_chat_msg_req *receive_packet_chat_msg_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_chat_msg_req_100_fields fields;
  struct packet_chat_msg_req *old;
  struct genhash **hash = pc->phs.received + PACKET_CHAT_MSG_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_chat_msg_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
    RECEIVE_PACKET_FIELD_ERROR(message);
  }

#endif
  log_packet_detailed("packet_chat_msg_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_chat_msg_req_100, cmp_packet_chat_msg_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'message'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "message";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
      RECEIVE_PACKET_FIELD_ERROR(message);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_chat_msg_req_100(struct connection *pc, const struct packet_chat_msg_req *packet)
{
  const struct packet_chat_msg_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_chat_msg_req_100_fields fields;
  struct packet_chat_msg_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CHAT_MSG_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CHAT_MSG_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_chat_msg_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_chat_msg_req_100, cmp_packet_chat_msg_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->message, real_packet->message) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'message' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->message);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->message);

#endif
  SEND_PACKET_END(PACKET_CHAT_MSG_REQ);
}

int send_packet_chat_msg_req(struct connection *pc, const struct packet_chat_msg_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CHAT_MSG_REQ].packet != NULL, -1,
                        "Handler for PACKET_CHAT_MSG_REQ not installed");
  return pc->phs.handlers->send[PACKET_CHAT_MSG_REQ].packet(pc, packet);
}

int dsend_packet_chat_msg_req(struct connection *pc, const char *message)
{
  struct packet_chat_msg_req packet, *real_packet = &packet;

  sz_strlcpy(real_packet->message, message);
  
  return send_packet_chat_msg_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_connect_msg_100 hash_const

#define cmp_packet_connect_msg_100 cmp_const

BV_DEFINE(packet_connect_msg_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_connect_msg *receive_packet_connect_msg_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_connect_msg_100_fields fields;
  struct packet_connect_msg *old;
  struct genhash **hash = pc->phs.received + PACKET_CONNECT_MSG;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_connect_msg, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
    RECEIVE_PACKET_FIELD_ERROR(message);
  }

#endif
  log_packet_detailed("packet_connect_msg_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_connect_msg_100, cmp_packet_connect_msg_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'message'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "message";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->message, sizeof(real_packet->message))) {
      RECEIVE_PACKET_FIELD_ERROR(message);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_connect_msg_100(struct connection *pc, const struct packet_connect_msg *packet)
{
  const struct packet_connect_msg *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_connect_msg_100_fields fields;
  struct packet_connect_msg *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CONNECT_MSG;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CONNECT_MSG);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_connect_msg_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_connect_msg_100, cmp_packet_connect_msg_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->message, real_packet->message) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'message' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->message);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "message";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->message);

#endif
  SEND_PACKET_END(PACKET_CONNECT_MSG);
}

int send_packet_connect_msg(struct connection *pc, const struct packet_connect_msg *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CONNECT_MSG].packet != NULL, -1,
                        "Handler for PACKET_CONNECT_MSG not installed");
  return pc->phs.handlers->send[PACKET_CONNECT_MSG].packet(pc, packet);
}

int dsend_packet_connect_msg(struct connection *pc, const char *message)
{
  struct packet_connect_msg packet, *real_packet = &packet;

  sz_strlcpy(real_packet->message, message);
  
  return send_packet_connect_msg(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_server_info_100 hash_const

#define cmp_packet_server_info_100 cmp_const

BV_DEFINE(packet_server_info_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_server_info *receive_packet_server_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_info_100_fields fields;
  struct packet_server_info *old;
  struct genhash **hash = pc->phs.received + PACKET_SERVER_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_server_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version_label";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->version_label, sizeof(real_packet->version_label))) {
    RECEIVE_PACKET_FIELD_ERROR(version_label);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "major_version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->major_version)) {
    RECEIVE_PACKET_FIELD_ERROR(major_version);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "minor_version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->minor_version)) {
    RECEIVE_PACKET_FIELD_ERROR(minor_version);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "patch_version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->patch_version)) {
    RECEIVE_PACKET_FIELD_ERROR(patch_version);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "emerg_version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->emerg_version)) {
    RECEIVE_PACKET_FIELD_ERROR(emerg_version);
  }

#endif
  log_packet_detailed("packet_server_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_info_100, cmp_packet_server_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'version_label'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "version_label";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->version_label, sizeof(real_packet->version_label))) {
      RECEIVE_PACKET_FIELD_ERROR(version_label);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'major_version'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "major_version";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->major_version)) {
      RECEIVE_PACKET_FIELD_ERROR(major_version);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'minor_version'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "minor_version";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->minor_version)) {
      RECEIVE_PACKET_FIELD_ERROR(minor_version);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'patch_version'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "patch_version";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->patch_version)) {
      RECEIVE_PACKET_FIELD_ERROR(patch_version);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'emerg_version'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "emerg_version";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->emerg_version)) {
      RECEIVE_PACKET_FIELD_ERROR(emerg_version);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_info_100(struct connection *pc, const struct packet_server_info *packet)
{
  const struct packet_server_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_info_100_fields fields;
  struct packet_server_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SERVER_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SERVER_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_info_100, cmp_packet_server_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->version_label, real_packet->version_label) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->major_version != real_packet->major_version);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->minor_version != real_packet->minor_version);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->patch_version != real_packet->patch_version);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->emerg_version != real_packet->emerg_version);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'version_label' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version_label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->version_label);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'major_version' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "major_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->major_version);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'minor_version' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "minor_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->minor_version);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'patch_version' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "patch_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->patch_version);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'emerg_version' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "emerg_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->emerg_version);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version_label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->version_label);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "major_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->major_version);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "minor_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->minor_version);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "patch_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->patch_version);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "emerg_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->emerg_version);

#endif
  SEND_PACKET_END(PACKET_SERVER_INFO);
}

int send_packet_server_info(struct connection *pc, const struct packet_server_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_INFO].packet != NULL, -1,
                        "Handler for PACKET_SERVER_INFO not installed");
  return pc->phs.handlers->send[PACKET_SERVER_INFO].packet(pc, packet);
}

int dsend_packet_server_info(struct connection *pc, const char *version_label, int major_version, int minor_version, int patch_version, int emerg_version)
{
  struct packet_server_info packet, *real_packet = &packet;

  sz_strlcpy(real_packet->version_label, version_label);
  real_packet->major_version = major_version;
  real_packet->minor_version = minor_version;
  real_packet->patch_version = patch_version;
  real_packet->emerg_version = emerg_version;
  
  return send_packet_server_info(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_remove_100 hash_const

#define cmp_packet_city_remove_100 cmp_const

BV_DEFINE(packet_city_remove_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_remove *receive_packet_city_remove_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_remove_100_fields fields;
  struct packet_city_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }

#endif
  log_packet_detailed("packet_city_remove_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_remove_100, cmp_packet_city_remove_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_WEB_CITY_INFO_ADDITION;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_NATIONALITIES;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_RALLY_POINT;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_remove_100(struct connection *pc, const struct packet_city_remove *packet)
{
  const struct packet_city_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_remove_100_fields fields;
  struct packet_city_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_remove_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_remove_100, cmp_packet_city_remove_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_WEB_CITY_INFO_ADDITION;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_NATIONALITIES;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_RALLY_POINT;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);

#endif
  SEND_PACKET_END(PACKET_CITY_REMOVE);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_remove_101 hash_const

#define cmp_packet_city_remove_101 cmp_const

BV_DEFINE(packet_city_remove_101_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_remove *receive_packet_city_remove_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_remove_101_fields fields;
  struct packet_city_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }

#endif
  log_packet_detailed("packet_city_remove_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_remove_101, cmp_packet_city_remove_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_WEB_CITY_INFO_ADDITION;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_NATIONALITIES;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_RALLY_POINT;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_remove_101(struct connection *pc, const struct packet_city_remove *packet)
{
  const struct packet_city_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_remove_101_fields fields;
  struct packet_city_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_remove_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_remove_101, cmp_packet_city_remove_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_WEB_CITY_INFO_ADDITION;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_NATIONALITIES;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_RALLY_POINT;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);

#endif
  SEND_PACKET_END(PACKET_CITY_REMOVE);
}

int send_packet_city_remove(struct connection *pc, const struct packet_city_remove *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_REMOVE].packet != NULL, -1,
                        "Handler for PACKET_CITY_REMOVE not installed");
  return pc->phs.handlers->send[PACKET_CITY_REMOVE].packet(pc, packet);
}

void lsend_packet_city_remove(struct conn_list *dest, const struct packet_city_remove *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_city_remove(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_city_remove(struct connection *pc, int city_id16, int city_id32)
{
  struct packet_city_remove packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  
  return send_packet_city_remove(pc, real_packet);
}

void dlsend_packet_city_remove(struct conn_list *dest, int city_id16, int city_id32)
{
  struct packet_city_remove packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  
  lsend_packet_city_remove(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_info_100 hash_const

#define cmp_packet_city_info_100 cmp_const

BV_DEFINE(packet_city_info_100_fields, 50);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_info *receive_packet_city_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_info_100_fields fields;
  struct packet_city_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->original)) {
    RECEIVE_PACKET_FIELD_ERROR(original);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_radius_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(city_radius_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
    RECEIVE_PACKET_FIELD_ERROR(style);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(capital);
    }
    real_packet->capital = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_content);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
    RECEIVE_PACKET_FIELD_ERROR(specialists_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->specialists_size > SP_MAX) {
      RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
    }
    for (i = 0; i < real_packet->specialists_size; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
        RECEIVE_PACKET_FIELD_ERROR(specialists);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
    RECEIVE_PACKET_FIELD_ERROR(history);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
    RECEIVE_PACKET_FIELD_ERROR(culture);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->buy_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(buy_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->surplus[i])) {
        RECEIVE_PACKET_FIELD_ERROR(surplus);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->waste[i])) {
        RECEIVE_PACKET_FIELD_ERROR(waste);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->unhappy_penalty[i])) {
        RECEIVE_PACKET_FIELD_ERROR(unhappy_penalty);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->prod[i])) {
        RECEIVE_PACKET_FIELD_ERROR(prod);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->citizen_base[i])) {
        RECEIVE_PACKET_FIELD_ERROR(citizen_base);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->usage[i])) {
        RECEIVE_PACKET_FIELD_ERROR(usage);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->food_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(food_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(shield_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_route_count)) {
    RECEIVE_PACKET_FIELD_ERROR(trade_route_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->pollution)) {
    RECEIVE_PACKET_FIELD_ERROR(pollution);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade)) {
    RECEIVE_PACKET_FIELD_ERROR(illness_trade);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(production_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
    RECEIVE_PACKET_FIELD_ERROR(production_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_founded);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_value)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->before_change_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(before_change_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disbanded_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(disbanded_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->caravan_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(caravan_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->last_turns_shield_surplus)) {
    RECEIVE_PACKET_FIELD_ERROR(last_turns_shield_surplus);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->airlift)) {
    RECEIVE_PACKET_FIELD_ERROR(airlift);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_buy)) {
    RECEIVE_PACKET_FIELD_ERROR(did_buy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_sell)) {
    RECEIVE_PACKET_FIELD_ERROR(did_sell);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->was_happy)) {
    RECEIVE_PACKET_FIELD_ERROR(was_happy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomat_investigate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->diplomat_investigate)) {
    RECEIVE_PACKET_FIELD_ERROR(diplomat_investigate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
    RECEIVE_PACKET_FIELD_ERROR(walls);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
    RECEIVE_PACKET_FIELD_ERROR(city_image);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->steal)) {
    RECEIVE_PACKET_FIELD_ERROR(steal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
    RECEIVE_PACKET_FIELD_ERROR(worklist);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
    RECEIVE_PACKET_FIELD_ERROR(improvements);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
    RECEIVE_PACKET_FIELD_ERROR(city_options);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_info_100, cmp_packet_city_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'original'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "original";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->original)) {
      RECEIVE_PACKET_FIELD_ERROR(original);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'city_radius_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_radius_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_radius_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(city_radius_sq);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
      RECEIVE_PACKET_FIELD_ERROR(style);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'capital'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "capital";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(capital);
      }
      real_packet->capital = readin;
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'ppl_happy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_happy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'ppl_content'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_content";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_content);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'ppl_unhappy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_unhappy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'ppl_angry'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_angry";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'specialists_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
      RECEIVE_PACKET_FIELD_ERROR(specialists_size);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'specialists'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->specialists_size > SP_MAX) {
        RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
      }
      for (i = 0; i < real_packet->specialists_size; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
          RECEIVE_PACKET_FIELD_ERROR(specialists);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'history'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "history";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
      RECEIVE_PACKET_FIELD_ERROR(history);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'culture'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "culture";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
      RECEIVE_PACKET_FIELD_ERROR(culture);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'buy_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "buy_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->buy_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(buy_cost);
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'surplus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "surplus";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->surplus[i])) {
          RECEIVE_PACKET_FIELD_ERROR(surplus);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'waste'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "waste";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->waste[i])) {
          RECEIVE_PACKET_FIELD_ERROR(waste);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'unhappy_penalty'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unhappy_penalty";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->unhappy_penalty[i])) {
          RECEIVE_PACKET_FIELD_ERROR(unhappy_penalty);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'prod'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "prod";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->prod[i])) {
          RECEIVE_PACKET_FIELD_ERROR(prod);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'citizen_base'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "citizen_base";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->citizen_base[i])) {
          RECEIVE_PACKET_FIELD_ERROR(citizen_base);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'usage'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "usage";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->usage[i])) {
          RECEIVE_PACKET_FIELD_ERROR(usage);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'food_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "food_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->food_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(food_stock);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'shield_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "shield_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(shield_stock);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'trade_route_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "trade_route_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_route_count)) {
      RECEIVE_PACKET_FIELD_ERROR(trade_route_count);
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'pollution'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "pollution";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->pollution)) {
      RECEIVE_PACKET_FIELD_ERROR(pollution);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'illness_trade'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "illness_trade";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade)) {
      RECEIVE_PACKET_FIELD_ERROR(illness_trade);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'production_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(production_kind);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'production_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
      RECEIVE_PACKET_FIELD_ERROR(production_value);
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'turn_founded'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_founded";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_founded);
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  got field 'turn_last_built'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_last_built";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
    }
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  got field 'changed_from_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_kind);
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'changed_from_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_value)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_value);
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'before_change_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "before_change_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->before_change_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(before_change_shields);
    }
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  got field 'disbanded_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "disbanded_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disbanded_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(disbanded_shields);
    }
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  got field 'caravan_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "caravan_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->caravan_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(caravan_shields);
    }
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  got field 'last_turns_shield_surplus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "last_turns_shield_surplus";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->last_turns_shield_surplus)) {
      RECEIVE_PACKET_FIELD_ERROR(last_turns_shield_surplus);
    }
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  got field 'airlift'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "airlift";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->airlift)) {
      RECEIVE_PACKET_FIELD_ERROR(airlift);
    }
  }
  real_packet->did_buy = BV_ISSET(fields, 39);
  real_packet->did_sell = BV_ISSET(fields, 40);
  real_packet->was_happy = BV_ISSET(fields, 41);
  real_packet->diplomat_investigate = BV_ISSET(fields, 42);
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  got field 'walls'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "walls";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
      RECEIVE_PACKET_FIELD_ERROR(walls);
    }
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  got field 'city_image'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_image";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
      RECEIVE_PACKET_FIELD_ERROR(city_image);
    }
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  got field 'steal'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "steal";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->steal)) {
      RECEIVE_PACKET_FIELD_ERROR(steal);
    }
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  got field 'worklist'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "worklist";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
      RECEIVE_PACKET_FIELD_ERROR(worklist);
    }
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  got field 'improvements'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "improvements";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
      RECEIVE_PACKET_FIELD_ERROR(improvements);
    }
  }
  if (BV_ISSET(fields, 48)) {
    log_packet_detailed("  got field 'city_options'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_options";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
      RECEIVE_PACKET_FIELD_ERROR(city_options);
    }
  }
  if (BV_ISSET(fields, 49)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_info_100(struct connection *pc, const struct packet_city_info *packet, bool force_to_send)
{
  const struct packet_city_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_info_100_fields fields;
  struct packet_city_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_INFO;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_info_100, cmp_packet_city_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->original != real_packet->original);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->city_radius_sq != real_packet->city_radius_sq);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->style != real_packet->style);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (old->capital != real_packet->capital);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_happy[i] != real_packet->ppl_happy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_content[i] != real_packet->ppl_content[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_unhappy[i] != real_packet->ppl_unhappy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_angry[i] != real_packet->ppl_angry[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }

  differ = (old->specialists_size != real_packet->specialists_size);
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }


    {
      differ = (old->specialists_size != real_packet->specialists_size);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->specialists_size; i++) {
          if (old->specialists[i] != real_packet->specialists[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 13);
  }

  differ = (old->history != real_packet->history);
  if (differ) {
    different++;
    BV_SET(fields, 14);
  }

  differ = (old->culture != real_packet->culture);
  if (differ) {
    different++;
    BV_SET(fields, 15);
  }

  differ = (old->buy_cost != real_packet->buy_cost);
  if (differ) {
    different++;
    BV_SET(fields, 16);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->surplus[i] != real_packet->surplus[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 17);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->waste[i] != real_packet->waste[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 18);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->unhappy_penalty[i] != real_packet->unhappy_penalty[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 19);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->prod[i] != real_packet->prod[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 20);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->citizen_base[i] != real_packet->citizen_base[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 21);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->usage[i] != real_packet->usage[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 22);
  }

  differ = (old->food_stock != real_packet->food_stock);
  if (differ) {
    different++;
    BV_SET(fields, 23);
  }

  differ = (old->shield_stock != real_packet->shield_stock);
  if (differ) {
    different++;
    BV_SET(fields, 24);
  }

  differ = (old->trade_route_count != real_packet->trade_route_count);
  if (differ) {
    different++;
    BV_SET(fields, 25);
  }

  differ = (old->pollution != real_packet->pollution);
  if (differ) {
    different++;
    BV_SET(fields, 26);
  }

  differ = (old->illness_trade != real_packet->illness_trade);
  if (differ) {
    different++;
    BV_SET(fields, 27);
  }

  differ = (old->production_kind != real_packet->production_kind);
  if (differ) {
    different++;
    BV_SET(fields, 28);
  }

  differ = (old->production_value != real_packet->production_value);
  if (differ) {
    different++;
    BV_SET(fields, 29);
  }

  differ = (old->turn_founded != real_packet->turn_founded);
  if (differ) {
    different++;
    BV_SET(fields, 30);
  }

  differ = (old->turn_last_built != real_packet->turn_last_built);
  if (differ) {
    different++;
    BV_SET(fields, 31);
  }

  differ = (old->changed_from_kind != real_packet->changed_from_kind);
  if (differ) {
    different++;
    BV_SET(fields, 32);
  }

  differ = (old->changed_from_value != real_packet->changed_from_value);
  if (differ) {
    different++;
    BV_SET(fields, 33);
  }

  differ = (old->before_change_shields != real_packet->before_change_shields);
  if (differ) {
    different++;
    BV_SET(fields, 34);
  }

  differ = (old->disbanded_shields != real_packet->disbanded_shields);
  if (differ) {
    different++;
    BV_SET(fields, 35);
  }

  differ = (old->caravan_shields != real_packet->caravan_shields);
  if (differ) {
    different++;
    BV_SET(fields, 36);
  }

  differ = (old->last_turns_shield_surplus != real_packet->last_turns_shield_surplus);
  if (differ) {
    different++;
    BV_SET(fields, 37);
  }

  differ = (old->airlift != real_packet->airlift);
  if (differ) {
    different++;
    BV_SET(fields, 38);
  }

  differ = (old->did_buy != real_packet->did_buy);
  if (differ) {
    different++;
  }
  if (packet->did_buy) {
    BV_SET(fields, 39);
  }

  differ = (old->did_sell != real_packet->did_sell);
  if (differ) {
    different++;
  }
  if (packet->did_sell) {
    BV_SET(fields, 40);
  }

  differ = (old->was_happy != real_packet->was_happy);
  if (differ) {
    different++;
  }
  if (packet->was_happy) {
    BV_SET(fields, 41);
  }

  differ = (old->diplomat_investigate != real_packet->diplomat_investigate);
  if (differ) {
    different++;
  }
  if (packet->diplomat_investigate) {
    BV_SET(fields, 42);
  }

  differ = (old->walls != real_packet->walls);
  if (differ) {
    different++;
    BV_SET(fields, 43);
  }

  differ = (old->city_image != real_packet->city_image);
  if (differ) {
    different++;
    BV_SET(fields, 44);
  }

  differ = (old->steal != real_packet->steal);
  if (differ) {
    different++;
    BV_SET(fields, 45);
  }

  differ = !are_worklists_equal(&old->worklist, &real_packet->worklist);
  if (differ) {
    different++;
    BV_SET(fields, 46);
  }

  differ = !BV_ARE_EQUAL(old->improvements, real_packet->improvements);
  if (differ) {
    different++;
    BV_SET(fields, 47);
  }

  differ = !BV_ARE_EQUAL(old->city_options, real_packet->city_options);
  if (differ) {
    different++;
    BV_SET(fields, 48);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 49);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'original' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->original);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'city_radius_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_radius_sq);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'capital' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'ppl_happy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'ppl_content' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'ppl_unhappy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'ppl_angry' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'specialists_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'specialists' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'history' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'culture' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'buy_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->buy_cost);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'surplus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->surplus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'waste' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->waste[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'unhappy_penalty' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->unhappy_penalty[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'prod' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->prod[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'citizen_base' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->citizen_base[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'usage' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->usage[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'food_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->food_stock);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'shield_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'trade_route_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_route_count);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'pollution' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->pollution);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'illness_trade' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'production_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'production_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'turn_founded' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  field 'turn_last_built' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  field 'changed_from_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_kind);
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'changed_from_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_value);
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'before_change_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->before_change_shields);
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  field 'disbanded_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disbanded_shields);
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  field 'caravan_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->caravan_shields);
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  field 'last_turns_shield_surplus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->last_turns_shield_surplus);
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  field 'airlift' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlift);
  }
  /* field 39 is folded into the header */
  /* field 40 is folded into the header */
  /* field 41 is folded into the header */
  /* field 42 is folded into the header */
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  field 'walls' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  field 'city_image' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  field 'steal' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->steal);
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  field 'worklist' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  field 'improvements' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
  }
  if (BV_ISSET(fields, 48)) {
    log_packet_detailed("  field 'city_options' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
  }
  if (BV_ISSET(fields, 49)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->original);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_radius_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->buy_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->surplus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->waste[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->unhappy_penalty[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->prod[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->citizen_base[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->usage[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->food_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_route_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->pollution);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->before_change_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disbanded_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->caravan_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->last_turns_shield_surplus);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlift);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_buy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_sell);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->was_happy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomat_investigate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->diplomat_investigate);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->steal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_info_101 hash_const

#define cmp_packet_city_info_101 cmp_const

BV_DEFINE(packet_city_info_101_fields, 49);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_info *receive_packet_city_info_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_info_101_fields fields;
  struct packet_city_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_radius_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(city_radius_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
    RECEIVE_PACKET_FIELD_ERROR(style);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(capital);
    }
    real_packet->capital = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_content);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
    RECEIVE_PACKET_FIELD_ERROR(specialists_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->specialists_size > SP_MAX) {
      RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
    }
    for (i = 0; i < real_packet->specialists_size; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
        RECEIVE_PACKET_FIELD_ERROR(specialists);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
    RECEIVE_PACKET_FIELD_ERROR(history);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
    RECEIVE_PACKET_FIELD_ERROR(culture);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->buy_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(buy_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->surplus[i])) {
        RECEIVE_PACKET_FIELD_ERROR(surplus);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->waste[i])) {
        RECEIVE_PACKET_FIELD_ERROR(waste);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->unhappy_penalty[i])) {
        RECEIVE_PACKET_FIELD_ERROR(unhappy_penalty);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->prod[i])) {
        RECEIVE_PACKET_FIELD_ERROR(prod);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->citizen_base[i])) {
        RECEIVE_PACKET_FIELD_ERROR(citizen_base);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->usage[i])) {
        RECEIVE_PACKET_FIELD_ERROR(usage);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->food_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(food_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(shield_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_route_count)) {
    RECEIVE_PACKET_FIELD_ERROR(trade_route_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->pollution)) {
    RECEIVE_PACKET_FIELD_ERROR(pollution);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade)) {
    RECEIVE_PACKET_FIELD_ERROR(illness_trade);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(production_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
    RECEIVE_PACKET_FIELD_ERROR(production_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_founded);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_value)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->before_change_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(before_change_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disbanded_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(disbanded_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->caravan_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(caravan_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->last_turns_shield_surplus)) {
    RECEIVE_PACKET_FIELD_ERROR(last_turns_shield_surplus);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->airlift)) {
    RECEIVE_PACKET_FIELD_ERROR(airlift);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_buy)) {
    RECEIVE_PACKET_FIELD_ERROR(did_buy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_sell)) {
    RECEIVE_PACKET_FIELD_ERROR(did_sell);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->was_happy)) {
    RECEIVE_PACKET_FIELD_ERROR(was_happy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomat_investigate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->diplomat_investigate)) {
    RECEIVE_PACKET_FIELD_ERROR(diplomat_investigate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
    RECEIVE_PACKET_FIELD_ERROR(walls);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
    RECEIVE_PACKET_FIELD_ERROR(city_image);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->steal)) {
    RECEIVE_PACKET_FIELD_ERROR(steal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
    RECEIVE_PACKET_FIELD_ERROR(worklist);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
    RECEIVE_PACKET_FIELD_ERROR(improvements);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
    RECEIVE_PACKET_FIELD_ERROR(city_options);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_info_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_info_101, cmp_packet_city_info_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'city_radius_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_radius_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_radius_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(city_radius_sq);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
      RECEIVE_PACKET_FIELD_ERROR(style);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'capital'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "capital";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(capital);
      }
      real_packet->capital = readin;
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'ppl_happy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_happy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'ppl_content'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_content";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_content);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'ppl_unhappy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_unhappy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'ppl_angry'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_angry";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'specialists_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
      RECEIVE_PACKET_FIELD_ERROR(specialists_size);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'specialists'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->specialists_size > SP_MAX) {
        RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
      }
      for (i = 0; i < real_packet->specialists_size; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
          RECEIVE_PACKET_FIELD_ERROR(specialists);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'history'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "history";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
      RECEIVE_PACKET_FIELD_ERROR(history);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'culture'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "culture";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
      RECEIVE_PACKET_FIELD_ERROR(culture);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'buy_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "buy_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->buy_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(buy_cost);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'surplus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "surplus";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->surplus[i])) {
          RECEIVE_PACKET_FIELD_ERROR(surplus);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'waste'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "waste";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->waste[i])) {
          RECEIVE_PACKET_FIELD_ERROR(waste);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'unhappy_penalty'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unhappy_penalty";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->unhappy_penalty[i])) {
          RECEIVE_PACKET_FIELD_ERROR(unhappy_penalty);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'prod'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "prod";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->prod[i])) {
          RECEIVE_PACKET_FIELD_ERROR(prod);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'citizen_base'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "citizen_base";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->citizen_base[i])) {
          RECEIVE_PACKET_FIELD_ERROR(citizen_base);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'usage'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "usage";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->usage[i])) {
          RECEIVE_PACKET_FIELD_ERROR(usage);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'food_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "food_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->food_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(food_stock);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'shield_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "shield_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(shield_stock);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'trade_route_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "trade_route_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_route_count)) {
      RECEIVE_PACKET_FIELD_ERROR(trade_route_count);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'pollution'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "pollution";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->pollution)) {
      RECEIVE_PACKET_FIELD_ERROR(pollution);
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'illness_trade'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "illness_trade";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade)) {
      RECEIVE_PACKET_FIELD_ERROR(illness_trade);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'production_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(production_kind);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'production_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
      RECEIVE_PACKET_FIELD_ERROR(production_value);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'turn_founded'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_founded";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_founded);
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'turn_last_built'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_last_built";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  got field 'changed_from_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_kind);
    }
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  got field 'changed_from_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_value)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_value);
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'before_change_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "before_change_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->before_change_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(before_change_shields);
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'disbanded_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "disbanded_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disbanded_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(disbanded_shields);
    }
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  got field 'caravan_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "caravan_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->caravan_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(caravan_shields);
    }
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  got field 'last_turns_shield_surplus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "last_turns_shield_surplus";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->last_turns_shield_surplus)) {
      RECEIVE_PACKET_FIELD_ERROR(last_turns_shield_surplus);
    }
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  got field 'airlift'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "airlift";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->airlift)) {
      RECEIVE_PACKET_FIELD_ERROR(airlift);
    }
  }
  real_packet->did_buy = BV_ISSET(fields, 38);
  real_packet->did_sell = BV_ISSET(fields, 39);
  real_packet->was_happy = BV_ISSET(fields, 40);
  real_packet->diplomat_investigate = BV_ISSET(fields, 41);
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  got field 'walls'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "walls";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
      RECEIVE_PACKET_FIELD_ERROR(walls);
    }
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  got field 'city_image'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_image";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
      RECEIVE_PACKET_FIELD_ERROR(city_image);
    }
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  got field 'steal'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "steal";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->steal)) {
      RECEIVE_PACKET_FIELD_ERROR(steal);
    }
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  got field 'worklist'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "worklist";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
      RECEIVE_PACKET_FIELD_ERROR(worklist);
    }
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  got field 'improvements'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "improvements";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
      RECEIVE_PACKET_FIELD_ERROR(improvements);
    }
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  got field 'city_options'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_options";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
      RECEIVE_PACKET_FIELD_ERROR(city_options);
    }
  }
  if (BV_ISSET(fields, 48)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_info_101(struct connection *pc, const struct packet_city_info *packet, bool force_to_send)
{
  const struct packet_city_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_info_101_fields fields;
  struct packet_city_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_INFO;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_info_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_info_101, cmp_packet_city_info_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->city_radius_sq != real_packet->city_radius_sq);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->style != real_packet->style);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->capital != real_packet->capital);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_happy[i] != real_packet->ppl_happy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_content[i] != real_packet->ppl_content[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_unhappy[i] != real_packet->ppl_unhappy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_angry[i] != real_packet->ppl_angry[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (old->specialists_size != real_packet->specialists_size);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }


    {
      differ = (old->specialists_size != real_packet->specialists_size);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->specialists_size; i++) {
          if (old->specialists[i] != real_packet->specialists[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }

  differ = (old->history != real_packet->history);
  if (differ) {
    different++;
    BV_SET(fields, 13);
  }

  differ = (old->culture != real_packet->culture);
  if (differ) {
    different++;
    BV_SET(fields, 14);
  }

  differ = (old->buy_cost != real_packet->buy_cost);
  if (differ) {
    different++;
    BV_SET(fields, 15);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->surplus[i] != real_packet->surplus[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 16);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->waste[i] != real_packet->waste[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 17);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->unhappy_penalty[i] != real_packet->unhappy_penalty[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 18);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->prod[i] != real_packet->prod[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 19);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->citizen_base[i] != real_packet->citizen_base[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 20);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->usage[i] != real_packet->usage[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 21);
  }

  differ = (old->food_stock != real_packet->food_stock);
  if (differ) {
    different++;
    BV_SET(fields, 22);
  }

  differ = (old->shield_stock != real_packet->shield_stock);
  if (differ) {
    different++;
    BV_SET(fields, 23);
  }

  differ = (old->trade_route_count != real_packet->trade_route_count);
  if (differ) {
    different++;
    BV_SET(fields, 24);
  }

  differ = (old->pollution != real_packet->pollution);
  if (differ) {
    different++;
    BV_SET(fields, 25);
  }

  differ = (old->illness_trade != real_packet->illness_trade);
  if (differ) {
    different++;
    BV_SET(fields, 26);
  }

  differ = (old->production_kind != real_packet->production_kind);
  if (differ) {
    different++;
    BV_SET(fields, 27);
  }

  differ = (old->production_value != real_packet->production_value);
  if (differ) {
    different++;
    BV_SET(fields, 28);
  }

  differ = (old->turn_founded != real_packet->turn_founded);
  if (differ) {
    different++;
    BV_SET(fields, 29);
  }

  differ = (old->turn_last_built != real_packet->turn_last_built);
  if (differ) {
    different++;
    BV_SET(fields, 30);
  }

  differ = (old->changed_from_kind != real_packet->changed_from_kind);
  if (differ) {
    different++;
    BV_SET(fields, 31);
  }

  differ = (old->changed_from_value != real_packet->changed_from_value);
  if (differ) {
    different++;
    BV_SET(fields, 32);
  }

  differ = (old->before_change_shields != real_packet->before_change_shields);
  if (differ) {
    different++;
    BV_SET(fields, 33);
  }

  differ = (old->disbanded_shields != real_packet->disbanded_shields);
  if (differ) {
    different++;
    BV_SET(fields, 34);
  }

  differ = (old->caravan_shields != real_packet->caravan_shields);
  if (differ) {
    different++;
    BV_SET(fields, 35);
  }

  differ = (old->last_turns_shield_surplus != real_packet->last_turns_shield_surplus);
  if (differ) {
    different++;
    BV_SET(fields, 36);
  }

  differ = (old->airlift != real_packet->airlift);
  if (differ) {
    different++;
    BV_SET(fields, 37);
  }

  differ = (old->did_buy != real_packet->did_buy);
  if (differ) {
    different++;
  }
  if (packet->did_buy) {
    BV_SET(fields, 38);
  }

  differ = (old->did_sell != real_packet->did_sell);
  if (differ) {
    different++;
  }
  if (packet->did_sell) {
    BV_SET(fields, 39);
  }

  differ = (old->was_happy != real_packet->was_happy);
  if (differ) {
    different++;
  }
  if (packet->was_happy) {
    BV_SET(fields, 40);
  }

  differ = (old->diplomat_investigate != real_packet->diplomat_investigate);
  if (differ) {
    different++;
  }
  if (packet->diplomat_investigate) {
    BV_SET(fields, 41);
  }

  differ = (old->walls != real_packet->walls);
  if (differ) {
    different++;
    BV_SET(fields, 42);
  }

  differ = (old->city_image != real_packet->city_image);
  if (differ) {
    different++;
    BV_SET(fields, 43);
  }

  differ = (old->steal != real_packet->steal);
  if (differ) {
    different++;
    BV_SET(fields, 44);
  }

  differ = !are_worklists_equal(&old->worklist, &real_packet->worklist);
  if (differ) {
    different++;
    BV_SET(fields, 45);
  }

  differ = !BV_ARE_EQUAL(old->improvements, real_packet->improvements);
  if (differ) {
    different++;
    BV_SET(fields, 46);
  }

  differ = !BV_ARE_EQUAL(old->city_options, real_packet->city_options);
  if (differ) {
    different++;
    BV_SET(fields, 47);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 48);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'city_radius_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_radius_sq);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'capital' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'ppl_happy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'ppl_content' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'ppl_unhappy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'ppl_angry' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'specialists_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'specialists' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'history' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'culture' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'buy_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->buy_cost);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'surplus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->surplus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'waste' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->waste[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'unhappy_penalty' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->unhappy_penalty[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'prod' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->prod[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'citizen_base' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->citizen_base[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'usage' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->usage[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'food_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->food_stock);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'shield_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'trade_route_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_route_count);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'pollution' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->pollution);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'illness_trade' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'production_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'production_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'turn_founded' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'turn_last_built' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  field 'changed_from_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_kind);
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  field 'changed_from_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_value);
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'before_change_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->before_change_shields);
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'disbanded_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disbanded_shields);
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  field 'caravan_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->caravan_shields);
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  field 'last_turns_shield_surplus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->last_turns_shield_surplus);
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  field 'airlift' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlift);
  }
  /* field 38 is folded into the header */
  /* field 39 is folded into the header */
  /* field 40 is folded into the header */
  /* field 41 is folded into the header */
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  field 'walls' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  field 'city_image' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  field 'steal' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->steal);
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  field 'worklist' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  field 'improvements' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  field 'city_options' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
  }
  if (BV_ISSET(fields, 48)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_radius_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->buy_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->surplus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->waste[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->unhappy_penalty[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->prod[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->citizen_base[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->usage[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->food_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_route_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->pollution);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->before_change_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disbanded_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->caravan_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->last_turns_shield_surplus);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlift);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_buy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_sell);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->was_happy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomat_investigate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->diplomat_investigate);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->steal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_city_info_102(const void *vkey)
{
  const struct packet_city_info *key = (const struct packet_city_info *) vkey;

  return key->id16;
}

static bool cmp_packet_city_info_102(const void *vkey1, const void *vkey2)
{
  const struct packet_city_info *key1 = (const struct packet_city_info *) vkey1;
  const struct packet_city_info *key2 = (const struct packet_city_info *) vkey2;

  return key1->id16 == key2->id16;
}
BV_DEFINE(packet_city_info_102_fields, 49);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_info *receive_packet_city_info_102(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_info_102_fields fields;
  struct packet_city_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->original)) {
    RECEIVE_PACKET_FIELD_ERROR(original);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_radius_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(city_radius_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
    RECEIVE_PACKET_FIELD_ERROR(style);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(capital);
    }
    real_packet->capital = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_content);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
    RECEIVE_PACKET_FIELD_ERROR(specialists_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->specialists_size > SP_MAX) {
      RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
    }
    for (i = 0; i < real_packet->specialists_size; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
        RECEIVE_PACKET_FIELD_ERROR(specialists);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
    RECEIVE_PACKET_FIELD_ERROR(history);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
    RECEIVE_PACKET_FIELD_ERROR(culture);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->buy_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(buy_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->surplus[i])) {
        RECEIVE_PACKET_FIELD_ERROR(surplus);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->waste[i])) {
        RECEIVE_PACKET_FIELD_ERROR(waste);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->unhappy_penalty[i])) {
        RECEIVE_PACKET_FIELD_ERROR(unhappy_penalty);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->prod[i])) {
        RECEIVE_PACKET_FIELD_ERROR(prod);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->citizen_base[i])) {
        RECEIVE_PACKET_FIELD_ERROR(citizen_base);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->usage[i])) {
        RECEIVE_PACKET_FIELD_ERROR(usage);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->food_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(food_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(shield_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_route_count)) {
    RECEIVE_PACKET_FIELD_ERROR(trade_route_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->pollution)) {
    RECEIVE_PACKET_FIELD_ERROR(pollution);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade)) {
    RECEIVE_PACKET_FIELD_ERROR(illness_trade);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(production_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
    RECEIVE_PACKET_FIELD_ERROR(production_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_founded);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_value)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->before_change_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(before_change_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disbanded_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(disbanded_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->caravan_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(caravan_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->last_turns_shield_surplus)) {
    RECEIVE_PACKET_FIELD_ERROR(last_turns_shield_surplus);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->airlift)) {
    RECEIVE_PACKET_FIELD_ERROR(airlift);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_buy)) {
    RECEIVE_PACKET_FIELD_ERROR(did_buy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_sell)) {
    RECEIVE_PACKET_FIELD_ERROR(did_sell);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->was_happy)) {
    RECEIVE_PACKET_FIELD_ERROR(was_happy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomat_investigate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->diplomat_investigate)) {
    RECEIVE_PACKET_FIELD_ERROR(diplomat_investigate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
    RECEIVE_PACKET_FIELD_ERROR(walls);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
    RECEIVE_PACKET_FIELD_ERROR(city_image);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->steal)) {
    RECEIVE_PACKET_FIELD_ERROR(steal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
    RECEIVE_PACKET_FIELD_ERROR(worklist);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
    RECEIVE_PACKET_FIELD_ERROR(improvements);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
    RECEIVE_PACKET_FIELD_ERROR(city_options);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_info_102: got info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_info_102, cmp_packet_city_info_102,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id16 = real_packet->id16;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id16 = id16;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'original'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "original";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->original)) {
      RECEIVE_PACKET_FIELD_ERROR(original);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'city_radius_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_radius_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_radius_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(city_radius_sq);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
      RECEIVE_PACKET_FIELD_ERROR(style);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'capital'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "capital";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(capital);
      }
      real_packet->capital = readin;
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'ppl_happy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_happy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'ppl_content'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_content";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_content);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'ppl_unhappy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_unhappy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'ppl_angry'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_angry";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'specialists_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
      RECEIVE_PACKET_FIELD_ERROR(specialists_size);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'specialists'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->specialists_size > SP_MAX) {
        RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
      }
      for (i = 0; i < real_packet->specialists_size; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
          RECEIVE_PACKET_FIELD_ERROR(specialists);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'history'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "history";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
      RECEIVE_PACKET_FIELD_ERROR(history);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'culture'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "culture";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
      RECEIVE_PACKET_FIELD_ERROR(culture);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'buy_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "buy_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->buy_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(buy_cost);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'surplus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "surplus";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->surplus[i])) {
          RECEIVE_PACKET_FIELD_ERROR(surplus);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'waste'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "waste";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->waste[i])) {
          RECEIVE_PACKET_FIELD_ERROR(waste);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'unhappy_penalty'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unhappy_penalty";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->unhappy_penalty[i])) {
          RECEIVE_PACKET_FIELD_ERROR(unhappy_penalty);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'prod'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "prod";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->prod[i])) {
          RECEIVE_PACKET_FIELD_ERROR(prod);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'citizen_base'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "citizen_base";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->citizen_base[i])) {
          RECEIVE_PACKET_FIELD_ERROR(citizen_base);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'usage'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "usage";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->usage[i])) {
          RECEIVE_PACKET_FIELD_ERROR(usage);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'food_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "food_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->food_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(food_stock);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'shield_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "shield_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(shield_stock);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'trade_route_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "trade_route_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_route_count)) {
      RECEIVE_PACKET_FIELD_ERROR(trade_route_count);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'pollution'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "pollution";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->pollution)) {
      RECEIVE_PACKET_FIELD_ERROR(pollution);
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'illness_trade'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "illness_trade";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade)) {
      RECEIVE_PACKET_FIELD_ERROR(illness_trade);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'production_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(production_kind);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'production_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
      RECEIVE_PACKET_FIELD_ERROR(production_value);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'turn_founded'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_founded";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_founded);
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'turn_last_built'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_last_built";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  got field 'changed_from_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_kind);
    }
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  got field 'changed_from_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_value)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_value);
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'before_change_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "before_change_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->before_change_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(before_change_shields);
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'disbanded_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "disbanded_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disbanded_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(disbanded_shields);
    }
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  got field 'caravan_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "caravan_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->caravan_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(caravan_shields);
    }
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  got field 'last_turns_shield_surplus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "last_turns_shield_surplus";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->last_turns_shield_surplus)) {
      RECEIVE_PACKET_FIELD_ERROR(last_turns_shield_surplus);
    }
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  got field 'airlift'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "airlift";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->airlift)) {
      RECEIVE_PACKET_FIELD_ERROR(airlift);
    }
  }
  real_packet->did_buy = BV_ISSET(fields, 38);
  real_packet->did_sell = BV_ISSET(fields, 39);
  real_packet->was_happy = BV_ISSET(fields, 40);
  real_packet->diplomat_investigate = BV_ISSET(fields, 41);
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  got field 'walls'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "walls";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
      RECEIVE_PACKET_FIELD_ERROR(walls);
    }
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  got field 'city_image'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_image";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
      RECEIVE_PACKET_FIELD_ERROR(city_image);
    }
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  got field 'steal'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "steal";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->steal)) {
      RECEIVE_PACKET_FIELD_ERROR(steal);
    }
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  got field 'worklist'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "worklist";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
      RECEIVE_PACKET_FIELD_ERROR(worklist);
    }
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  got field 'improvements'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "improvements";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
      RECEIVE_PACKET_FIELD_ERROR(improvements);
    }
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  got field 'city_options'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_options";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
      RECEIVE_PACKET_FIELD_ERROR(city_options);
    }
  }
  if (BV_ISSET(fields, 48)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_info_102(struct connection *pc, const struct packet_city_info *packet, bool force_to_send)
{
  const struct packet_city_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_info_102_fields fields;
  struct packet_city_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_INFO;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_info_102: sending info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_info_102, cmp_packet_city_info_102,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->original != real_packet->original);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->city_radius_sq != real_packet->city_radius_sq);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->style != real_packet->style);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->capital != real_packet->capital);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_happy[i] != real_packet->ppl_happy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_content[i] != real_packet->ppl_content[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_unhappy[i] != real_packet->ppl_unhappy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_angry[i] != real_packet->ppl_angry[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (old->specialists_size != real_packet->specialists_size);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }


    {
      differ = (old->specialists_size != real_packet->specialists_size);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->specialists_size; i++) {
          if (old->specialists[i] != real_packet->specialists[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }

  differ = (old->history != real_packet->history);
  if (differ) {
    different++;
    BV_SET(fields, 13);
  }

  differ = (old->culture != real_packet->culture);
  if (differ) {
    different++;
    BV_SET(fields, 14);
  }

  differ = (old->buy_cost != real_packet->buy_cost);
  if (differ) {
    different++;
    BV_SET(fields, 15);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->surplus[i] != real_packet->surplus[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 16);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->waste[i] != real_packet->waste[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 17);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->unhappy_penalty[i] != real_packet->unhappy_penalty[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 18);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->prod[i] != real_packet->prod[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 19);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->citizen_base[i] != real_packet->citizen_base[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 20);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->usage[i] != real_packet->usage[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 21);
  }

  differ = (old->food_stock != real_packet->food_stock);
  if (differ) {
    different++;
    BV_SET(fields, 22);
  }

  differ = (old->shield_stock != real_packet->shield_stock);
  if (differ) {
    different++;
    BV_SET(fields, 23);
  }

  differ = (old->trade_route_count != real_packet->trade_route_count);
  if (differ) {
    different++;
    BV_SET(fields, 24);
  }

  differ = (old->pollution != real_packet->pollution);
  if (differ) {
    different++;
    BV_SET(fields, 25);
  }

  differ = (old->illness_trade != real_packet->illness_trade);
  if (differ) {
    different++;
    BV_SET(fields, 26);
  }

  differ = (old->production_kind != real_packet->production_kind);
  if (differ) {
    different++;
    BV_SET(fields, 27);
  }

  differ = (old->production_value != real_packet->production_value);
  if (differ) {
    different++;
    BV_SET(fields, 28);
  }

  differ = (old->turn_founded != real_packet->turn_founded);
  if (differ) {
    different++;
    BV_SET(fields, 29);
  }

  differ = (old->turn_last_built != real_packet->turn_last_built);
  if (differ) {
    different++;
    BV_SET(fields, 30);
  }

  differ = (old->changed_from_kind != real_packet->changed_from_kind);
  if (differ) {
    different++;
    BV_SET(fields, 31);
  }

  differ = (old->changed_from_value != real_packet->changed_from_value);
  if (differ) {
    different++;
    BV_SET(fields, 32);
  }

  differ = (old->before_change_shields != real_packet->before_change_shields);
  if (differ) {
    different++;
    BV_SET(fields, 33);
  }

  differ = (old->disbanded_shields != real_packet->disbanded_shields);
  if (differ) {
    different++;
    BV_SET(fields, 34);
  }

  differ = (old->caravan_shields != real_packet->caravan_shields);
  if (differ) {
    different++;
    BV_SET(fields, 35);
  }

  differ = (old->last_turns_shield_surplus != real_packet->last_turns_shield_surplus);
  if (differ) {
    different++;
    BV_SET(fields, 36);
  }

  differ = (old->airlift != real_packet->airlift);
  if (differ) {
    different++;
    BV_SET(fields, 37);
  }

  differ = (old->did_buy != real_packet->did_buy);
  if (differ) {
    different++;
  }
  if (packet->did_buy) {
    BV_SET(fields, 38);
  }

  differ = (old->did_sell != real_packet->did_sell);
  if (differ) {
    different++;
  }
  if (packet->did_sell) {
    BV_SET(fields, 39);
  }

  differ = (old->was_happy != real_packet->was_happy);
  if (differ) {
    different++;
  }
  if (packet->was_happy) {
    BV_SET(fields, 40);
  }

  differ = (old->diplomat_investigate != real_packet->diplomat_investigate);
  if (differ) {
    different++;
  }
  if (packet->diplomat_investigate) {
    BV_SET(fields, 41);
  }

  differ = (old->walls != real_packet->walls);
  if (differ) {
    different++;
    BV_SET(fields, 42);
  }

  differ = (old->city_image != real_packet->city_image);
  if (differ) {
    different++;
    BV_SET(fields, 43);
  }

  differ = (old->steal != real_packet->steal);
  if (differ) {
    different++;
    BV_SET(fields, 44);
  }

  differ = !are_worklists_equal(&old->worklist, &real_packet->worklist);
  if (differ) {
    different++;
    BV_SET(fields, 45);
  }

  differ = !BV_ARE_EQUAL(old->improvements, real_packet->improvements);
  if (differ) {
    different++;
    BV_SET(fields, 46);
  }

  differ = !BV_ARE_EQUAL(old->city_options, real_packet->city_options);
  if (differ) {
    different++;
    BV_SET(fields, 47);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 48);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'original' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->original);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'city_radius_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_radius_sq);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'capital' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'ppl_happy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'ppl_content' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'ppl_unhappy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'ppl_angry' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'specialists_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'specialists' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'history' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'culture' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'buy_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->buy_cost);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'surplus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->surplus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'waste' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->waste[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'unhappy_penalty' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->unhappy_penalty[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'prod' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->prod[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'citizen_base' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->citizen_base[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'usage' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->usage[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'food_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->food_stock);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'shield_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'trade_route_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_route_count);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'pollution' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->pollution);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'illness_trade' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'production_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'production_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'turn_founded' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'turn_last_built' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  field 'changed_from_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_kind);
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  field 'changed_from_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_value);
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'before_change_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->before_change_shields);
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'disbanded_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disbanded_shields);
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  field 'caravan_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->caravan_shields);
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  field 'last_turns_shield_surplus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->last_turns_shield_surplus);
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  field 'airlift' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlift);
  }
  /* field 38 is folded into the header */
  /* field 39 is folded into the header */
  /* field 40 is folded into the header */
  /* field 41 is folded into the header */
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  field 'walls' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  field 'city_image' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  field 'steal' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->steal);
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  field 'worklist' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  field 'improvements' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  field 'city_options' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
  }
  if (BV_ISSET(fields, 48)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->original);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_radius_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->buy_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->surplus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->waste[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->unhappy_penalty[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->prod[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->citizen_base[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->usage[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->food_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_route_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->pollution);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->before_change_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disbanded_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->caravan_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->last_turns_shield_surplus);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlift);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_buy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_sell);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->was_happy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomat_investigate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->diplomat_investigate);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->steal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_city_info_103(const void *vkey)
{
  const struct packet_city_info *key = (const struct packet_city_info *) vkey;

  return key->id16;
}

static bool cmp_packet_city_info_103(const void *vkey1, const void *vkey2)
{
  const struct packet_city_info *key1 = (const struct packet_city_info *) vkey1;
  const struct packet_city_info *key2 = (const struct packet_city_info *) vkey2;

  return key1->id16 == key2->id16;
}
BV_DEFINE(packet_city_info_103_fields, 48);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_info *receive_packet_city_info_103(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_info_103_fields fields;
  struct packet_city_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_radius_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(city_radius_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
    RECEIVE_PACKET_FIELD_ERROR(style);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(capital);
    }
    real_packet->capital = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_content);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < FEELING_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
    RECEIVE_PACKET_FIELD_ERROR(specialists_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->specialists_size > SP_MAX) {
      RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
    }
    for (i = 0; i < real_packet->specialists_size; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
        RECEIVE_PACKET_FIELD_ERROR(specialists);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
    RECEIVE_PACKET_FIELD_ERROR(history);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
    RECEIVE_PACKET_FIELD_ERROR(culture);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->buy_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(buy_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->surplus[i])) {
        RECEIVE_PACKET_FIELD_ERROR(surplus);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->waste[i])) {
        RECEIVE_PACKET_FIELD_ERROR(waste);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->unhappy_penalty[i])) {
        RECEIVE_PACKET_FIELD_ERROR(unhappy_penalty);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->prod[i])) {
        RECEIVE_PACKET_FIELD_ERROR(prod);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->citizen_base[i])) {
        RECEIVE_PACKET_FIELD_ERROR(citizen_base);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->usage[i])) {
        RECEIVE_PACKET_FIELD_ERROR(usage);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->food_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(food_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(shield_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_route_count)) {
    RECEIVE_PACKET_FIELD_ERROR(trade_route_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->pollution)) {
    RECEIVE_PACKET_FIELD_ERROR(pollution);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade)) {
    RECEIVE_PACKET_FIELD_ERROR(illness_trade);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(production_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
    RECEIVE_PACKET_FIELD_ERROR(production_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_founded);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_value)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->before_change_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(before_change_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disbanded_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(disbanded_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->caravan_shields)) {
    RECEIVE_PACKET_FIELD_ERROR(caravan_shields);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->last_turns_shield_surplus)) {
    RECEIVE_PACKET_FIELD_ERROR(last_turns_shield_surplus);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->airlift)) {
    RECEIVE_PACKET_FIELD_ERROR(airlift);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_buy)) {
    RECEIVE_PACKET_FIELD_ERROR(did_buy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_sell)) {
    RECEIVE_PACKET_FIELD_ERROR(did_sell);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->was_happy)) {
    RECEIVE_PACKET_FIELD_ERROR(was_happy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomat_investigate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->diplomat_investigate)) {
    RECEIVE_PACKET_FIELD_ERROR(diplomat_investigate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
    RECEIVE_PACKET_FIELD_ERROR(walls);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
    RECEIVE_PACKET_FIELD_ERROR(city_image);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->steal)) {
    RECEIVE_PACKET_FIELD_ERROR(steal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
    RECEIVE_PACKET_FIELD_ERROR(worklist);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
    RECEIVE_PACKET_FIELD_ERROR(improvements);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
    RECEIVE_PACKET_FIELD_ERROR(city_options);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_info_103: got info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_info_103, cmp_packet_city_info_103,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id16 = real_packet->id16;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id16 = id16;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'city_radius_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_radius_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_radius_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(city_radius_sq);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
      RECEIVE_PACKET_FIELD_ERROR(style);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'capital'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "capital";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(capital);
      }
      real_packet->capital = readin;
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'ppl_happy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_happy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'ppl_content'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_content";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_content);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'ppl_unhappy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_unhappy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'ppl_angry'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_angry";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < FEELING_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'specialists_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
      RECEIVE_PACKET_FIELD_ERROR(specialists_size);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'specialists'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->specialists_size > SP_MAX) {
        RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
      }
      for (i = 0; i < real_packet->specialists_size; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
          RECEIVE_PACKET_FIELD_ERROR(specialists);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'history'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "history";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
      RECEIVE_PACKET_FIELD_ERROR(history);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'culture'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "culture";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
      RECEIVE_PACKET_FIELD_ERROR(culture);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'buy_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "buy_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->buy_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(buy_cost);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'surplus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "surplus";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->surplus[i])) {
          RECEIVE_PACKET_FIELD_ERROR(surplus);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'waste'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "waste";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->waste[i])) {
          RECEIVE_PACKET_FIELD_ERROR(waste);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'unhappy_penalty'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unhappy_penalty";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->unhappy_penalty[i])) {
          RECEIVE_PACKET_FIELD_ERROR(unhappy_penalty);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'prod'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "prod";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->prod[i])) {
          RECEIVE_PACKET_FIELD_ERROR(prod);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'citizen_base'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "citizen_base";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->citizen_base[i])) {
          RECEIVE_PACKET_FIELD_ERROR(citizen_base);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'usage'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "usage";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->usage[i])) {
          RECEIVE_PACKET_FIELD_ERROR(usage);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'food_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "food_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->food_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(food_stock);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'shield_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "shield_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(shield_stock);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'trade_route_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "trade_route_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->trade_route_count)) {
      RECEIVE_PACKET_FIELD_ERROR(trade_route_count);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'pollution'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "pollution";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->pollution)) {
      RECEIVE_PACKET_FIELD_ERROR(pollution);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'illness_trade'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "illness_trade";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->illness_trade)) {
      RECEIVE_PACKET_FIELD_ERROR(illness_trade);
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'production_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(production_kind);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'production_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
      RECEIVE_PACKET_FIELD_ERROR(production_value);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'turn_founded'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_founded";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_founded);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'turn_last_built'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_last_built";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'changed_from_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_kind);
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  got field 'changed_from_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->changed_from_value)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_value);
    }
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  got field 'before_change_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "before_change_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->before_change_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(before_change_shields);
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'disbanded_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "disbanded_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disbanded_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(disbanded_shields);
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'caravan_shields'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "caravan_shields";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->caravan_shields)) {
      RECEIVE_PACKET_FIELD_ERROR(caravan_shields);
    }
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  got field 'last_turns_shield_surplus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "last_turns_shield_surplus";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->last_turns_shield_surplus)) {
      RECEIVE_PACKET_FIELD_ERROR(last_turns_shield_surplus);
    }
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  got field 'airlift'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "airlift";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->airlift)) {
      RECEIVE_PACKET_FIELD_ERROR(airlift);
    }
  }
  real_packet->did_buy = BV_ISSET(fields, 37);
  real_packet->did_sell = BV_ISSET(fields, 38);
  real_packet->was_happy = BV_ISSET(fields, 39);
  real_packet->diplomat_investigate = BV_ISSET(fields, 40);
  if (BV_ISSET(fields, 41)) {
    log_packet_detailed("  got field 'walls'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "walls";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
      RECEIVE_PACKET_FIELD_ERROR(walls);
    }
  }
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  got field 'city_image'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_image";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
      RECEIVE_PACKET_FIELD_ERROR(city_image);
    }
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  got field 'steal'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "steal";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->steal)) {
      RECEIVE_PACKET_FIELD_ERROR(steal);
    }
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  got field 'worklist'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "worklist";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
      RECEIVE_PACKET_FIELD_ERROR(worklist);
    }
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  got field 'improvements'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "improvements";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
      RECEIVE_PACKET_FIELD_ERROR(improvements);
    }
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  got field 'city_options'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_options";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
      RECEIVE_PACKET_FIELD_ERROR(city_options);
    }
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_info_103(struct connection *pc, const struct packet_city_info *packet, bool force_to_send)
{
  const struct packet_city_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_info_103_fields fields;
  struct packet_city_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_INFO;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_info_103: sending info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_info_103, cmp_packet_city_info_103,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->city_radius_sq != real_packet->city_radius_sq);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->style != real_packet->style);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->capital != real_packet->capital);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_happy[i] != real_packet->ppl_happy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_content[i] != real_packet->ppl_content[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_unhappy[i] != real_packet->ppl_unhappy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < FEELING_LAST; i++) {
          if (old->ppl_angry[i] != real_packet->ppl_angry[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }

  differ = (old->specialists_size != real_packet->specialists_size);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }


    {
      differ = (old->specialists_size != real_packet->specialists_size);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->specialists_size; i++) {
          if (old->specialists[i] != real_packet->specialists[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }

  differ = (old->history != real_packet->history);
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }

  differ = (old->culture != real_packet->culture);
  if (differ) {
    different++;
    BV_SET(fields, 13);
  }

  differ = (old->buy_cost != real_packet->buy_cost);
  if (differ) {
    different++;
    BV_SET(fields, 14);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->surplus[i] != real_packet->surplus[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 15);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->waste[i] != real_packet->waste[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 16);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->unhappy_penalty[i] != real_packet->unhappy_penalty[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 17);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->prod[i] != real_packet->prod[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 18);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->citizen_base[i] != real_packet->citizen_base[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 19);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->usage[i] != real_packet->usage[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 20);
  }

  differ = (old->food_stock != real_packet->food_stock);
  if (differ) {
    different++;
    BV_SET(fields, 21);
  }

  differ = (old->shield_stock != real_packet->shield_stock);
  if (differ) {
    different++;
    BV_SET(fields, 22);
  }

  differ = (old->trade_route_count != real_packet->trade_route_count);
  if (differ) {
    different++;
    BV_SET(fields, 23);
  }

  differ = (old->pollution != real_packet->pollution);
  if (differ) {
    different++;
    BV_SET(fields, 24);
  }

  differ = (old->illness_trade != real_packet->illness_trade);
  if (differ) {
    different++;
    BV_SET(fields, 25);
  }

  differ = (old->production_kind != real_packet->production_kind);
  if (differ) {
    different++;
    BV_SET(fields, 26);
  }

  differ = (old->production_value != real_packet->production_value);
  if (differ) {
    different++;
    BV_SET(fields, 27);
  }

  differ = (old->turn_founded != real_packet->turn_founded);
  if (differ) {
    different++;
    BV_SET(fields, 28);
  }

  differ = (old->turn_last_built != real_packet->turn_last_built);
  if (differ) {
    different++;
    BV_SET(fields, 29);
  }

  differ = (old->changed_from_kind != real_packet->changed_from_kind);
  if (differ) {
    different++;
    BV_SET(fields, 30);
  }

  differ = (old->changed_from_value != real_packet->changed_from_value);
  if (differ) {
    different++;
    BV_SET(fields, 31);
  }

  differ = (old->before_change_shields != real_packet->before_change_shields);
  if (differ) {
    different++;
    BV_SET(fields, 32);
  }

  differ = (old->disbanded_shields != real_packet->disbanded_shields);
  if (differ) {
    different++;
    BV_SET(fields, 33);
  }

  differ = (old->caravan_shields != real_packet->caravan_shields);
  if (differ) {
    different++;
    BV_SET(fields, 34);
  }

  differ = (old->last_turns_shield_surplus != real_packet->last_turns_shield_surplus);
  if (differ) {
    different++;
    BV_SET(fields, 35);
  }

  differ = (old->airlift != real_packet->airlift);
  if (differ) {
    different++;
    BV_SET(fields, 36);
  }

  differ = (old->did_buy != real_packet->did_buy);
  if (differ) {
    different++;
  }
  if (packet->did_buy) {
    BV_SET(fields, 37);
  }

  differ = (old->did_sell != real_packet->did_sell);
  if (differ) {
    different++;
  }
  if (packet->did_sell) {
    BV_SET(fields, 38);
  }

  differ = (old->was_happy != real_packet->was_happy);
  if (differ) {
    different++;
  }
  if (packet->was_happy) {
    BV_SET(fields, 39);
  }

  differ = (old->diplomat_investigate != real_packet->diplomat_investigate);
  if (differ) {
    different++;
  }
  if (packet->diplomat_investigate) {
    BV_SET(fields, 40);
  }

  differ = (old->walls != real_packet->walls);
  if (differ) {
    different++;
    BV_SET(fields, 41);
  }

  differ = (old->city_image != real_packet->city_image);
  if (differ) {
    different++;
    BV_SET(fields, 42);
  }

  differ = (old->steal != real_packet->steal);
  if (differ) {
    different++;
    BV_SET(fields, 43);
  }

  differ = !are_worklists_equal(&old->worklist, &real_packet->worklist);
  if (differ) {
    different++;
    BV_SET(fields, 44);
  }

  differ = !BV_ARE_EQUAL(old->improvements, real_packet->improvements);
  if (differ) {
    different++;
    BV_SET(fields, 45);
  }

  differ = !BV_ARE_EQUAL(old->city_options, real_packet->city_options);
  if (differ) {
    different++;
    BV_SET(fields, 46);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 47);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'city_radius_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_radius_sq);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'capital' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'ppl_happy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'ppl_content' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'ppl_unhappy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'ppl_angry' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'specialists_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'specialists' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'history' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'culture' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'buy_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->buy_cost);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'surplus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->surplus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'waste' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->waste[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'unhappy_penalty' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->unhappy_penalty[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'prod' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->prod[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'citizen_base' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->citizen_base[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'usage' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->usage[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'food_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->food_stock);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'shield_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'trade_route_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_route_count);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'pollution' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->pollution);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'illness_trade' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'production_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'production_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'turn_founded' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'turn_last_built' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'changed_from_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_kind);
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  field 'changed_from_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_value);
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  field 'before_change_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->before_change_shields);
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'disbanded_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disbanded_shields);
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'caravan_shields' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->caravan_shields);
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  field 'last_turns_shield_surplus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->last_turns_shield_surplus);
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  field 'airlift' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlift);
  }
  /* field 37 is folded into the header */
  /* field 38 is folded into the header */
  /* field 39 is folded into the header */
  /* field 40 is folded into the header */
  if (BV_ISSET(fields, 41)) {
    log_packet_detailed("  field 'walls' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
  }
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  field 'city_image' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  field 'steal' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->steal);
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  field 'worklist' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  field 'improvements' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  field 'city_options' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
  }
  if (BV_ISSET(fields, 47)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_radius_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, FEELING_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < FEELING_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->buy_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "surplus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->surplus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "waste";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->waste[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy_penalty";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->unhappy_penalty[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prod";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->prod[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizen_base";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->citizen_base[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "usage";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->usage[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->food_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_route_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->trade_route_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pollution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->pollution);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "illness_trade";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->illness_trade);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "before_change_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->before_change_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disbanded_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disbanded_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caravan_shields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->caravan_shields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "last_turns_shield_surplus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->last_turns_shield_surplus);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->airlift);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_buy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_sell);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->was_happy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplomat_investigate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->diplomat_investigate);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->steal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_INFO);
}

int send_packet_city_info(struct connection *pc, const struct packet_city_info *packet, bool force_to_send)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_INFO].force_to_send != NULL, -1,
                        "Handler for PACKET_CITY_INFO not installed");
  return pc->phs.handlers->send[PACKET_CITY_INFO].force_to_send(pc, packet, force_to_send);
}

void lsend_packet_city_info(struct conn_list *dest, const struct packet_city_info *packet, bool force_to_send)
{
  conn_list_iterate(dest, pconn) {
    send_packet_city_info(pconn, packet, force_to_send);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_nationalities_100 hash_const

#define cmp_packet_city_nationalities_100 cmp_const

BV_DEFINE(packet_city_nationalities_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_nationalities *receive_packet_city_nationalities_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_nationalities_100_fields fields;
  struct packet_city_nationalities *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_NATIONALITIES;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_nationalities, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationalities_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nationalities_count)) {
    RECEIVE_PACKET_FIELD_ERROR(nationalities_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_id";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->nationalities_count > MAX_CITY_NATIONALITIES) {
      RECEIVE_PACKET_FIELD_ERROR(nation_id, ": truncation array");
    }
    for (i = 0; i < real_packet->nationalities_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nation_id[i])) {
        RECEIVE_PACKET_FIELD_ERROR(nation_id);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_citizens";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->nationalities_count > MAX_CITY_NATIONALITIES) {
      RECEIVE_PACKET_FIELD_ERROR(nation_citizens, ": truncation array");
    }
    for (i = 0; i < real_packet->nationalities_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nation_citizens[i])) {
        RECEIVE_PACKET_FIELD_ERROR(nation_citizens);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_city_nationalities_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_nationalities_100, cmp_packet_city_nationalities_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'nationalities_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nationalities_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nationalities_count)) {
      RECEIVE_PACKET_FIELD_ERROR(nationalities_count);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'nation_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation_id";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->nationalities_count > MAX_CITY_NATIONALITIES) {
        RECEIVE_PACKET_FIELD_ERROR(nation_id, ": truncation array");
      }
      for (i = 0; i < real_packet->nationalities_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nation_id[i])) {
          RECEIVE_PACKET_FIELD_ERROR(nation_id);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'nation_citizens'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation_citizens";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->nationalities_count > MAX_CITY_NATIONALITIES) {
        RECEIVE_PACKET_FIELD_ERROR(nation_citizens, ": truncation array");
      }
      for (i = 0; i < real_packet->nationalities_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nation_citizens[i])) {
          RECEIVE_PACKET_FIELD_ERROR(nation_citizens);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_nationalities_100(struct connection *pc, const struct packet_city_nationalities *packet, bool force_to_send)
{
  const struct packet_city_nationalities *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_nationalities_100_fields fields;
  struct packet_city_nationalities *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_NATIONALITIES;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_NATIONALITIES);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_nationalities_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_nationalities_100, cmp_packet_city_nationalities_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->nationalities_count != real_packet->nationalities_count);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }


    {
      differ = (old->nationalities_count != real_packet->nationalities_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->nationalities_count; i++) {
          if (old->nation_id[i] != real_packet->nation_id[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }


    {
      differ = (old->nationalities_count != real_packet->nationalities_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->nationalities_count; i++) {
          if (old->nation_citizens[i] != real_packet->nation_citizens[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'nationalities_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationalities_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nationalities_count);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'nation_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_id";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nationalities_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nationalities_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->nation_id[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'nation_citizens' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_citizens";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nationalities_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nationalities_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->nation_citizens[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationalities_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nationalities_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_id";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nationalities_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nationalities_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->nation_id[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_citizens";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nationalities_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nationalities_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->nation_citizens[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_CITY_NATIONALITIES);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_city_nationalities_101(const void *vkey)
{
  const struct packet_city_nationalities *key = (const struct packet_city_nationalities *) vkey;

  return key->id16;
}

static bool cmp_packet_city_nationalities_101(const void *vkey1, const void *vkey2)
{
  const struct packet_city_nationalities *key1 = (const struct packet_city_nationalities *) vkey1;
  const struct packet_city_nationalities *key2 = (const struct packet_city_nationalities *) vkey2;

  return key1->id16 == key2->id16;
}
BV_DEFINE(packet_city_nationalities_101_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_nationalities *receive_packet_city_nationalities_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_nationalities_101_fields fields;
  struct packet_city_nationalities *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_NATIONALITIES;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_nationalities, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationalities_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nationalities_count)) {
    RECEIVE_PACKET_FIELD_ERROR(nationalities_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_id";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->nationalities_count > MAX_CITY_NATIONALITIES) {
      RECEIVE_PACKET_FIELD_ERROR(nation_id, ": truncation array");
    }
    for (i = 0; i < real_packet->nationalities_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nation_id[i])) {
        RECEIVE_PACKET_FIELD_ERROR(nation_id);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_citizens";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->nationalities_count > MAX_CITY_NATIONALITIES) {
      RECEIVE_PACKET_FIELD_ERROR(nation_citizens, ": truncation array");
    }
    for (i = 0; i < real_packet->nationalities_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nation_citizens[i])) {
        RECEIVE_PACKET_FIELD_ERROR(nation_citizens);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_city_nationalities_101: got info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_nationalities_101, cmp_packet_city_nationalities_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id16 = real_packet->id16;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id16 = id16;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'nationalities_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nationalities_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nationalities_count)) {
      RECEIVE_PACKET_FIELD_ERROR(nationalities_count);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'nation_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation_id";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->nationalities_count > MAX_CITY_NATIONALITIES) {
        RECEIVE_PACKET_FIELD_ERROR(nation_id, ": truncation array");
      }
      for (i = 0; i < real_packet->nationalities_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nation_id[i])) {
          RECEIVE_PACKET_FIELD_ERROR(nation_id);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'nation_citizens'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation_citizens";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->nationalities_count > MAX_CITY_NATIONALITIES) {
        RECEIVE_PACKET_FIELD_ERROR(nation_citizens, ": truncation array");
      }
      for (i = 0; i < real_packet->nationalities_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nation_citizens[i])) {
          RECEIVE_PACKET_FIELD_ERROR(nation_citizens);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_nationalities_101(struct connection *pc, const struct packet_city_nationalities *packet, bool force_to_send)
{
  const struct packet_city_nationalities *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_nationalities_101_fields fields;
  struct packet_city_nationalities *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_NATIONALITIES;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_NATIONALITIES);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_nationalities_101: sending info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_nationalities_101, cmp_packet_city_nationalities_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->nationalities_count != real_packet->nationalities_count);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }


    {
      differ = (old->nationalities_count != real_packet->nationalities_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->nationalities_count; i++) {
          if (old->nation_id[i] != real_packet->nation_id[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }


    {
      differ = (old->nationalities_count != real_packet->nationalities_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->nationalities_count; i++) {
          if (old->nation_citizens[i] != real_packet->nation_citizens[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'nationalities_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationalities_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nationalities_count);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'nation_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_id";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nationalities_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nationalities_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->nation_id[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'nation_citizens' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_citizens";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nationalities_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nationalities_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->nation_citizens[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationalities_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nationalities_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_id";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nationalities_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nationalities_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->nation_id[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_citizens";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nationalities_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nationalities_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->nation_citizens[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_CITY_NATIONALITIES);
}

int send_packet_city_nationalities(struct connection *pc, const struct packet_city_nationalities *packet, bool force_to_send)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_NATIONALITIES].force_to_send != NULL, -1,
                        "Handler for PACKET_CITY_NATIONALITIES not installed");
  return pc->phs.handlers->send[PACKET_CITY_NATIONALITIES].force_to_send(pc, packet, force_to_send);
}

void lsend_packet_city_nationalities(struct conn_list *dest, const struct packet_city_nationalities *packet, bool force_to_send)
{
  conn_list_iterate(dest, pconn) {
    send_packet_city_nationalities(pconn, packet, force_to_send);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_short_info_100 hash_const

#define cmp_packet_city_short_info_100 cmp_const

BV_DEFINE(packet_city_short_info_100_fields, 13);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_short_info *receive_packet_city_short_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_short_info_100_fields fields;
  struct packet_city_short_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_short_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
    RECEIVE_PACKET_FIELD_ERROR(style);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(capital);
    }
    real_packet->capital = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->occupied)) {
    RECEIVE_PACKET_FIELD_ERROR(occupied);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
    RECEIVE_PACKET_FIELD_ERROR(walls);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->happy)) {
    RECEIVE_PACKET_FIELD_ERROR(happy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->unhappy)) {
    RECEIVE_PACKET_FIELD_ERROR(unhappy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
    RECEIVE_PACKET_FIELD_ERROR(city_image);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
    RECEIVE_PACKET_FIELD_ERROR(improvements);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_short_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_short_info_100, cmp_packet_city_short_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
      RECEIVE_PACKET_FIELD_ERROR(style);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'capital'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "capital";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(capital);
      }
      real_packet->capital = readin;
    }
  }
  real_packet->occupied = BV_ISSET(fields, 6);
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'walls'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "walls";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
      RECEIVE_PACKET_FIELD_ERROR(walls);
    }
  }
  real_packet->happy = BV_ISSET(fields, 8);
  real_packet->unhappy = BV_ISSET(fields, 9);
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'city_image'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_image";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
      RECEIVE_PACKET_FIELD_ERROR(city_image);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'improvements'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "improvements";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
      RECEIVE_PACKET_FIELD_ERROR(improvements);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_WEB_CITY_INFO_ADDITION;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_NATIONALITIES;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_RALLY_POINT;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_short_info_100(struct connection *pc, const struct packet_city_short_info *packet)
{
  const struct packet_city_short_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_short_info_100_fields fields;
  struct packet_city_short_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_SHORT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_short_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_short_info_100, cmp_packet_city_short_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->style != real_packet->style);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->capital != real_packet->capital);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->occupied != real_packet->occupied);
  if (differ) {
    different++;
  }
  if (packet->occupied) {
    BV_SET(fields, 6);
  }

  differ = (old->walls != real_packet->walls);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }

  differ = (old->happy != real_packet->happy);
  if (differ) {
    different++;
  }
  if (packet->happy) {
    BV_SET(fields, 8);
  }

  differ = (old->unhappy != real_packet->unhappy);
  if (differ) {
    different++;
  }
  if (packet->unhappy) {
    BV_SET(fields, 9);
  }

  differ = (old->city_image != real_packet->city_image);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = !BV_ARE_EQUAL(old->improvements, real_packet->improvements);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'capital' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
  }
  /* field 6 is folded into the header */
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'walls' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
  }
  /* field 8 is folded into the header */
  /* field 9 is folded into the header */
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'city_image' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'improvements' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_WEB_CITY_INFO_ADDITION;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_NATIONALITIES;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_RALLY_POINT;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->occupied);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->happy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->unhappy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_SHORT_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_city_short_info_101(const void *vkey)
{
  const struct packet_city_short_info *key = (const struct packet_city_short_info *) vkey;

  return key->id16;
}

static bool cmp_packet_city_short_info_101(const void *vkey1, const void *vkey2)
{
  const struct packet_city_short_info *key1 = (const struct packet_city_short_info *) vkey1;
  const struct packet_city_short_info *key2 = (const struct packet_city_short_info *) vkey2;

  return key1->id16 == key2->id16;
}
BV_DEFINE(packet_city_short_info_101_fields, 12);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_short_info *receive_packet_city_short_info_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_short_info_101_fields fields;
  struct packet_city_short_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_short_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
    RECEIVE_PACKET_FIELD_ERROR(style);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(capital);
    }
    real_packet->capital = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->occupied)) {
    RECEIVE_PACKET_FIELD_ERROR(occupied);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
    RECEIVE_PACKET_FIELD_ERROR(walls);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->happy)) {
    RECEIVE_PACKET_FIELD_ERROR(happy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->unhappy)) {
    RECEIVE_PACKET_FIELD_ERROR(unhappy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
    RECEIVE_PACKET_FIELD_ERROR(city_image);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
    RECEIVE_PACKET_FIELD_ERROR(improvements);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_short_info_101: got info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_short_info_101, cmp_packet_city_short_info_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id16 = real_packet->id16;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id16 = id16;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
      RECEIVE_PACKET_FIELD_ERROR(style);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'capital'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "capital";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(capital);
      }
      real_packet->capital = readin;
    }
  }
  real_packet->occupied = BV_ISSET(fields, 5);
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'walls'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "walls";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->walls)) {
      RECEIVE_PACKET_FIELD_ERROR(walls);
    }
  }
  real_packet->happy = BV_ISSET(fields, 7);
  real_packet->unhappy = BV_ISSET(fields, 8);
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'city_image'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_image";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->city_image)) {
      RECEIVE_PACKET_FIELD_ERROR(city_image);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'improvements'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "improvements";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
      RECEIVE_PACKET_FIELD_ERROR(improvements);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_WEB_CITY_INFO_ADDITION;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_NATIONALITIES;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_CITY_RALLY_POINT;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_short_info_101(struct connection *pc, const struct packet_city_short_info *packet)
{
  const struct packet_city_short_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_short_info_101_fields fields;
  struct packet_city_short_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_SHORT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_short_info_101: sending info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_short_info_101, cmp_packet_city_short_info_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->style != real_packet->style);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->capital != real_packet->capital);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->occupied != real_packet->occupied);
  if (differ) {
    different++;
  }
  if (packet->occupied) {
    BV_SET(fields, 5);
  }

  differ = (old->walls != real_packet->walls);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (old->happy != real_packet->happy);
  if (differ) {
    different++;
  }
  if (packet->happy) {
    BV_SET(fields, 7);
  }

  differ = (old->unhappy != real_packet->unhappy);
  if (differ) {
    different++;
  }
  if (packet->unhappy) {
    BV_SET(fields, 8);
  }

  differ = (old->city_image != real_packet->city_image);
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }

  differ = !BV_ARE_EQUAL(old->improvements, real_packet->improvements);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'capital' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
  }
  /* field 5 is folded into the header */
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'walls' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
  }
  /* field 7 is folded into the header */
  /* field 8 is folded into the header */
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'city_image' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'improvements' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_WEB_CITY_INFO_ADDITION;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_NATIONALITIES;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_CITY_RALLY_POINT;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capital";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->capital);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->occupied);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "walls";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->walls);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->happy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unhappy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->unhappy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_image";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->city_image);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_SHORT_INFO);
}

int send_packet_city_short_info(struct connection *pc, const struct packet_city_short_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_SHORT_INFO].packet != NULL, -1,
                        "Handler for PACKET_CITY_SHORT_INFO not installed");
  return pc->phs.handlers->send[PACKET_CITY_SHORT_INFO].packet(pc, packet);
}

void lsend_packet_city_short_info(struct conn_list *dest, const struct packet_city_short_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_city_short_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_trade_route_info_100 hash_const

#define cmp_packet_trade_route_info_100 cmp_const

BV_DEFINE(packet_trade_route_info_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_trade_route_info *receive_packet_trade_route_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_trade_route_info_100_fields fields;
  struct packet_trade_route_info *old;
  struct genhash **hash = pc->phs.received + PACKET_TRADE_ROUTE_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_trade_route_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city32)) {
    RECEIVE_PACKET_FIELD_ERROR(city32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "index";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->index)) {
    RECEIVE_PACKET_FIELD_ERROR(index);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "partner32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->partner32)) {
    RECEIVE_PACKET_FIELD_ERROR(partner32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "direction";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(direction);
    }
    real_packet->direction = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goods";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(goods);
    }
    real_packet->goods = readin;
  }

#endif
  log_packet_detailed("packet_trade_route_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_trade_route_info_100, cmp_packet_trade_route_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city32)) {
      RECEIVE_PACKET_FIELD_ERROR(city32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'index'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "index";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->index)) {
      RECEIVE_PACKET_FIELD_ERROR(index);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'partner32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "partner32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->partner32)) {
      RECEIVE_PACKET_FIELD_ERROR(partner32);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'direction'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "direction";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(direction);
      }
      real_packet->direction = readin;
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'goods'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "goods";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(goods);
      }
      real_packet->goods = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_trade_route_info_100(struct connection *pc, const struct packet_trade_route_info *packet)
{
  const struct packet_trade_route_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_trade_route_info_100_fields fields;
  struct packet_trade_route_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_TRADE_ROUTE_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_TRADE_ROUTE_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_trade_route_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_trade_route_info_100, cmp_packet_trade_route_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city32 != real_packet->city32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->index != real_packet->index);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->partner32 != real_packet->partner32);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->direction != real_packet->direction);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->goods != real_packet->goods);
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'index' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "index";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->index);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'partner32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "partner32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->partner32);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->value);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'direction' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "direction";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->direction);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'goods' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goods";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->goods);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "index";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->index);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "partner32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->partner32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "direction";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->direction);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goods";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->goods);

#endif
  SEND_PACKET_END(PACKET_TRADE_ROUTE_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_trade_route_info_101 hash_const

#define cmp_packet_trade_route_info_101 cmp_const

BV_DEFINE(packet_trade_route_info_101_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_trade_route_info *receive_packet_trade_route_info_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_trade_route_info_101_fields fields;
  struct packet_trade_route_info *old;
  struct genhash **hash = pc->phs.received + PACKET_TRADE_ROUTE_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_trade_route_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city16)) {
    RECEIVE_PACKET_FIELD_ERROR(city16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "index";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->index)) {
    RECEIVE_PACKET_FIELD_ERROR(index);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "partner16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->partner16)) {
    RECEIVE_PACKET_FIELD_ERROR(partner16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "direction";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(direction);
    }
    real_packet->direction = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goods";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(goods);
    }
    real_packet->goods = readin;
  }

#endif
  log_packet_detailed("packet_trade_route_info_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_trade_route_info_101, cmp_packet_trade_route_info_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city16)) {
      RECEIVE_PACKET_FIELD_ERROR(city16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'index'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "index";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->index)) {
      RECEIVE_PACKET_FIELD_ERROR(index);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'partner16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "partner16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->partner16)) {
      RECEIVE_PACKET_FIELD_ERROR(partner16);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'direction'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "direction";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(direction);
      }
      real_packet->direction = readin;
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'goods'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "goods";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(goods);
      }
      real_packet->goods = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_trade_route_info_101(struct connection *pc, const struct packet_trade_route_info *packet)
{
  const struct packet_trade_route_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_trade_route_info_101_fields fields;
  struct packet_trade_route_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_TRADE_ROUTE_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_TRADE_ROUTE_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_trade_route_info_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_trade_route_info_101, cmp_packet_trade_route_info_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city16 != real_packet->city16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->index != real_packet->index);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->partner16 != real_packet->partner16);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->direction != real_packet->direction);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->goods != real_packet->goods);
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'index' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "index";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->index);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'partner16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "partner16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->partner16);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->value);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'direction' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "direction";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->direction);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'goods' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goods";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->goods);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "index";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->index);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "partner16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->partner16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "direction";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->direction);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goods";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->goods);

#endif
  SEND_PACKET_END(PACKET_TRADE_ROUTE_INFO);
}

int send_packet_trade_route_info(struct connection *pc, const struct packet_trade_route_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_TRADE_ROUTE_INFO].packet != NULL, -1,
                        "Handler for PACKET_TRADE_ROUTE_INFO not installed");
  return pc->phs.handlers->send[PACKET_TRADE_ROUTE_INFO].packet(pc, packet);
}

void lsend_packet_trade_route_info(struct conn_list *dest, const struct packet_trade_route_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_trade_route_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_sell_100 hash_const

#define cmp_packet_city_sell_100 cmp_const

BV_DEFINE(packet_city_sell_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_sell *receive_packet_city_sell_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_sell_100_fields fields;
  struct packet_city_sell *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_SELL;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_sell, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_id)) {
    RECEIVE_PACKET_FIELD_ERROR(build_id);
  }

#endif
  log_packet_detailed("packet_city_sell_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_sell_100, cmp_packet_city_sell_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'build_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "build_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_id)) {
      RECEIVE_PACKET_FIELD_ERROR(build_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_sell_100(struct connection *pc, const struct packet_city_sell *packet)
{
  const struct packet_city_sell *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_sell_100_fields fields;
  struct packet_city_sell *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_SELL;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_SELL);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_sell_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_sell_100, cmp_packet_city_sell_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->build_id != real_packet->build_id);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'build_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_id);

#endif
  SEND_PACKET_END(PACKET_CITY_SELL);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_sell_101 hash_const

#define cmp_packet_city_sell_101 cmp_const

BV_DEFINE(packet_city_sell_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_sell *receive_packet_city_sell_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_sell_101_fields fields;
  struct packet_city_sell *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_SELL;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_sell, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_id)) {
    RECEIVE_PACKET_FIELD_ERROR(build_id);
  }

#endif
  log_packet_detailed("packet_city_sell_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_sell_101, cmp_packet_city_sell_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'build_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "build_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_id)) {
      RECEIVE_PACKET_FIELD_ERROR(build_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_sell_101(struct connection *pc, const struct packet_city_sell *packet)
{
  const struct packet_city_sell *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_sell_101_fields fields;
  struct packet_city_sell *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_SELL;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_SELL);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_sell_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_sell_101, cmp_packet_city_sell_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->build_id != real_packet->build_id);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'build_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_id);

#endif
  SEND_PACKET_END(PACKET_CITY_SELL);
}

int send_packet_city_sell(struct connection *pc, const struct packet_city_sell *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_SELL].packet != NULL, -1,
                        "Handler for PACKET_CITY_SELL not installed");
  return pc->phs.handlers->send[PACKET_CITY_SELL].packet(pc, packet);
}

int dsend_packet_city_sell(struct connection *pc, int city_id16, int city_id32, int build_id)
{
  struct packet_city_sell packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  real_packet->build_id = build_id;
  
  return send_packet_city_sell(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_buy_100 hash_const

#define cmp_packet_city_buy_100 cmp_const

BV_DEFINE(packet_city_buy_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_buy *receive_packet_city_buy_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_buy_100_fields fields;
  struct packet_city_buy *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_BUY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_buy, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }

#endif
  log_packet_detailed("packet_city_buy_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_buy_100, cmp_packet_city_buy_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_buy_100(struct connection *pc, const struct packet_city_buy *packet)
{
  const struct packet_city_buy *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_buy_100_fields fields;
  struct packet_city_buy *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_BUY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_BUY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_buy_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_buy_100, cmp_packet_city_buy_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);

#endif
  SEND_PACKET_END(PACKET_CITY_BUY);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_buy_101 hash_const

#define cmp_packet_city_buy_101 cmp_const

BV_DEFINE(packet_city_buy_101_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_buy *receive_packet_city_buy_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_buy_101_fields fields;
  struct packet_city_buy *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_BUY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_buy, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }

#endif
  log_packet_detailed("packet_city_buy_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_buy_101, cmp_packet_city_buy_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_buy_101(struct connection *pc, const struct packet_city_buy *packet)
{
  const struct packet_city_buy *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_buy_101_fields fields;
  struct packet_city_buy *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_BUY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_BUY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_buy_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_buy_101, cmp_packet_city_buy_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);

#endif
  SEND_PACKET_END(PACKET_CITY_BUY);
}

int send_packet_city_buy(struct connection *pc, const struct packet_city_buy *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_BUY].packet != NULL, -1,
                        "Handler for PACKET_CITY_BUY not installed");
  return pc->phs.handlers->send[PACKET_CITY_BUY].packet(pc, packet);
}

int dsend_packet_city_buy(struct connection *pc, int city_id16, int city_id32)
{
  struct packet_city_buy packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  
  return send_packet_city_buy(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_change_100 hash_const

#define cmp_packet_city_change_100 cmp_const

BV_DEFINE(packet_city_change_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_change *receive_packet_city_change_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_change_100_fields fields;
  struct packet_city_change *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_CHANGE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_change, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(production_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
    RECEIVE_PACKET_FIELD_ERROR(production_value);
  }

#endif
  log_packet_detailed("packet_city_change_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_change_100, cmp_packet_city_change_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'production_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(production_kind);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'production_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
      RECEIVE_PACKET_FIELD_ERROR(production_value);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_change_100(struct connection *pc, const struct packet_city_change *packet)
{
  const struct packet_city_change *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_change_100_fields fields;
  struct packet_city_change *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_CHANGE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_CHANGE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_change_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_change_100, cmp_packet_city_change_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->production_kind != real_packet->production_kind);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->production_value != real_packet->production_value);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'production_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'production_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);

#endif
  SEND_PACKET_END(PACKET_CITY_CHANGE);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_change_101 hash_const

#define cmp_packet_city_change_101 cmp_const

BV_DEFINE(packet_city_change_101_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_change *receive_packet_city_change_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_change_101_fields fields;
  struct packet_city_change *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_CHANGE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_change, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(production_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
    RECEIVE_PACKET_FIELD_ERROR(production_value);
  }

#endif
  log_packet_detailed("packet_city_change_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_change_101, cmp_packet_city_change_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'production_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(production_kind);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'production_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
      RECEIVE_PACKET_FIELD_ERROR(production_value);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_change_101(struct connection *pc, const struct packet_city_change *packet)
{
  const struct packet_city_change *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_change_101_fields fields;
  struct packet_city_change *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_CHANGE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_CHANGE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_change_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_change_101, cmp_packet_city_change_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->production_kind != real_packet->production_kind);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->production_value != real_packet->production_value);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'production_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'production_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);

#endif
  SEND_PACKET_END(PACKET_CITY_CHANGE);
}

int send_packet_city_change(struct connection *pc, const struct packet_city_change *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_CHANGE].packet != NULL, -1,
                        "Handler for PACKET_CITY_CHANGE not installed");
  return pc->phs.handlers->send[PACKET_CITY_CHANGE].packet(pc, packet);
}

int dsend_packet_city_change(struct connection *pc, int city_id16, int city_id32, int production_kind, int production_value)
{
  struct packet_city_change packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  real_packet->production_kind = production_kind;
  real_packet->production_value = production_value;
  
  return send_packet_city_change(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_worklist_100 hash_const

#define cmp_packet_city_worklist_100 cmp_const

BV_DEFINE(packet_city_worklist_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_worklist *receive_packet_city_worklist_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_worklist_100_fields fields;
  struct packet_city_worklist *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_WORKLIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_worklist, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
    RECEIVE_PACKET_FIELD_ERROR(worklist);
  }

#endif
  log_packet_detailed("packet_city_worklist_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_worklist_100, cmp_packet_city_worklist_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'worklist'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "worklist";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
      RECEIVE_PACKET_FIELD_ERROR(worklist);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_worklist_100(struct connection *pc, const struct packet_city_worklist *packet)
{
  const struct packet_city_worklist *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_worklist_100_fields fields;
  struct packet_city_worklist *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_WORKLIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_WORKLIST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_worklist_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_worklist_100, cmp_packet_city_worklist_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = !are_worklists_equal(&old->worklist, &real_packet->worklist);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'worklist' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);

#endif
  SEND_PACKET_END(PACKET_CITY_WORKLIST);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_worklist_101 hash_const

#define cmp_packet_city_worklist_101 cmp_const

BV_DEFINE(packet_city_worklist_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_worklist *receive_packet_city_worklist_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_worklist_101_fields fields;
  struct packet_city_worklist *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_WORKLIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_worklist, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
    RECEIVE_PACKET_FIELD_ERROR(worklist);
  }

#endif
  log_packet_detailed("packet_city_worklist_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_worklist_101, cmp_packet_city_worklist_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'worklist'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "worklist";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(worklist, &din, &field_addr, &real_packet->worklist)) {
      RECEIVE_PACKET_FIELD_ERROR(worklist);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_worklist_101(struct connection *pc, const struct packet_city_worklist *packet)
{
  const struct packet_city_worklist *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_worklist_101_fields fields;
  struct packet_city_worklist *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_WORKLIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_WORKLIST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_worklist_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_worklist_101, cmp_packet_city_worklist_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = !are_worklists_equal(&old->worklist, &real_packet->worklist);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'worklist' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worklist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(worklist, &dout, &field_addr, &real_packet->worklist);

#endif
  SEND_PACKET_END(PACKET_CITY_WORKLIST);
}

int send_packet_city_worklist(struct connection *pc, const struct packet_city_worklist *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_WORKLIST].packet != NULL, -1,
                        "Handler for PACKET_CITY_WORKLIST not installed");
  return pc->phs.handlers->send[PACKET_CITY_WORKLIST].packet(pc, packet);
}

int dsend_packet_city_worklist(struct connection *pc, int city_id16, int city_id32, const struct worklist *worklist)
{
  struct packet_city_worklist packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  worklist_copy(&real_packet->worklist, worklist);
  
  return send_packet_city_worklist(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_make_specialist_100 hash_const

#define cmp_packet_city_make_specialist_100 cmp_const

BV_DEFINE(packet_city_make_specialist_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_make_specialist *receive_packet_city_make_specialist_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_make_specialist_100_fields fields;
  struct packet_city_make_specialist *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_MAKE_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_make_specialist, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(tile_id);
  }

#endif
  log_packet_detailed("packet_city_make_specialist_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_make_specialist_100, cmp_packet_city_make_specialist_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(tile_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_make_specialist_100(struct connection *pc, const struct packet_city_make_specialist *packet)
{
  const struct packet_city_make_specialist *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_make_specialist_100_fields fields;
  struct packet_city_make_specialist *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_MAKE_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_MAKE_SPECIALIST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_make_specialist_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_make_specialist_100, cmp_packet_city_make_specialist_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile_id != real_packet->tile_id);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);

#endif
  SEND_PACKET_END(PACKET_CITY_MAKE_SPECIALIST);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_make_specialist_101 hash_const

#define cmp_packet_city_make_specialist_101 cmp_const

BV_DEFINE(packet_city_make_specialist_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_make_specialist *receive_packet_city_make_specialist_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_make_specialist_101_fields fields;
  struct packet_city_make_specialist *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_MAKE_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_make_specialist, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(tile_id);
  }

#endif
  log_packet_detailed("packet_city_make_specialist_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_make_specialist_101, cmp_packet_city_make_specialist_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(tile_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_make_specialist_101(struct connection *pc, const struct packet_city_make_specialist *packet)
{
  const struct packet_city_make_specialist *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_make_specialist_101_fields fields;
  struct packet_city_make_specialist *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_MAKE_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_MAKE_SPECIALIST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_make_specialist_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_make_specialist_101, cmp_packet_city_make_specialist_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile_id != real_packet->tile_id);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);

#endif
  SEND_PACKET_END(PACKET_CITY_MAKE_SPECIALIST);
}

int send_packet_city_make_specialist(struct connection *pc, const struct packet_city_make_specialist *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_MAKE_SPECIALIST].packet != NULL, -1,
                        "Handler for PACKET_CITY_MAKE_SPECIALIST not installed");
  return pc->phs.handlers->send[PACKET_CITY_MAKE_SPECIALIST].packet(pc, packet);
}

int dsend_packet_city_make_specialist(struct connection *pc, int city_id16, int city_id32, int tile_id)
{
  struct packet_city_make_specialist packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  real_packet->tile_id = tile_id;
  
  return send_packet_city_make_specialist(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_make_worker_100 hash_const

#define cmp_packet_city_make_worker_100 cmp_const

BV_DEFINE(packet_city_make_worker_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_make_worker *receive_packet_city_make_worker_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_make_worker_100_fields fields;
  struct packet_city_make_worker *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_MAKE_WORKER;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_make_worker, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(tile_id);
  }

#endif
  log_packet_detailed("packet_city_make_worker_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_make_worker_100, cmp_packet_city_make_worker_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(tile_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_make_worker_100(struct connection *pc, const struct packet_city_make_worker *packet)
{
  const struct packet_city_make_worker *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_make_worker_100_fields fields;
  struct packet_city_make_worker *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_MAKE_WORKER;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_MAKE_WORKER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_make_worker_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_make_worker_100, cmp_packet_city_make_worker_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile_id != real_packet->tile_id);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);

#endif
  SEND_PACKET_END(PACKET_CITY_MAKE_WORKER);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_make_worker_101 hash_const

#define cmp_packet_city_make_worker_101 cmp_const

BV_DEFINE(packet_city_make_worker_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_make_worker *receive_packet_city_make_worker_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_make_worker_101_fields fields;
  struct packet_city_make_worker *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_MAKE_WORKER;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_make_worker, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(tile_id);
  }

#endif
  log_packet_detailed("packet_city_make_worker_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_make_worker_101, cmp_packet_city_make_worker_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(tile_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_make_worker_101(struct connection *pc, const struct packet_city_make_worker *packet)
{
  const struct packet_city_make_worker *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_make_worker_101_fields fields;
  struct packet_city_make_worker *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_MAKE_WORKER;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_MAKE_WORKER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_make_worker_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_make_worker_101, cmp_packet_city_make_worker_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile_id != real_packet->tile_id);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);

#endif
  SEND_PACKET_END(PACKET_CITY_MAKE_WORKER);
}

int send_packet_city_make_worker(struct connection *pc, const struct packet_city_make_worker *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_MAKE_WORKER].packet != NULL, -1,
                        "Handler for PACKET_CITY_MAKE_WORKER not installed");
  return pc->phs.handlers->send[PACKET_CITY_MAKE_WORKER].packet(pc, packet);
}

int dsend_packet_city_make_worker(struct connection *pc, int city_id16, int city_id32, int tile_id)
{
  struct packet_city_make_worker packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  real_packet->tile_id = tile_id;
  
  return send_packet_city_make_worker(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_change_specialist_100 hash_const

#define cmp_packet_city_change_specialist_100 cmp_const

BV_DEFINE(packet_city_change_specialist_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_change_specialist *receive_packet_city_change_specialist_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_change_specialist_100_fields fields;
  struct packet_city_change_specialist *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_CHANGE_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_change_specialist, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "from";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(from);
    }
    real_packet->from = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "to";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(to);
    }
    real_packet->to = readin;
  }

#endif
  log_packet_detailed("packet_city_change_specialist_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_change_specialist_100, cmp_packet_city_change_specialist_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'from'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "from";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(from);
      }
      real_packet->from = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'to'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "to";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(to);
      }
      real_packet->to = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_change_specialist_100(struct connection *pc, const struct packet_city_change_specialist *packet)
{
  const struct packet_city_change_specialist *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_change_specialist_100_fields fields;
  struct packet_city_change_specialist *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_CHANGE_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_CHANGE_SPECIALIST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_change_specialist_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_change_specialist_100, cmp_packet_city_change_specialist_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->from != real_packet->from);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->to != real_packet->to);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'from' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->from);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'to' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "to";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->to);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->from);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "to";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->to);

#endif
  SEND_PACKET_END(PACKET_CITY_CHANGE_SPECIALIST);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_change_specialist_101 hash_const

#define cmp_packet_city_change_specialist_101 cmp_const

BV_DEFINE(packet_city_change_specialist_101_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_change_specialist *receive_packet_city_change_specialist_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_change_specialist_101_fields fields;
  struct packet_city_change_specialist *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_CHANGE_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_change_specialist, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "from";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(from);
    }
    real_packet->from = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "to";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(to);
    }
    real_packet->to = readin;
  }

#endif
  log_packet_detailed("packet_city_change_specialist_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_change_specialist_101, cmp_packet_city_change_specialist_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'from'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "from";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(from);
      }
      real_packet->from = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'to'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "to";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(to);
      }
      real_packet->to = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_change_specialist_101(struct connection *pc, const struct packet_city_change_specialist *packet)
{
  const struct packet_city_change_specialist *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_change_specialist_101_fields fields;
  struct packet_city_change_specialist *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_CHANGE_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_CHANGE_SPECIALIST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_change_specialist_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_change_specialist_101, cmp_packet_city_change_specialist_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->from != real_packet->from);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->to != real_packet->to);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'from' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->from);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'to' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "to";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->to);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->from);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "to";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->to);

#endif
  SEND_PACKET_END(PACKET_CITY_CHANGE_SPECIALIST);
}

int send_packet_city_change_specialist(struct connection *pc, const struct packet_city_change_specialist *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_CHANGE_SPECIALIST].packet != NULL, -1,
                        "Handler for PACKET_CITY_CHANGE_SPECIALIST not installed");
  return pc->phs.handlers->send[PACKET_CITY_CHANGE_SPECIALIST].packet(pc, packet);
}

int dsend_packet_city_change_specialist(struct connection *pc, int city_id16, int city_id32, Specialist_type_id from, Specialist_type_id to)
{
  struct packet_city_change_specialist packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  real_packet->from = from;
  real_packet->to = to;
  
  return send_packet_city_change_specialist(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_rename_100 hash_const

#define cmp_packet_city_rename_100 cmp_const

BV_DEFINE(packet_city_rename_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_rename *receive_packet_city_rename_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_rename_100_fields fields;
  struct packet_city_rename *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_RENAME;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_rename, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_rename_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_rename_100, cmp_packet_city_rename_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_rename_100(struct connection *pc, const struct packet_city_rename *packet)
{
  const struct packet_city_rename *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_rename_100_fields fields;
  struct packet_city_rename *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_RENAME;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_RENAME);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_rename_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_rename_100, cmp_packet_city_rename_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_RENAME);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_rename_101 hash_const

#define cmp_packet_city_rename_101 cmp_const

BV_DEFINE(packet_city_rename_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_rename *receive_packet_city_rename_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_rename_101_fields fields;
  struct packet_city_rename *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_RENAME;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_rename, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_rename_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_rename_101, cmp_packet_city_rename_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_rename_101(struct connection *pc, const struct packet_city_rename *packet)
{
  const struct packet_city_rename *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_rename_101_fields fields;
  struct packet_city_rename *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_RENAME;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_RENAME);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_rename_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_rename_101, cmp_packet_city_rename_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_RENAME);
}

int send_packet_city_rename(struct connection *pc, const struct packet_city_rename *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_RENAME].packet != NULL, -1,
                        "Handler for PACKET_CITY_RENAME not installed");
  return pc->phs.handlers->send[PACKET_CITY_RENAME].packet(pc, packet);
}

int dsend_packet_city_rename(struct connection *pc, int city_id16, int city_id32, const char *name)
{
  struct packet_city_rename packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  sz_strlcpy(real_packet->name, name);
  
  return send_packet_city_rename(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_options_req_100 hash_const

#define cmp_packet_city_options_req_100 cmp_const

BV_DEFINE(packet_city_options_req_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_options_req *receive_packet_city_options_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_options_req_100_fields fields;
  struct packet_city_options_req *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_OPTIONS_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_options_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "options";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->options)) {
    RECEIVE_PACKET_FIELD_ERROR(options);
  }

#endif
  log_packet_detailed("packet_city_options_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_options_req_100, cmp_packet_city_options_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'options'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "options";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->options)) {
      RECEIVE_PACKET_FIELD_ERROR(options);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_options_req_100(struct connection *pc, const struct packet_city_options_req *packet)
{
  const struct packet_city_options_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_options_req_100_fields fields;
  struct packet_city_options_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_OPTIONS_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_OPTIONS_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_options_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_options_req_100, cmp_packet_city_options_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = !BV_ARE_EQUAL(old->options, real_packet->options);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'options' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->options);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->options);

#endif
  SEND_PACKET_END(PACKET_CITY_OPTIONS_REQ);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_options_req_101 hash_const

#define cmp_packet_city_options_req_101 cmp_const

BV_DEFINE(packet_city_options_req_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_options_req *receive_packet_city_options_req_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_options_req_101_fields fields;
  struct packet_city_options_req *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_OPTIONS_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_options_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "options";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->options)) {
    RECEIVE_PACKET_FIELD_ERROR(options);
  }

#endif
  log_packet_detailed("packet_city_options_req_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_options_req_101, cmp_packet_city_options_req_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'options'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "options";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->options)) {
      RECEIVE_PACKET_FIELD_ERROR(options);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_options_req_101(struct connection *pc, const struct packet_city_options_req *packet)
{
  const struct packet_city_options_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_options_req_101_fields fields;
  struct packet_city_options_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_OPTIONS_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_OPTIONS_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_options_req_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_options_req_101, cmp_packet_city_options_req_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = !BV_ARE_EQUAL(old->options, real_packet->options);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'options' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->options);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->options);

#endif
  SEND_PACKET_END(PACKET_CITY_OPTIONS_REQ);
}

int send_packet_city_options_req(struct connection *pc, const struct packet_city_options_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_OPTIONS_REQ].packet != NULL, -1,
                        "Handler for PACKET_CITY_OPTIONS_REQ not installed");
  return pc->phs.handlers->send[PACKET_CITY_OPTIONS_REQ].packet(pc, packet);
}

int dsend_packet_city_options_req(struct connection *pc, int city_id16, int city_id32, bv_city_options options)
{
  struct packet_city_options_req packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  real_packet->options = options;
  
  return send_packet_city_options_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_refresh_100 hash_const

#define cmp_packet_city_refresh_100 cmp_const

BV_DEFINE(packet_city_refresh_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_refresh *receive_packet_city_refresh_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_refresh_100_fields fields;
  struct packet_city_refresh *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_REFRESH;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_refresh, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }

#endif
  log_packet_detailed("packet_city_refresh_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_refresh_100, cmp_packet_city_refresh_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_refresh_100(struct connection *pc, const struct packet_city_refresh *packet)
{
  const struct packet_city_refresh *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_refresh_100_fields fields;
  struct packet_city_refresh *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_REFRESH;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_REFRESH);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_refresh_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_refresh_100, cmp_packet_city_refresh_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);

#endif
  SEND_PACKET_END(PACKET_CITY_REFRESH);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_refresh_101 hash_const

#define cmp_packet_city_refresh_101 cmp_const

BV_DEFINE(packet_city_refresh_101_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_refresh *receive_packet_city_refresh_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_refresh_101_fields fields;
  struct packet_city_refresh *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_REFRESH;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_refresh, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }

#endif
  log_packet_detailed("packet_city_refresh_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_refresh_101, cmp_packet_city_refresh_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_refresh_101(struct connection *pc, const struct packet_city_refresh *packet)
{
  const struct packet_city_refresh *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_refresh_101_fields fields;
  struct packet_city_refresh *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_REFRESH;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_REFRESH);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_refresh_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_refresh_101, cmp_packet_city_refresh_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);

#endif
  SEND_PACKET_END(PACKET_CITY_REFRESH);
}

int send_packet_city_refresh(struct connection *pc, const struct packet_city_refresh *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_REFRESH].packet != NULL, -1,
                        "Handler for PACKET_CITY_REFRESH not installed");
  return pc->phs.handlers->send[PACKET_CITY_REFRESH].packet(pc, packet);
}

int dsend_packet_city_refresh(struct connection *pc, int city_id16, int city_id32)
{
  struct packet_city_refresh packet, *real_packet = &packet;

  real_packet->city_id16 = city_id16;
  real_packet->city_id32 = city_id32;
  
  return send_packet_city_refresh(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_name_suggestion_req_100 hash_const

#define cmp_packet_city_name_suggestion_req_100 cmp_const

BV_DEFINE(packet_city_name_suggestion_req_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_name_suggestion_req *receive_packet_city_name_suggestion_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_name_suggestion_req_100_fields fields;
  struct packet_city_name_suggestion_req *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_NAME_SUGGESTION_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_name_suggestion_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id32);
  }

#endif
  log_packet_detailed("packet_city_name_suggestion_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_name_suggestion_req_100, cmp_packet_city_name_suggestion_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_name_suggestion_req_100(struct connection *pc, const struct packet_city_name_suggestion_req *packet)
{
  const struct packet_city_name_suggestion_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_name_suggestion_req_100_fields fields;
  struct packet_city_name_suggestion_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_NAME_SUGGESTION_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_NAME_SUGGESTION_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_name_suggestion_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_name_suggestion_req_100, cmp_packet_city_name_suggestion_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id32 != real_packet->unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);

#endif
  SEND_PACKET_END(PACKET_CITY_NAME_SUGGESTION_REQ);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_name_suggestion_req_101 hash_const

#define cmp_packet_city_name_suggestion_req_101 cmp_const

BV_DEFINE(packet_city_name_suggestion_req_101_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_name_suggestion_req *receive_packet_city_name_suggestion_req_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_name_suggestion_req_101_fields fields;
  struct packet_city_name_suggestion_req *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_NAME_SUGGESTION_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_name_suggestion_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id16);
  }

#endif
  log_packet_detailed("packet_city_name_suggestion_req_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_name_suggestion_req_101, cmp_packet_city_name_suggestion_req_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_name_suggestion_req_101(struct connection *pc, const struct packet_city_name_suggestion_req *packet)
{
  const struct packet_city_name_suggestion_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_name_suggestion_req_101_fields fields;
  struct packet_city_name_suggestion_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_NAME_SUGGESTION_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_NAME_SUGGESTION_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_name_suggestion_req_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_name_suggestion_req_101, cmp_packet_city_name_suggestion_req_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id16 != real_packet->unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);

#endif
  SEND_PACKET_END(PACKET_CITY_NAME_SUGGESTION_REQ);
}

int send_packet_city_name_suggestion_req(struct connection *pc, const struct packet_city_name_suggestion_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_NAME_SUGGESTION_REQ].packet != NULL, -1,
                        "Handler for PACKET_CITY_NAME_SUGGESTION_REQ not installed");
  return pc->phs.handlers->send[PACKET_CITY_NAME_SUGGESTION_REQ].packet(pc, packet);
}

int dsend_packet_city_name_suggestion_req(struct connection *pc, int unit_id16, int unit_id32)
{
  struct packet_city_name_suggestion_req packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  
  return send_packet_city_name_suggestion_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_name_suggestion_info_100 hash_const

#define cmp_packet_city_name_suggestion_info_100 cmp_const

BV_DEFINE(packet_city_name_suggestion_info_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_name_suggestion_info *receive_packet_city_name_suggestion_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_name_suggestion_info_100_fields fields;
  struct packet_city_name_suggestion_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_NAME_SUGGESTION_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_name_suggestion_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_name_suggestion_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_name_suggestion_info_100, cmp_packet_city_name_suggestion_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_name_suggestion_info_100(struct connection *pc, const struct packet_city_name_suggestion_info *packet)
{
  const struct packet_city_name_suggestion_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_name_suggestion_info_100_fields fields;
  struct packet_city_name_suggestion_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_NAME_SUGGESTION_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_NAME_SUGGESTION_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_name_suggestion_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_name_suggestion_info_100, cmp_packet_city_name_suggestion_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id32 != real_packet->unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_NAME_SUGGESTION_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_name_suggestion_info_101 hash_const

#define cmp_packet_city_name_suggestion_info_101 cmp_const

BV_DEFINE(packet_city_name_suggestion_info_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_name_suggestion_info *receive_packet_city_name_suggestion_info_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_name_suggestion_info_101_fields fields;
  struct packet_city_name_suggestion_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_NAME_SUGGESTION_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_name_suggestion_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_city_name_suggestion_info_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_name_suggestion_info_101, cmp_packet_city_name_suggestion_info_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_name_suggestion_info_101(struct connection *pc, const struct packet_city_name_suggestion_info *packet)
{
  const struct packet_city_name_suggestion_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_name_suggestion_info_101_fields fields;
  struct packet_city_name_suggestion_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_NAME_SUGGESTION_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_NAME_SUGGESTION_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_name_suggestion_info_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_name_suggestion_info_101, cmp_packet_city_name_suggestion_info_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id16 != real_packet->unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_CITY_NAME_SUGGESTION_INFO);
}

int send_packet_city_name_suggestion_info(struct connection *pc, const struct packet_city_name_suggestion_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_NAME_SUGGESTION_INFO].packet != NULL, -1,
                        "Handler for PACKET_CITY_NAME_SUGGESTION_INFO not installed");
  return pc->phs.handlers->send[PACKET_CITY_NAME_SUGGESTION_INFO].packet(pc, packet);
}

void lsend_packet_city_name_suggestion_info(struct conn_list *dest, const struct packet_city_name_suggestion_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_city_name_suggestion_info(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_city_name_suggestion_info(struct connection *pc, int unit_id16, int unit_id32, const char *name)
{
  struct packet_city_name_suggestion_info packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  sz_strlcpy(real_packet->name, name);
  
  return send_packet_city_name_suggestion_info(pc, real_packet);
}

void dlsend_packet_city_name_suggestion_info(struct conn_list *dest, int unit_id16, int unit_id32, const char *name)
{
  struct packet_city_name_suggestion_info packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  sz_strlcpy(real_packet->name, name);
  
  lsend_packet_city_name_suggestion_info(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_sabotage_list_100 hash_const

#define cmp_packet_city_sabotage_list_100 cmp_const

BV_DEFINE(packet_city_sabotage_list_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_sabotage_list *receive_packet_city_sabotage_list_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_sabotage_list_100_fields fields;
  struct packet_city_sabotage_list *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_SABOTAGE_LIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_sabotage_list, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
    RECEIVE_PACKET_FIELD_ERROR(improvements);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(act_id);
    }
    real_packet->act_id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }

#endif
  log_packet_detailed("packet_city_sabotage_list_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_sabotage_list_100, cmp_packet_city_sabotage_list_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'improvements'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "improvements";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
      RECEIVE_PACKET_FIELD_ERROR(improvements);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'act_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "act_id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(act_id);
      }
      real_packet->act_id = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_sabotage_list_100(struct connection *pc, const struct packet_city_sabotage_list *packet)
{
  const struct packet_city_sabotage_list *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_sabotage_list_100_fields fields;
  struct packet_city_sabotage_list *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_SABOTAGE_LIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_SABOTAGE_LIST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_sabotage_list_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_sabotage_list_100, cmp_packet_city_sabotage_list_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_id32 != real_packet->actor_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = !BV_ARE_EQUAL(old->improvements, real_packet->improvements);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->act_id != real_packet->act_id);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'improvements' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'act_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->act_id);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->act_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);

#endif
  SEND_PACKET_END(PACKET_CITY_SABOTAGE_LIST);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_sabotage_list_101 hash_const

#define cmp_packet_city_sabotage_list_101 cmp_const

BV_DEFINE(packet_city_sabotage_list_101_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_sabotage_list *receive_packet_city_sabotage_list_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_sabotage_list_101_fields fields;
  struct packet_city_sabotage_list *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_SABOTAGE_LIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_sabotage_list, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
    RECEIVE_PACKET_FIELD_ERROR(improvements);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(act_id);
    }
    real_packet->act_id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }

#endif
  log_packet_detailed("packet_city_sabotage_list_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_sabotage_list_101, cmp_packet_city_sabotage_list_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'improvements'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "improvements";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->improvements)) {
      RECEIVE_PACKET_FIELD_ERROR(improvements);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'act_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "act_id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(act_id);
      }
      real_packet->act_id = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_sabotage_list_101(struct connection *pc, const struct packet_city_sabotage_list *packet)
{
  const struct packet_city_sabotage_list *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_sabotage_list_101_fields fields;
  struct packet_city_sabotage_list *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_SABOTAGE_LIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_SABOTAGE_LIST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_sabotage_list_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_sabotage_list_101, cmp_packet_city_sabotage_list_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_id16 != real_packet->actor_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = !BV_ARE_EQUAL(old->improvements, real_packet->improvements);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->act_id != real_packet->act_id);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'improvements' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'act_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->act_id);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "improvements";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->improvements);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->act_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);

#endif
  SEND_PACKET_END(PACKET_CITY_SABOTAGE_LIST);
}

int send_packet_city_sabotage_list(struct connection *pc, const struct packet_city_sabotage_list *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_SABOTAGE_LIST].packet != NULL, -1,
                        "Handler for PACKET_CITY_SABOTAGE_LIST not installed");
  return pc->phs.handlers->send[PACKET_CITY_SABOTAGE_LIST].packet(pc, packet);
}

void lsend_packet_city_sabotage_list(struct conn_list *dest, const struct packet_city_sabotage_list *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_city_sabotage_list(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_rally_point_100 hash_const

#define cmp_packet_city_rally_point_100 cmp_const

BV_DEFINE(packet_city_rally_point_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_rally_point *receive_packet_city_rally_point_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_rally_point_100_fields fields;
  struct packet_city_rally_point *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_RALLY_POINT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_rally_point, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->length)) {
    RECEIVE_PACKET_FIELD_ERROR(length);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "persistent";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->persistent)) {
    RECEIVE_PACKET_FIELD_ERROR(persistent);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vigilant";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->vigilant)) {
    RECEIVE_PACKET_FIELD_ERROR(vigilant);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->length > MAX_LEN_ROUTE) {
      RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
    }
    for (i = 0; i < real_packet->length; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
        RECEIVE_PACKET_FIELD_ERROR(orders);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_city_rally_point_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_rally_point_100, cmp_packet_city_rally_point_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'length'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "length";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->length)) {
      RECEIVE_PACKET_FIELD_ERROR(length);
    }
  }
  real_packet->persistent = BV_ISSET(fields, 2);
  real_packet->vigilant = BV_ISSET(fields, 3);
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'orders'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->length > MAX_LEN_ROUTE) {
        RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
      }
      for (i = 0; i < real_packet->length; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
          RECEIVE_PACKET_FIELD_ERROR(orders);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_rally_point_100(struct connection *pc, const struct packet_city_rally_point *packet, bool force_to_send)
{
  const struct packet_city_rally_point *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_rally_point_100_fields fields;
  struct packet_city_rally_point *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_RALLY_POINT;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_RALLY_POINT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_rally_point_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_rally_point_100, cmp_packet_city_rally_point_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->length != real_packet->length);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->persistent != real_packet->persistent);
  if (differ) {
    different++;
  }
  if (packet->persistent) {
    BV_SET(fields, 2);
  }

  differ = (old->vigilant != real_packet->vigilant);
  if (differ) {
    different++;
  }
  if (packet->vigilant) {
    BV_SET(fields, 3);
  }


    {
      differ = (old->length != real_packet->length);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->length; i++) {
          if (!are_unit_orders_equal(&old->orders[i], &real_packet->orders[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'length' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->length);
  }
  /* field 2 is folded into the header */
  /* field 3 is folded into the header */
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'orders' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->length);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "persistent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->persistent);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vigilant";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->vigilant);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_CITY_RALLY_POINT);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_city_rally_point_101 hash_const

#define cmp_packet_city_rally_point_101 cmp_const

BV_DEFINE(packet_city_rally_point_101_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_city_rally_point *receive_packet_city_rally_point_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_rally_point_101_fields fields;
  struct packet_city_rally_point *old;
  struct genhash **hash = pc->phs.received + PACKET_CITY_RALLY_POINT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_city_rally_point, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->length)) {
    RECEIVE_PACKET_FIELD_ERROR(length);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "persistent";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->persistent)) {
    RECEIVE_PACKET_FIELD_ERROR(persistent);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vigilant";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->vigilant)) {
    RECEIVE_PACKET_FIELD_ERROR(vigilant);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->length > MAX_LEN_ROUTE) {
      RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
    }
    for (i = 0; i < real_packet->length; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
        RECEIVE_PACKET_FIELD_ERROR(orders);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_city_rally_point_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_rally_point_101, cmp_packet_city_rally_point_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'length'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "length";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->length)) {
      RECEIVE_PACKET_FIELD_ERROR(length);
    }
  }
  real_packet->persistent = BV_ISSET(fields, 2);
  real_packet->vigilant = BV_ISSET(fields, 3);
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'orders'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->length > MAX_LEN_ROUTE) {
        RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
      }
      for (i = 0; i < real_packet->length; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
          RECEIVE_PACKET_FIELD_ERROR(orders);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_city_rally_point_101(struct connection *pc, const struct packet_city_rally_point *packet, bool force_to_send)
{
  const struct packet_city_rally_point *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_city_rally_point_101_fields fields;
  struct packet_city_rally_point *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CITY_RALLY_POINT;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CITY_RALLY_POINT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_city_rally_point_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_city_rally_point_101, cmp_packet_city_rally_point_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->length != real_packet->length);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->persistent != real_packet->persistent);
  if (differ) {
    different++;
  }
  if (packet->persistent) {
    BV_SET(fields, 2);
  }

  differ = (old->vigilant != real_packet->vigilant);
  if (differ) {
    different++;
  }
  if (packet->vigilant) {
    BV_SET(fields, 3);
  }


    {
      differ = (old->length != real_packet->length);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->length; i++) {
          if (!are_unit_orders_equal(&old->orders[i], &real_packet->orders[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'length' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->length);
  }
  /* field 2 is folded into the header */
  /* field 3 is folded into the header */
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'orders' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->length);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "persistent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->persistent);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vigilant";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->vigilant);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_CITY_RALLY_POINT);
}

int send_packet_city_rally_point(struct connection *pc, const struct packet_city_rally_point *packet, bool force_to_send)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CITY_RALLY_POINT].force_to_send != NULL, -1,
                        "Handler for PACKET_CITY_RALLY_POINT not installed");
  return pc->phs.handlers->send[PACKET_CITY_RALLY_POINT].force_to_send(pc, packet, force_to_send);
}

void lsend_packet_city_rally_point(struct conn_list *dest, const struct packet_city_rally_point *packet, bool force_to_send)
{
  conn_list_iterate(dest, pconn) {
    send_packet_city_rally_point(pconn, packet, force_to_send);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_worker_task_100 hash_const

#define cmp_packet_worker_task_100 cmp_const

BV_DEFINE(packet_worker_task_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_worker_task *receive_packet_worker_task_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_worker_task_100_fields fields;
  struct packet_worker_task *old;
  struct genhash **hash = pc->phs.received + PACKET_WORKER_TASK;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_worker_task, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(tile_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
    real_packet->activity = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tgt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->tgt)) {
    RECEIVE_PACKET_FIELD_ERROR(tgt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "want";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->want)) {
    RECEIVE_PACKET_FIELD_ERROR(want);
  }

#endif
  log_packet_detailed("packet_worker_task_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_worker_task_100, cmp_packet_worker_task_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(tile_id);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity);
      }
      real_packet->activity = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'tgt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tgt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->tgt)) {
      RECEIVE_PACKET_FIELD_ERROR(tgt);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'want'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "want";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->want)) {
      RECEIVE_PACKET_FIELD_ERROR(want);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_worker_task_100(struct connection *pc, const struct packet_worker_task *packet)
{
  const struct packet_worker_task *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_worker_task_100_fields fields;
  struct packet_worker_task *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_WORKER_TASK;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_WORKER_TASK);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_worker_task_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_worker_task_100, cmp_packet_worker_task_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id32 != real_packet->city_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile_id != real_packet->tile_id);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->tgt != real_packet->tgt);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->want != real_packet->want);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'tgt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->tgt);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'want' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "want";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->want);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->tgt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "want";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->want);

#endif
  SEND_PACKET_END(PACKET_WORKER_TASK);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_worker_task_101 hash_const

#define cmp_packet_worker_task_101 cmp_const

BV_DEFINE(packet_worker_task_101_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_worker_task *receive_packet_worker_task_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_worker_task_101_fields fields;
  struct packet_worker_task *old;
  struct genhash **hash = pc->phs.received + PACKET_WORKER_TASK;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_worker_task, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(tile_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
    real_packet->activity = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tgt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->tgt)) {
    RECEIVE_PACKET_FIELD_ERROR(tgt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "want";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->want)) {
    RECEIVE_PACKET_FIELD_ERROR(want);
  }

#endif
  log_packet_detailed("packet_worker_task_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_worker_task_101, cmp_packet_worker_task_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(city_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(tile_id);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity);
      }
      real_packet->activity = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'tgt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tgt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->tgt)) {
      RECEIVE_PACKET_FIELD_ERROR(tgt);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'want'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "want";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->want)) {
      RECEIVE_PACKET_FIELD_ERROR(want);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_worker_task_101(struct connection *pc, const struct packet_worker_task *packet)
{
  const struct packet_worker_task *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_worker_task_101_fields fields;
  struct packet_worker_task *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_WORKER_TASK;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_WORKER_TASK);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_worker_task_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_worker_task_101, cmp_packet_worker_task_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->city_id16 != real_packet->city_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile_id != real_packet->tile_id);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->tgt != real_packet->tgt);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->want != real_packet->want);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'tgt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->tgt);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'want' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "want";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->want);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->tgt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "want";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->want);

#endif
  SEND_PACKET_END(PACKET_WORKER_TASK);
}

int send_packet_worker_task(struct connection *pc, const struct packet_worker_task *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_WORKER_TASK].packet != NULL, -1,
                        "Handler for PACKET_WORKER_TASK not installed");
  return pc->phs.handlers->send[PACKET_WORKER_TASK].packet(pc, packet);
}

void lsend_packet_worker_task(struct conn_list *dest, const struct packet_worker_task *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_worker_task(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_player_remove_100 hash_const

#define cmp_packet_player_remove_100 cmp_const

BV_DEFINE(packet_player_remove_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_remove *receive_packet_player_remove_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_remove_100_fields fields;
  struct packet_player_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->playerno)) {
    RECEIVE_PACKET_FIELD_ERROR(playerno);
  }

#endif
  log_packet_detailed("packet_player_remove_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_remove_100, cmp_packet_player_remove_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'playerno'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "playerno";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->playerno)) {
      RECEIVE_PACKET_FIELD_ERROR(playerno);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_PLAYER_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_remove_100(struct connection *pc, const struct packet_player_remove *packet)
{
  const struct packet_player_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_remove_100_fields fields;
  struct packet_player_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_remove_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_remove_100, cmp_packet_player_remove_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->playerno != real_packet->playerno);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'playerno' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->playerno);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_PLAYER_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->playerno);

#endif
  SEND_PACKET_END(PACKET_PLAYER_REMOVE);
}

int send_packet_player_remove(struct connection *pc, const struct packet_player_remove *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_REMOVE].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_REMOVE not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_REMOVE].packet(pc, packet);
}

int dsend_packet_player_remove(struct connection *pc, int playerno)
{
  struct packet_player_remove packet, *real_packet = &packet;

  real_packet->playerno = playerno;
  
  return send_packet_player_remove(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_player_info_100(const void *vkey)
{
  const struct packet_player_info *key = (const struct packet_player_info *) vkey;

  return key->playerno;
}

static bool cmp_packet_player_info_100(const void *vkey1, const void *vkey2)
{
  const struct packet_player_info *key1 = (const struct packet_player_info *) vkey1;
  const struct packet_player_info *key2 = (const struct packet_player_info *) vkey2;

  return key1->playerno == key2->playerno;
}
BV_DEFINE(packet_player_info_100_fields, 45);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_info *receive_packet_player_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_info_100_fields fields;
  struct packet_player_info *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->playerno)) {
    RECEIVE_PACKET_FIELD_ERROR(playerno);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->playerno)) {
    RECEIVE_PACKET_FIELD_ERROR(playerno);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->username, sizeof(real_packet->username))) {
    RECEIVE_PACKET_FIELD_ERROR(username);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unassigned_user";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->unassigned_user)) {
    RECEIVE_PACKET_FIELD_ERROR(unassigned_user);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "score";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->score)) {
    RECEIVE_PACKET_FIELD_ERROR(score);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_male";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_male)) {
    RECEIVE_PACKET_FIELD_ERROR(is_male);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_created";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->was_created)) {
    RECEIVE_PACKET_FIELD_ERROR(was_created);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(government);
    }
    real_packet->government = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_government";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(target_government);
    }
    real_packet->target_government = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "real_embassy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(bool8, &din, &field_addr, &real_packet->real_embassy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(real_embassy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mood";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(mood);
    }
    real_packet->mood = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
    RECEIVE_PACKET_FIELD_ERROR(style);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "music_style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->music_style)) {
    RECEIVE_PACKET_FIELD_ERROR(music_style);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(nation);
    }
    real_packet->nation = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->team)) {
    RECEIVE_PACKET_FIELD_ERROR(team);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_ready";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_ready)) {
    RECEIVE_PACKET_FIELD_ERROR(is_ready);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase_done";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->phase_done)) {
    RECEIVE_PACKET_FIELD_ERROR(phase_done);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nturns_idle";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->nturns_idle)) {
    RECEIVE_PACKET_FIELD_ERROR(nturns_idle);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turns_alive";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turns_alive)) {
    RECEIVE_PACKET_FIELD_ERROR(turns_alive);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_alive";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_alive)) {
    RECEIVE_PACKET_FIELD_ERROR(is_alive);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->gold)) {
    RECEIVE_PACKET_FIELD_ERROR(gold);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tax";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tax)) {
    RECEIVE_PACKET_FIELD_ERROR(tax);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->science)) {
    RECEIVE_PACKET_FIELD_ERROR(science);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "luxury";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->luxury)) {
    RECEIVE_PACKET_FIELD_ERROR(luxury);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infrapoints";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->infrapoints)) {
    RECEIVE_PACKET_FIELD_ERROR(infrapoints);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_upkeep";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tech_upkeep)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_upkeep);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->science_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(science_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_connected";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_connected)) {
    RECEIVE_PACKET_FIELD_ERROR(is_connected);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "revolution_finishes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->revolution_finishes)) {
    RECEIVE_PACKET_FIELD_ERROR(revolution_finishes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ai_skill_level";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(ai_skill_level);
    }
    real_packet->ai_skill_level = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "barbarian_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(barbarian_type);
    }
    real_packet->barbarian_type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gives_shared_vision";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->gives_shared_vision)) {
    RECEIVE_PACKET_FIELD_ERROR(gives_shared_vision);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
    RECEIVE_PACKET_FIELD_ERROR(history);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
    RECEIVE_PACKET_FIELD_ERROR(culture);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "love";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->love[i])) {
        RECEIVE_PACKET_FIELD_ERROR(love);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_valid";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->color_valid)) {
    RECEIVE_PACKET_FIELD_ERROR(color_valid);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_changeable";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->color_changeable)) {
    RECEIVE_PACKET_FIELD_ERROR(color_changeable);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_red";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_red)) {
    RECEIVE_PACKET_FIELD_ERROR(color_red);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_green";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_green)) {
    RECEIVE_PACKET_FIELD_ERROR(color_green);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_blue";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_blue)) {
    RECEIVE_PACKET_FIELD_ERROR(color_blue);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "wonders";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
    for (i = 0; i < B_LAST; i++) {
      if (!DIO_GET(sint32, &din, &field_addr, &real_packet->wonders[i])) {
        RECEIVE_PACKET_FIELD_ERROR(wonders);
      }
    }
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multip_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->multip_count)) {
    RECEIVE_PACKET_FIELD_ERROR(multip_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->multip_count > MAX_NUM_MULTIPLIERS) {
      RECEIVE_PACKET_FIELD_ERROR(multiplier, ": truncation array");
    }
    for (i = 0; i < real_packet->multip_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint32, &din, &field_addr, &real_packet->multiplier[i])) {
        RECEIVE_PACKET_FIELD_ERROR(multiplier);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier_target";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->multip_count > MAX_NUM_MULTIPLIERS) {
      RECEIVE_PACKET_FIELD_ERROR(multiplier_target, ": truncation array");
    }
    for (i = 0; i < real_packet->multip_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint32, &din, &field_addr, &real_packet->multiplier_target[i])) {
        RECEIVE_PACKET_FIELD_ERROR(multiplier_target);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier_changed";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->multip_count > MAX_NUM_MULTIPLIERS) {
      RECEIVE_PACKET_FIELD_ERROR(multiplier_changed, ": truncation array");
    }
    for (i = 0; i < real_packet->multip_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->multiplier_changed[i])) {
        RECEIVE_PACKET_FIELD_ERROR(multiplier_changed);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_player_info_100: got info about (%d)",
    real_packet->playerno);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_info_100, cmp_packet_player_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int playerno = real_packet->playerno;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->playerno = playerno;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'username'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "username";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->username, sizeof(real_packet->username))) {
      RECEIVE_PACKET_FIELD_ERROR(username);
    }
  }
  real_packet->unassigned_user = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'score'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "score";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->score)) {
      RECEIVE_PACKET_FIELD_ERROR(score);
    }
  }
  real_packet->is_male = BV_ISSET(fields, 4);
  real_packet->was_created = BV_ISSET(fields, 5);
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'government'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "government";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(government);
      }
      real_packet->government = readin;
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'target_government'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_government";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(target_government);
      }
      real_packet->target_government = readin;
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'real_embassy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "real_embassy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(bool8, &din, &field_addr, &real_packet->real_embassy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(real_embassy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'mood'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "mood";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(mood);
      }
      real_packet->mood = readin;
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
      RECEIVE_PACKET_FIELD_ERROR(style);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'music_style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "music_style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->music_style)) {
      RECEIVE_PACKET_FIELD_ERROR(music_style);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'nation'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(nation);
      }
      real_packet->nation = readin;
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'team'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "team";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->team)) {
      RECEIVE_PACKET_FIELD_ERROR(team);
    }
  }
  real_packet->is_ready = BV_ISSET(fields, 14);
  real_packet->phase_done = BV_ISSET(fields, 15);
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'nturns_idle'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nturns_idle";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->nturns_idle)) {
      RECEIVE_PACKET_FIELD_ERROR(nturns_idle);
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'turns_alive'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turns_alive";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turns_alive)) {
      RECEIVE_PACKET_FIELD_ERROR(turns_alive);
    }
  }
  real_packet->is_alive = BV_ISSET(fields, 18);
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'gold'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gold";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->gold)) {
      RECEIVE_PACKET_FIELD_ERROR(gold);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'tax'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tax";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tax)) {
      RECEIVE_PACKET_FIELD_ERROR(tax);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'science'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "science";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->science)) {
      RECEIVE_PACKET_FIELD_ERROR(science);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'luxury'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "luxury";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->luxury)) {
      RECEIVE_PACKET_FIELD_ERROR(luxury);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'infrapoints'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "infrapoints";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->infrapoints)) {
      RECEIVE_PACKET_FIELD_ERROR(infrapoints);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'tech_upkeep'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech_upkeep";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tech_upkeep)) {
      RECEIVE_PACKET_FIELD_ERROR(tech_upkeep);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'science_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "science_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->science_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(science_cost);
    }
  }
  real_packet->is_connected = BV_ISSET(fields, 26);
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'revolution_finishes'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "revolution_finishes";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->revolution_finishes)) {
      RECEIVE_PACKET_FIELD_ERROR(revolution_finishes);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'ai_skill_level'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ai_skill_level";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(ai_skill_level);
      }
      real_packet->ai_skill_level = readin;
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'barbarian_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "barbarian_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(barbarian_type);
      }
      real_packet->barbarian_type = readin;
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'gives_shared_vision'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gives_shared_vision";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->gives_shared_vision)) {
      RECEIVE_PACKET_FIELD_ERROR(gives_shared_vision);
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  got field 'history'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "history";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
      RECEIVE_PACKET_FIELD_ERROR(history);
    }
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  got field 'culture'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "culture";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->culture)) {
      RECEIVE_PACKET_FIELD_ERROR(culture);
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'love'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "love";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->love[i])) {
          RECEIVE_PACKET_FIELD_ERROR(love);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  real_packet->color_valid = BV_ISSET(fields, 34);
  real_packet->color_changeable = BV_ISSET(fields, 35);
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  got field 'color_red'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "color_red";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_red)) {
      RECEIVE_PACKET_FIELD_ERROR(color_red);
    }
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  got field 'color_green'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "color_green";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_green)) {
      RECEIVE_PACKET_FIELD_ERROR(color_green);
    }
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  got field 'color_blue'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "color_blue";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_blue)) {
      RECEIVE_PACKET_FIELD_ERROR(color_blue);
    }
  }
  if (BV_ISSET(fields, 39)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }
  if (BV_ISSET(fields, 40)) {
    log_packet_detailed("  got field 'wonders'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "wonders";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
    #ifdef FREECIV_JSON_CONNECTION
    int count;
    
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
    
    for (count = 0;; count++) {
      int i;
    
      field_addr.sub_location->number = count;
    
      /* Enter diff array element (start at the index address). */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
    #else /* FREECIV_JSON_CONNECTION */
    while (TRUE) {
      int i;
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (!DIO_GET(uint8, &din, &field_addr, &i)) {
        RECEIVE_PACKET_FIELD_ERROR(wonders);
      }
      if (i == 255) {
    #ifdef FREECIV_JSON_CONNECTION
        /* Exit diff array element. */
        free(field_addr.sub_location->sub_location);
        field_addr.sub_location->sub_location = NULL;
    
        /* Exit diff array. */
        free(field_addr.sub_location);
        field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    
        break;
      }
      if (i > B_LAST) {
        RECEIVE_PACKET_FIELD_ERROR(wonders,
                                   ": unexpected value %d "
                                   "(> B_LAST) in array diff",
                                   i);
      } else {
    #ifdef FREECIV_JSON_CONNECTION
        /* Content address. */
        field_addr.sub_location->sub_location->number = 1;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint32, &din, &field_addr, &real_packet->wonders[i])) {
          RECEIVE_PACKET_FIELD_ERROR(wonders);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
    
    #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 41)) {
    log_packet_detailed("  got field 'multip_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "multip_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->multip_count)) {
      RECEIVE_PACKET_FIELD_ERROR(multip_count);
    }
  }
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  got field 'multiplier'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "multiplier";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->multip_count > MAX_NUM_MULTIPLIERS) {
        RECEIVE_PACKET_FIELD_ERROR(multiplier, ": truncation array");
      }
      for (i = 0; i < real_packet->multip_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint32, &din, &field_addr, &real_packet->multiplier[i])) {
          RECEIVE_PACKET_FIELD_ERROR(multiplier);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  got field 'multiplier_target'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "multiplier_target";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->multip_count > MAX_NUM_MULTIPLIERS) {
        RECEIVE_PACKET_FIELD_ERROR(multiplier_target, ": truncation array");
      }
      for (i = 0; i < real_packet->multip_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint32, &din, &field_addr, &real_packet->multiplier_target[i])) {
          RECEIVE_PACKET_FIELD_ERROR(multiplier_target);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  got field 'multiplier_changed'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "multiplier_changed";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->multip_count > MAX_NUM_MULTIPLIERS) {
        RECEIVE_PACKET_FIELD_ERROR(multiplier_changed, ": truncation array");
      }
      for (i = 0; i < real_packet->multip_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->multiplier_changed[i])) {
          RECEIVE_PACKET_FIELD_ERROR(multiplier_changed);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_info_100(struct connection *pc, const struct packet_player_info *packet)
{
  const struct packet_player_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_info_100_fields fields;
  struct packet_player_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_info_100: sending info about (%d)",
    real_packet->playerno);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_info_100, cmp_packet_player_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->username, real_packet->username) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->unassigned_user != real_packet->unassigned_user);
  if (differ) {
    different++;
  }
  if (packet->unassigned_user) {
    BV_SET(fields, 2);
  }

  differ = (old->score != real_packet->score);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->is_male != real_packet->is_male);
  if (differ) {
    different++;
  }
  if (packet->is_male) {
    BV_SET(fields, 4);
  }

  differ = (old->was_created != real_packet->was_created);
  if (differ) {
    different++;
  }
  if (packet->was_created) {
    BV_SET(fields, 5);
  }

  differ = (old->government != real_packet->government);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (old->target_government != real_packet->target_government);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
          if (old->real_embassy[i] != real_packet->real_embassy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }

  differ = (old->mood != real_packet->mood);
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }

  differ = (old->style != real_packet->style);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (old->music_style != real_packet->music_style);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }

  differ = (old->nation != real_packet->nation);
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }

  differ = (old->team != real_packet->team);
  if (differ) {
    different++;
    BV_SET(fields, 13);
  }

  differ = (old->is_ready != real_packet->is_ready);
  if (differ) {
    different++;
  }
  if (packet->is_ready) {
    BV_SET(fields, 14);
  }

  differ = (old->phase_done != real_packet->phase_done);
  if (differ) {
    different++;
  }
  if (packet->phase_done) {
    BV_SET(fields, 15);
  }

  differ = (old->nturns_idle != real_packet->nturns_idle);
  if (differ) {
    different++;
    BV_SET(fields, 16);
  }

  differ = (old->turns_alive != real_packet->turns_alive);
  if (differ) {
    different++;
    BV_SET(fields, 17);
  }

  differ = (old->is_alive != real_packet->is_alive);
  if (differ) {
    different++;
  }
  if (packet->is_alive) {
    BV_SET(fields, 18);
  }

  differ = (old->gold != real_packet->gold);
  if (differ) {
    different++;
    BV_SET(fields, 19);
  }

  differ = (old->tax != real_packet->tax);
  if (differ) {
    different++;
    BV_SET(fields, 20);
  }

  differ = (old->science != real_packet->science);
  if (differ) {
    different++;
    BV_SET(fields, 21);
  }

  differ = (old->luxury != real_packet->luxury);
  if (differ) {
    different++;
    BV_SET(fields, 22);
  }

  differ = (old->infrapoints != real_packet->infrapoints);
  if (differ) {
    different++;
    BV_SET(fields, 23);
  }

  differ = (old->tech_upkeep != real_packet->tech_upkeep);
  if (differ) {
    different++;
    BV_SET(fields, 24);
  }

  differ = (old->science_cost != real_packet->science_cost);
  if (differ) {
    different++;
    BV_SET(fields, 25);
  }

  differ = (old->is_connected != real_packet->is_connected);
  if (differ) {
    different++;
  }
  if (packet->is_connected) {
    BV_SET(fields, 26);
  }

  differ = (old->revolution_finishes != real_packet->revolution_finishes);
  if (differ) {
    different++;
    BV_SET(fields, 27);
  }

  differ = (old->ai_skill_level != real_packet->ai_skill_level);
  if (differ) {
    different++;
    BV_SET(fields, 28);
  }

  differ = (old->barbarian_type != real_packet->barbarian_type);
  if (differ) {
    different++;
    BV_SET(fields, 29);
  }

  differ = !BV_ARE_EQUAL(old->gives_shared_vision, real_packet->gives_shared_vision);
  if (differ) {
    different++;
    BV_SET(fields, 30);
  }

  differ = (old->history != real_packet->history);
  if (differ) {
    different++;
    BV_SET(fields, 31);
  }

  differ = (old->culture != real_packet->culture);
  if (differ) {
    different++;
    BV_SET(fields, 32);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
          if (old->love[i] != real_packet->love[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 33);
  }

  differ = (old->color_valid != real_packet->color_valid);
  if (differ) {
    different++;
  }
  if (packet->color_valid) {
    BV_SET(fields, 34);
  }

  differ = (old->color_changeable != real_packet->color_changeable);
  if (differ) {
    different++;
  }
  if (packet->color_changeable) {
    BV_SET(fields, 35);
  }

  differ = (old->color_red != real_packet->color_red);
  if (differ) {
    different++;
    BV_SET(fields, 36);
  }

  differ = (old->color_green != real_packet->color_green);
  if (differ) {
    different++;
    BV_SET(fields, 37);
  }

  differ = (old->color_blue != real_packet->color_blue);
  if (differ) {
    different++;
    BV_SET(fields, 38);
  }

  differ = !BV_ARE_EQUAL(old->flags, real_packet->flags);
  if (differ) {
    different++;
    BV_SET(fields, 39);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < B_LAST; i++) {
          if (old->wonders[i] != real_packet->wonders[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 40);
  }

  differ = (old->multip_count != real_packet->multip_count);
  if (differ) {
    different++;
    BV_SET(fields, 41);
  }


    {
      differ = (old->multip_count != real_packet->multip_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->multip_count; i++) {
          if (old->multiplier[i] != real_packet->multiplier[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 42);
  }


    {
      differ = (old->multip_count != real_packet->multip_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->multip_count; i++) {
          if (old->multiplier_target[i] != real_packet->multiplier_target[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 43);
  }


    {
      differ = (old->multip_count != real_packet->multip_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->multip_count; i++) {
          if (old->multiplier_changed[i] != real_packet->multiplier_changed[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 44);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->playerno);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'username' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->username);
  }
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'score' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "score";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->score);
  }
  /* field 4 is folded into the header */
  /* field 5 is folded into the header */
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'government' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->government);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'target_government' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_government);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'real_embassy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "real_embassy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_NUM_PLAYER_SLOTS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->real_embassy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'mood' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mood";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->mood);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'music_style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "music_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->music_style);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'nation' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nation);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'team' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->team);
  }
  /* field 14 is folded into the header */
  /* field 15 is folded into the header */
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'nturns_idle' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nturns_idle";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nturns_idle);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'turns_alive' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turns_alive";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turns_alive);
  }
  /* field 18 is folded into the header */
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'gold' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->gold);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'tax' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tax";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tax);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'science' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->science);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'luxury' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "luxury";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->luxury);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'infrapoints' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infrapoints";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->infrapoints);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'tech_upkeep' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_upkeep";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->tech_upkeep);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'science_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->science_cost);
  }
  /* field 26 is folded into the header */
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'revolution_finishes' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "revolution_finishes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->revolution_finishes);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'ai_skill_level' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ai_skill_level";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ai_skill_level);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'barbarian_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "barbarian_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->barbarian_type);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'gives_shared_vision' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gives_shared_vision";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->gives_shared_vision);
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  field 'history' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  field 'culture' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'love' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "love";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_NUM_PLAYER_SLOTS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->love[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  /* field 34 is folded into the header */
  /* field 35 is folded into the header */
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  field 'color_red' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_red";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_red);
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  field 'color_green' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_green";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_green);
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  field 'color_blue' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_blue";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_blue);
  }
  if (BV_ISSET(fields, 39)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
  }
  if (BV_ISSET(fields, 40)) {
    log_packet_detailed("  field 'wonders' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "wonders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      int count = 0;

      for (i = 0; i < B_LAST; i++) {
        if (old->wonders[i] != real_packet->wonders[i]) {
          count++;
        }
      }
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, count + 1);

      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);

      count = 0;
#endif /* FREECIV_JSON_CONNECTION */

      fc_assert(B_LAST < 255);

      for (i = 0; i < B_LAST; i++) {
        if (old->wonders[i] != real_packet->wonders[i]) {
#ifdef FREECIV_JSON_CONNECTION
          /* Next diff array element. */
          field_addr.sub_location->number = count - 1;

          /* Create the diff array element. */
          DIO_PUT(farray, &dout, &field_addr, 2);

          /* Enter diff array element (start at the index address). */
          field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(uint8, &dout, &field_addr, i);

#ifdef FREECIV_JSON_CONNECTION
          /* Content address. */
          field_addr.sub_location->sub_location->number = 1;
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(sint32, &dout, &field_addr, real_packet->wonders[i]);

#ifdef FREECIV_JSON_CONNECTION
          /* Exit diff array element. */
          free(field_addr.sub_location->sub_location);
          field_addr.sub_location->sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
        }
      }
#ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = count - 1;

      /* Create the diff array element. */
      DIO_PUT(farray, &dout, &field_addr, B_LAST);

      /* Enter diff array element. Point to index address. */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
      DIO_PUT(uint8, &dout, &field_addr, 255);

#ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;

      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 41)) {
    log_packet_detailed("  field 'multip_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multip_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->multip_count);
  }
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  field 'multiplier' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->multip_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->multip_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->multiplier[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  field 'multiplier_target' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier_target";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->multip_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->multip_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->multiplier_target[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  field 'multiplier_changed' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier_changed";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->multip_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->multip_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->multiplier_changed[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->playerno);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->username);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unassigned_user";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->unassigned_user);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "score";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->score);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_male";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_male);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_created";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->was_created);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->government);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_government);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "real_embassy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_NUM_PLAYER_SLOTS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->real_embassy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mood";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->mood);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "music_style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->music_style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nation);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->team);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_ready";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_ready);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase_done";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->phase_done);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nturns_idle";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nturns_idle);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turns_alive";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turns_alive);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_alive";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_alive);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->gold);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tax";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tax);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->science);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "luxury";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->luxury);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infrapoints";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->infrapoints);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_upkeep";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->tech_upkeep);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->science_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_connected";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_connected);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "revolution_finishes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->revolution_finishes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ai_skill_level";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ai_skill_level);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "barbarian_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->barbarian_type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gives_shared_vision";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->gives_shared_vision);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "culture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->culture);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "love";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_NUM_PLAYER_SLOTS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_NUM_PLAYER_SLOTS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->love[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_valid";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->color_valid);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_changeable";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->color_changeable);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_red";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_red);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_green";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_green);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_blue";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_blue);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "wonders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, B_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < B_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->wonders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multip_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->multip_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->multip_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->multip_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->multiplier[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier_target";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->multip_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->multip_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->multiplier_target[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier_changed";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->multip_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->multip_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->multiplier_changed[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_PLAYER_INFO);
}

int send_packet_player_info(struct connection *pc, const struct packet_player_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_INFO].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_INFO not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_INFO].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_player_phase_done_100 hash_const

#define cmp_packet_player_phase_done_100 cmp_const

BV_DEFINE(packet_player_phase_done_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_phase_done *receive_packet_player_phase_done_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_phase_done_100_fields fields;
  struct packet_player_phase_done *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_PHASE_DONE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_phase_done, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
    RECEIVE_PACKET_FIELD_ERROR(turn);
  }

#endif
  log_packet_detailed("packet_player_phase_done_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_phase_done_100, cmp_packet_player_phase_done_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'turn'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
      RECEIVE_PACKET_FIELD_ERROR(turn);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_phase_done_100(struct connection *pc, const struct packet_player_phase_done *packet)
{
  const struct packet_player_phase_done *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_phase_done_100_fields fields;
  struct packet_player_phase_done *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_PHASE_DONE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_PHASE_DONE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_phase_done_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_phase_done_100, cmp_packet_player_phase_done_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->turn != real_packet->turn);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'turn' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);

#endif
  SEND_PACKET_END(PACKET_PLAYER_PHASE_DONE);
}

int send_packet_player_phase_done(struct connection *pc, const struct packet_player_phase_done *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_PHASE_DONE].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_PHASE_DONE not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_PHASE_DONE].packet(pc, packet);
}

int dsend_packet_player_phase_done(struct connection *pc, int turn)
{
  struct packet_player_phase_done packet, *real_packet = &packet;

  real_packet->turn = turn;
  
  return send_packet_player_phase_done(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_player_rates_100 hash_const

#define cmp_packet_player_rates_100 cmp_const

BV_DEFINE(packet_player_rates_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_rates *receive_packet_player_rates_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_rates_100_fields fields;
  struct packet_player_rates *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_RATES;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_rates, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tax";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tax)) {
    RECEIVE_PACKET_FIELD_ERROR(tax);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "luxury";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->luxury)) {
    RECEIVE_PACKET_FIELD_ERROR(luxury);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->science)) {
    RECEIVE_PACKET_FIELD_ERROR(science);
  }

#endif
  log_packet_detailed("packet_player_rates_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_rates_100, cmp_packet_player_rates_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tax'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tax";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tax)) {
      RECEIVE_PACKET_FIELD_ERROR(tax);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'luxury'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "luxury";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->luxury)) {
      RECEIVE_PACKET_FIELD_ERROR(luxury);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'science'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "science";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->science)) {
      RECEIVE_PACKET_FIELD_ERROR(science);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_rates_100(struct connection *pc, const struct packet_player_rates *packet)
{
  const struct packet_player_rates *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_rates_100_fields fields;
  struct packet_player_rates *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_RATES;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_RATES);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_rates_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_rates_100, cmp_packet_player_rates_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->tax != real_packet->tax);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->luxury != real_packet->luxury);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->science != real_packet->science);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tax' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tax";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tax);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'luxury' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "luxury";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->luxury);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'science' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->science);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tax";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tax);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "luxury";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->luxury);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->science);

#endif
  SEND_PACKET_END(PACKET_PLAYER_RATES);
}

int send_packet_player_rates(struct connection *pc, const struct packet_player_rates *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_RATES].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_RATES not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_RATES].packet(pc, packet);
}

int dsend_packet_player_rates(struct connection *pc, int tax, int luxury, int science)
{
  struct packet_player_rates packet, *real_packet = &packet;

  real_packet->tax = tax;
  real_packet->luxury = luxury;
  real_packet->science = science;
  
  return send_packet_player_rates(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_player_change_government_100 hash_const

#define cmp_packet_player_change_government_100 cmp_const

BV_DEFINE(packet_player_change_government_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_change_government *receive_packet_player_change_government_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_change_government_100_fields fields;
  struct packet_player_change_government *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_CHANGE_GOVERNMENT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_change_government, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(government);
    }
    real_packet->government = readin;
  }

#endif
  log_packet_detailed("packet_player_change_government_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_change_government_100, cmp_packet_player_change_government_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'government'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "government";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(government);
      }
      real_packet->government = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_change_government_100(struct connection *pc, const struct packet_player_change_government *packet)
{
  const struct packet_player_change_government *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_change_government_100_fields fields;
  struct packet_player_change_government *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_CHANGE_GOVERNMENT;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_CHANGE_GOVERNMENT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_change_government_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_change_government_100, cmp_packet_player_change_government_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->government != real_packet->government);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'government' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->government);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->government);

#endif
  SEND_PACKET_END(PACKET_PLAYER_CHANGE_GOVERNMENT);
}

int send_packet_player_change_government(struct connection *pc, const struct packet_player_change_government *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_CHANGE_GOVERNMENT].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_CHANGE_GOVERNMENT not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_CHANGE_GOVERNMENT].packet(pc, packet);
}

int dsend_packet_player_change_government(struct connection *pc, Government_type_id government)
{
  struct packet_player_change_government packet, *real_packet = &packet;

  real_packet->government = government;
  
  return send_packet_player_change_government(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_player_place_infra_100 hash_const

#define cmp_packet_player_place_infra_100 cmp_const

BV_DEFINE(packet_player_place_infra_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_place_infra *receive_packet_player_place_infra_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_place_infra_100_fields fields;
  struct packet_player_place_infra *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_PLACE_INFRA;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_place_infra, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extra";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->extra)) {
    RECEIVE_PACKET_FIELD_ERROR(extra);
  }

#endif
  log_packet_detailed("packet_player_place_infra_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_place_infra_100, cmp_packet_player_place_infra_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'extra'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "extra";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->extra)) {
      RECEIVE_PACKET_FIELD_ERROR(extra);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_place_infra_100(struct connection *pc, const struct packet_player_place_infra *packet)
{
  const struct packet_player_place_infra *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_place_infra_100_fields fields;
  struct packet_player_place_infra *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_PLACE_INFRA;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_PLACE_INFRA);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_place_infra_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_place_infra_100, cmp_packet_player_place_infra_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->tile != real_packet->tile);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->extra != real_packet->extra);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'extra' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extra";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->extra);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extra";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->extra);

#endif
  SEND_PACKET_END(PACKET_PLAYER_PLACE_INFRA);
}

int send_packet_player_place_infra(struct connection *pc, const struct packet_player_place_infra *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_PLACE_INFRA].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_PLACE_INFRA not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_PLACE_INFRA].packet(pc, packet);
}

int dsend_packet_player_place_infra(struct connection *pc, int tile, int extra)
{
  struct packet_player_place_infra packet, *real_packet = &packet;

  real_packet->tile = tile;
  real_packet->extra = extra;
  
  return send_packet_player_place_infra(pc, real_packet);
}

static struct packet_player_attribute_block *receive_packet_player_attribute_block_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_player_attribute_block, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_player_attribute_block_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_attribute_block_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_PLAYER_ATTRIBUTE_BLOCK);

  log_packet_detailed("packet_player_attribute_block_100: sending info about ()");
  SEND_PACKET_END(PACKET_PLAYER_ATTRIBUTE_BLOCK);
}

int send_packet_player_attribute_block(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_ATTRIBUTE_BLOCK].no_packet != NULL, -1,
                        "Handler for PACKET_PLAYER_ATTRIBUTE_BLOCK not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_ATTRIBUTE_BLOCK].no_packet(pc);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_player_attribute_chunk_100(const void *vkey)
{
  const struct packet_player_attribute_chunk *key = (const struct packet_player_attribute_chunk *) vkey;

  return key->offset;
}

static bool cmp_packet_player_attribute_chunk_100(const void *vkey1, const void *vkey2)
{
  const struct packet_player_attribute_chunk *key1 = (const struct packet_player_attribute_chunk *) vkey1;
  const struct packet_player_attribute_chunk *key2 = (const struct packet_player_attribute_chunk *) vkey2;

  return key1->offset == key2->offset;
}
BV_DEFINE(packet_player_attribute_chunk_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_attribute_chunk *receive_packet_player_attribute_chunk_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_attribute_chunk_100_fields fields;
  struct packet_player_attribute_chunk *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_ATTRIBUTE_CHUNK;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_attribute_chunk, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "offset";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->offset)) {
    RECEIVE_PACKET_FIELD_ERROR(offset);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "offset";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->offset)) {
    RECEIVE_PACKET_FIELD_ERROR(offset);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "total_length";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->total_length)) {
    RECEIVE_PACKET_FIELD_ERROR(total_length);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "chunk_length";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->chunk_length)) {
    RECEIVE_PACKET_FIELD_ERROR(chunk_length);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "data";
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->chunk_length > ATTRIBUTE_CHUNK_SIZE) {
      RECEIVE_PACKET_FIELD_ERROR(data, ": truncation array");
    }
    if (!DIO_GET(memory, &din, &field_addr, real_packet->data, real_packet->chunk_length)) {
      RECEIVE_PACKET_FIELD_ERROR(data);
    }

#endif
  log_packet_detailed("packet_player_attribute_chunk_100: got info about (%d)",
    real_packet->offset);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_attribute_chunk_100, cmp_packet_player_attribute_chunk_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int offset = real_packet->offset;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->offset = offset;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'total_length'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "total_length";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->total_length)) {
      RECEIVE_PACKET_FIELD_ERROR(total_length);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'chunk_length'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "chunk_length";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->chunk_length)) {
      RECEIVE_PACKET_FIELD_ERROR(chunk_length);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'data'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "data";
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->chunk_length > ATTRIBUTE_CHUNK_SIZE) {
        RECEIVE_PACKET_FIELD_ERROR(data, ": truncation array");
      }
      if (!DIO_GET(memory, &din, &field_addr, real_packet->data, real_packet->chunk_length)) {
        RECEIVE_PACKET_FIELD_ERROR(data);
      }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_attribute_chunk_100(struct connection *pc, const struct packet_player_attribute_chunk *packet)
{
  const struct packet_player_attribute_chunk *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_attribute_chunk_100_fields fields;
  struct packet_player_attribute_chunk *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_ATTRIBUTE_CHUNK;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_ATTRIBUTE_CHUNK);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_attribute_chunk_100: sending info about (%d)",
    real_packet->offset);

  {
    struct packet_player_attribute_chunk *tmp = fc_malloc(sizeof(*tmp));

    *tmp = *packet;
    pre_send_packet_player_attribute_chunk(pc, tmp);
    real_packet = tmp;
  }

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_attribute_chunk_100, cmp_packet_player_attribute_chunk_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->total_length != real_packet->total_length);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->chunk_length != real_packet->chunk_length);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (memcmp(old->data, real_packet->data, ATTRIBUTE_CHUNK_SIZE) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "offset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->offset);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'total_length' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "total_length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->total_length);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'chunk_length' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "chunk_length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->chunk_length);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'data' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "data";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(memory, &dout, &field_addr, &real_packet->data, real_packet->chunk_length);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "offset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->offset);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "total_length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->total_length);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "chunk_length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->chunk_length);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "data";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(memory, &dout, &field_addr, &real_packet->data, real_packet->chunk_length);

#endif

  if (real_packet != packet) {
    free((void *) real_packet);
  }
  SEND_PACKET_END(PACKET_PLAYER_ATTRIBUTE_CHUNK);
}

int send_packet_player_attribute_chunk(struct connection *pc, const struct packet_player_attribute_chunk *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_ATTRIBUTE_CHUNK].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_ATTRIBUTE_CHUNK not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_ATTRIBUTE_CHUNK].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_player_diplstate_100(const void *vkey)
{
  const struct packet_player_diplstate *key = (const struct packet_player_diplstate *) vkey;

  return key->diplstate_id;
}

static bool cmp_packet_player_diplstate_100(const void *vkey1, const void *vkey2)
{
  const struct packet_player_diplstate *key1 = (const struct packet_player_diplstate *) vkey1;
  const struct packet_player_diplstate *key2 = (const struct packet_player_diplstate *) vkey2;

  return key1->diplstate_id == key2->diplstate_id;
}
BV_DEFINE(packet_player_diplstate_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_diplstate *receive_packet_player_diplstate_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_diplstate_100_fields fields;
  struct packet_player_diplstate *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_DIPLSTATE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_diplstate, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplstate_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->diplstate_id)) {
    RECEIVE_PACKET_FIELD_ERROR(diplstate_id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplstate_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->diplstate_id)) {
    RECEIVE_PACKET_FIELD_ERROR(diplstate_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plr1";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->plr1)) {
    RECEIVE_PACKET_FIELD_ERROR(plr1);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plr2";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->plr2)) {
    RECEIVE_PACKET_FIELD_ERROR(plr2);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turns_left";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->turns_left)) {
    RECEIVE_PACKET_FIELD_ERROR(turns_left);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "has_reason_to_cancel";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->has_reason_to_cancel)) {
    RECEIVE_PACKET_FIELD_ERROR(has_reason_to_cancel);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "contact_turns_left";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->contact_turns_left)) {
    RECEIVE_PACKET_FIELD_ERROR(contact_turns_left);
  }

#endif
  log_packet_detailed("packet_player_diplstate_100: got info about (%d)",
    real_packet->diplstate_id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_diplstate_100, cmp_packet_player_diplstate_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int diplstate_id = real_packet->diplstate_id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->diplstate_id = diplstate_id;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'plr1'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "plr1";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->plr1)) {
      RECEIVE_PACKET_FIELD_ERROR(plr1);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'plr2'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "plr2";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->plr2)) {
      RECEIVE_PACKET_FIELD_ERROR(plr2);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'turns_left'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turns_left";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->turns_left)) {
      RECEIVE_PACKET_FIELD_ERROR(turns_left);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'has_reason_to_cancel'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "has_reason_to_cancel";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->has_reason_to_cancel)) {
      RECEIVE_PACKET_FIELD_ERROR(has_reason_to_cancel);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'contact_turns_left'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "contact_turns_left";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->contact_turns_left)) {
      RECEIVE_PACKET_FIELD_ERROR(contact_turns_left);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_diplstate_100(struct connection *pc, const struct packet_player_diplstate *packet)
{
  const struct packet_player_diplstate *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_diplstate_100_fields fields;
  struct packet_player_diplstate *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_DIPLSTATE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_DIPLSTATE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_diplstate_100: sending info about (%d)",
    real_packet->diplstate_id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_diplstate_100, cmp_packet_player_diplstate_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->plr1 != real_packet->plr1);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->plr2 != real_packet->plr2);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->turns_left != real_packet->turns_left);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->has_reason_to_cancel != real_packet->has_reason_to_cancel);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->contact_turns_left != real_packet->contact_turns_left);
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplstate_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->diplstate_id);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'plr1' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plr1";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->plr1);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'plr2' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plr2";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->plr2);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'turns_left' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turns_left";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->turns_left);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'has_reason_to_cancel' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "has_reason_to_cancel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->has_reason_to_cancel);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'contact_turns_left' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "contact_turns_left";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->contact_turns_left);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "diplstate_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->diplstate_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plr1";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->plr1);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plr2";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->plr2);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turns_left";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->turns_left);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "has_reason_to_cancel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->has_reason_to_cancel);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "contact_turns_left";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->contact_turns_left);

#endif
  SEND_PACKET_END(PACKET_PLAYER_DIPLSTATE);
}

int send_packet_player_diplstate(struct connection *pc, const struct packet_player_diplstate *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_DIPLSTATE].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_DIPLSTATE not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_DIPLSTATE].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_player_multiplier_100 hash_const

#define cmp_packet_player_multiplier_100 cmp_const

BV_DEFINE(packet_player_multiplier_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_multiplier *receive_packet_player_multiplier_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_multiplier_100_fields fields;
  struct packet_player_multiplier *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_MULTIPLIER;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_multiplier, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->count)) {
    RECEIVE_PACKET_FIELD_ERROR(count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multipliers";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->count > MAX_NUM_MULTIPLIERS) {
      RECEIVE_PACKET_FIELD_ERROR(multipliers, ": truncation array");
    }
    for (i = 0; i < real_packet->count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint32, &din, &field_addr, &real_packet->multipliers[i])) {
        RECEIVE_PACKET_FIELD_ERROR(multipliers);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_player_multiplier_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_multiplier_100, cmp_packet_player_multiplier_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->count)) {
      RECEIVE_PACKET_FIELD_ERROR(count);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'multipliers'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "multipliers";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->count > MAX_NUM_MULTIPLIERS) {
        RECEIVE_PACKET_FIELD_ERROR(multipliers, ": truncation array");
      }
      for (i = 0; i < real_packet->count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint32, &din, &field_addr, &real_packet->multipliers[i])) {
          RECEIVE_PACKET_FIELD_ERROR(multipliers);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_multiplier_100(struct connection *pc, const struct packet_player_multiplier *packet)
{
  const struct packet_player_multiplier *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_multiplier_100_fields fields;
  struct packet_player_multiplier *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_MULTIPLIER;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_MULTIPLIER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_multiplier_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_multiplier_100, cmp_packet_player_multiplier_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->count != real_packet->count);
  if (differ) {
    BV_SET(fields, 0);
  }


    {
      differ = (old->count != real_packet->count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->count; i++) {
          if (old->multipliers[i] != real_packet->multipliers[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->count);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'multipliers' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multipliers";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->multipliers[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multipliers";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->multipliers[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_PLAYER_MULTIPLIER);
}

int send_packet_player_multiplier(struct connection *pc, const struct packet_player_multiplier *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_MULTIPLIER].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_MULTIPLIER not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_MULTIPLIER].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_research_info_100(const void *vkey)
{
  const struct packet_research_info *key = (const struct packet_research_info *) vkey;

  return key->id;
}

static bool cmp_packet_research_info_100(const void *vkey1, const void *vkey2)
{
  const struct packet_research_info *key1 = (const struct packet_research_info *) vkey1;
  const struct packet_research_info *key2 = (const struct packet_research_info *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_research_info_100_fields, 8);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_research_info *receive_packet_research_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_research_info_100_fields fields;
  struct packet_research_info *old;
  struct genhash **hash = pc->phs.received + PACKET_RESEARCH_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_research_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "techs_researched";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->techs_researched)) {
    RECEIVE_PACKET_FIELD_ERROR(techs_researched);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "future_tech";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->future_tech)) {
    RECEIVE_PACKET_FIELD_ERROR(future_tech);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "researching";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->researching)) {
    RECEIVE_PACKET_FIELD_ERROR(researching);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "researching_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->researching_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(researching_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bulbs_researched";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->bulbs_researched)) {
    RECEIVE_PACKET_FIELD_ERROR(bulbs_researched);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_goal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech_goal)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_goal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "total_bulbs_prod";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->total_bulbs_prod)) {
    RECEIVE_PACKET_FIELD_ERROR(total_bulbs_prod);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "inventions";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->inventions, sizeof(real_packet->inventions))) {
    RECEIVE_PACKET_FIELD_ERROR(inventions);
  }

#endif
  log_packet_detailed("packet_research_info_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_research_info_100, cmp_packet_research_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'techs_researched'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "techs_researched";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->techs_researched)) {
      RECEIVE_PACKET_FIELD_ERROR(techs_researched);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'future_tech'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "future_tech";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->future_tech)) {
      RECEIVE_PACKET_FIELD_ERROR(future_tech);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'researching'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "researching";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->researching)) {
      RECEIVE_PACKET_FIELD_ERROR(researching);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'researching_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "researching_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->researching_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(researching_cost);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'bulbs_researched'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "bulbs_researched";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->bulbs_researched)) {
      RECEIVE_PACKET_FIELD_ERROR(bulbs_researched);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'tech_goal'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech_goal";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech_goal)) {
      RECEIVE_PACKET_FIELD_ERROR(tech_goal);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'total_bulbs_prod'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "total_bulbs_prod";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->total_bulbs_prod)) {
      RECEIVE_PACKET_FIELD_ERROR(total_bulbs_prod);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'inventions'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "inventions";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->inventions, sizeof(real_packet->inventions))) {
      RECEIVE_PACKET_FIELD_ERROR(inventions);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_research_info_100(struct connection *pc, const struct packet_research_info *packet)
{
  const struct packet_research_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_research_info_100_fields fields;
  struct packet_research_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RESEARCH_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RESEARCH_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_research_info_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_research_info_100, cmp_packet_research_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->techs_researched != real_packet->techs_researched);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->future_tech != real_packet->future_tech);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->researching != real_packet->researching);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->researching_cost != real_packet->researching_cost);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->bulbs_researched != real_packet->bulbs_researched);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->tech_goal != real_packet->tech_goal);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->total_bulbs_prod != real_packet->total_bulbs_prod);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (strcmp(old->inventions, real_packet->inventions) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'techs_researched' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "techs_researched";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->techs_researched);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'future_tech' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "future_tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->future_tech);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'researching' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "researching";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->researching);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'researching_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "researching_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->researching_cost);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'bulbs_researched' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bulbs_researched";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->bulbs_researched);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'tech_goal' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_goal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_goal);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'total_bulbs_prod' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "total_bulbs_prod";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->total_bulbs_prod);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'inventions' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "inventions";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->inventions);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "techs_researched";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->techs_researched);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "future_tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->future_tech);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "researching";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->researching);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "researching_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->researching_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bulbs_researched";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->bulbs_researched);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_goal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_goal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "total_bulbs_prod";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->total_bulbs_prod);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "inventions";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->inventions);

#endif
  SEND_PACKET_END(PACKET_RESEARCH_INFO);
}

int send_packet_research_info(struct connection *pc, const struct packet_research_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RESEARCH_INFO].packet != NULL, -1,
                        "Handler for PACKET_RESEARCH_INFO not installed");
  return pc->phs.handlers->send[PACKET_RESEARCH_INFO].packet(pc, packet);
}

void lsend_packet_research_info(struct conn_list *dest, const struct packet_research_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_research_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unknown_research_100 hash_const

#define cmp_packet_unknown_research_100 cmp_const

BV_DEFINE(packet_unknown_research_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unknown_research *receive_packet_unknown_research_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unknown_research_100_fields fields;
  struct packet_unknown_research *old;
  struct genhash **hash = pc->phs.received + PACKET_UNKNOWN_RESEARCH;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unknown_research, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#endif
  log_packet_detailed("packet_unknown_research_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unknown_research_100, cmp_packet_unknown_research_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_RESEARCH_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unknown_research_100(struct connection *pc, const struct packet_unknown_research *packet)
{
  const struct packet_unknown_research *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unknown_research_100_fields fields;
  struct packet_unknown_research *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNKNOWN_RESEARCH;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNKNOWN_RESEARCH);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unknown_research_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unknown_research_100, cmp_packet_unknown_research_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_RESEARCH_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);

#endif
  SEND_PACKET_END(PACKET_UNKNOWN_RESEARCH);
}

int send_packet_unknown_research(struct connection *pc, const struct packet_unknown_research *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNKNOWN_RESEARCH].packet != NULL, -1,
                        "Handler for PACKET_UNKNOWN_RESEARCH not installed");
  return pc->phs.handlers->send[PACKET_UNKNOWN_RESEARCH].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_player_research_100 hash_const

#define cmp_packet_player_research_100 cmp_const

BV_DEFINE(packet_player_research_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_research *receive_packet_player_research_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_research_100_fields fields;
  struct packet_player_research *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_RESEARCH;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_research, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech)) {
    RECEIVE_PACKET_FIELD_ERROR(tech);
  }

#endif
  log_packet_detailed("packet_player_research_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_research_100, cmp_packet_player_research_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tech'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech)) {
      RECEIVE_PACKET_FIELD_ERROR(tech);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_research_100(struct connection *pc, const struct packet_player_research *packet)
{
  const struct packet_player_research *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_research_100_fields fields;
  struct packet_player_research *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_RESEARCH;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_RESEARCH);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_research_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_research_100, cmp_packet_player_research_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->tech != real_packet->tech);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tech' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech);

#endif
  SEND_PACKET_END(PACKET_PLAYER_RESEARCH);
}

int send_packet_player_research(struct connection *pc, const struct packet_player_research *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_RESEARCH].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_RESEARCH not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_RESEARCH].packet(pc, packet);
}

int dsend_packet_player_research(struct connection *pc, int tech)
{
  struct packet_player_research packet, *real_packet = &packet;

  real_packet->tech = tech;
  
  return send_packet_player_research(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_player_tech_goal_100 hash_const

#define cmp_packet_player_tech_goal_100 cmp_const

BV_DEFINE(packet_player_tech_goal_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_player_tech_goal *receive_packet_player_tech_goal_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_tech_goal_100_fields fields;
  struct packet_player_tech_goal *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAYER_TECH_GOAL;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_player_tech_goal, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech)) {
    RECEIVE_PACKET_FIELD_ERROR(tech);
  }

#endif
  log_packet_detailed("packet_player_tech_goal_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_tech_goal_100, cmp_packet_player_tech_goal_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tech'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech)) {
      RECEIVE_PACKET_FIELD_ERROR(tech);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_player_tech_goal_100(struct connection *pc, const struct packet_player_tech_goal *packet)
{
  const struct packet_player_tech_goal *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_player_tech_goal_100_fields fields;
  struct packet_player_tech_goal *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAYER_TECH_GOAL;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAYER_TECH_GOAL);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_player_tech_goal_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_player_tech_goal_100, cmp_packet_player_tech_goal_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->tech != real_packet->tech);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tech' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech);

#endif
  SEND_PACKET_END(PACKET_PLAYER_TECH_GOAL);
}

int send_packet_player_tech_goal(struct connection *pc, const struct packet_player_tech_goal *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAYER_TECH_GOAL].packet != NULL, -1,
                        "Handler for PACKET_PLAYER_TECH_GOAL not installed");
  return pc->phs.handlers->send[PACKET_PLAYER_TECH_GOAL].packet(pc, packet);
}

int dsend_packet_player_tech_goal(struct connection *pc, int tech)
{
  struct packet_player_tech_goal packet, *real_packet = &packet;

  real_packet->tech = tech;
  
  return send_packet_player_tech_goal(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_remove_100 hash_const

#define cmp_packet_unit_remove_100 cmp_const

BV_DEFINE(packet_unit_remove_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_remove *receive_packet_unit_remove_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_remove_100_fields fields;
  struct packet_unit_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id32);
  }

#endif
  log_packet_detailed("packet_unit_remove_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_remove_100, cmp_packet_unit_remove_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_UNIT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_UNIT_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_remove_100(struct connection *pc, const struct packet_unit_remove *packet)
{
  const struct packet_unit_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_remove_100_fields fields;
  struct packet_unit_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_remove_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_remove_100, cmp_packet_unit_remove_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id32 != real_packet->unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_UNIT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_UNIT_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);

#endif
  SEND_PACKET_END(PACKET_UNIT_REMOVE);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_remove_101 hash_const

#define cmp_packet_unit_remove_101 cmp_const

BV_DEFINE(packet_unit_remove_101_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_remove *receive_packet_unit_remove_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_remove_101_fields fields;
  struct packet_unit_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id16);
  }

#endif
  log_packet_detailed("packet_unit_remove_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_remove_101, cmp_packet_unit_remove_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_UNIT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.received + PACKET_UNIT_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_remove_101(struct connection *pc, const struct packet_unit_remove *packet)
{
  const struct packet_unit_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_remove_101_fields fields;
  struct packet_unit_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_remove_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_remove_101, cmp_packet_unit_remove_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id16 != real_packet->unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_UNIT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

  hash = pc->phs.sent + PACKET_UNIT_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);

#endif
  SEND_PACKET_END(PACKET_UNIT_REMOVE);
}

int send_packet_unit_remove(struct connection *pc, const struct packet_unit_remove *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_REMOVE].packet != NULL, -1,
                        "Handler for PACKET_UNIT_REMOVE not installed");
  return pc->phs.handlers->send[PACKET_UNIT_REMOVE].packet(pc, packet);
}

void lsend_packet_unit_remove(struct conn_list *dest, const struct packet_unit_remove *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_unit_remove(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_unit_remove(struct connection *pc, int unit_id16, int unit_id32)
{
  struct packet_unit_remove packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  
  return send_packet_unit_remove(pc, real_packet);
}

void dlsend_packet_unit_remove(struct conn_list *dest, int unit_id16, int unit_id32)
{
  struct packet_unit_remove packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  
  lsend_packet_unit_remove(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_info_100 hash_const

#define cmp_packet_unit_info_100 cmp_const

BV_DEFINE(packet_unit_info_100_fields, 36);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_info *receive_packet_unit_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_info_100_fields fields;
  struct packet_unit_info *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationality";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nationality)) {
    RECEIVE_PACKET_FIELD_ERROR(nationality);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(facing);
    }
    real_packet->facing = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->homecity32)) {
    RECEIVE_PACKET_FIELD_ERROR(homecity32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->upkeep[i])) {
        RECEIVE_PACKET_FIELD_ERROR(upkeep);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ssa_controller";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(ssa_controller);
    }
    real_packet->ssa_controller = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paradropped";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->paradropped)) {
    RECEIVE_PACKET_FIELD_ERROR(paradropped);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->occupied)) {
    RECEIVE_PACKET_FIELD_ERROR(occupied);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->transported)) {
    RECEIVE_PACKET_FIELD_ERROR(transported);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "done_moving";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->done_moving)) {
    RECEIVE_PACKET_FIELD_ERROR(done_moving);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stay";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->stay)) {
    RECEIVE_PACKET_FIELD_ERROR(stay);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->transported_by32)) {
    RECEIVE_PACKET_FIELD_ERROR(transported_by32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "carrying";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->carrying)) {
    RECEIVE_PACKET_FIELD_ERROR(carrying);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "movesleft";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->movesleft)) {
    RECEIVE_PACKET_FIELD_ERROR(movesleft);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
    RECEIVE_PACKET_FIELD_ERROR(hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
    RECEIVE_PACKET_FIELD_ERROR(fuel);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->activity_count)) {
    RECEIVE_PACKET_FIELD_ERROR(activity_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->changed_from_count)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goto_tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->goto_tile)) {
    RECEIVE_PACKET_FIELD_ERROR(goto_tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
    real_packet->activity = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->activity_tgt)) {
    RECEIVE_PACKET_FIELD_ERROR(activity_tgt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from);
    }
    real_packet->changed_from = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_tgt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->changed_from_tgt)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_tgt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "battlegroup";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->battlegroup)) {
    RECEIVE_PACKET_FIELD_ERROR(battlegroup);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "has_orders";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->has_orders)) {
    RECEIVE_PACKET_FIELD_ERROR(has_orders);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_length";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->orders_length)) {
    RECEIVE_PACKET_FIELD_ERROR(orders_length);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_index";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->orders_index)) {
    RECEIVE_PACKET_FIELD_ERROR(orders_index);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_repeat";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->orders_repeat)) {
    RECEIVE_PACKET_FIELD_ERROR(orders_repeat);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_vigilant";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->orders_vigilant)) {
    RECEIVE_PACKET_FIELD_ERROR(orders_vigilant);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->orders_length > MAX_LEN_ROUTE) {
      RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
    }
    for (i = 0; i < real_packet->orders_length; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
        RECEIVE_PACKET_FIELD_ERROR(orders);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_want";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(action_decision_want);
    }
    real_packet->action_decision_want = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->action_decision_tile)) {
    RECEIVE_PACKET_FIELD_ERROR(action_decision_tile);
  }

#endif
  log_packet_detailed("packet_unit_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_info_100, cmp_packet_unit_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'nationality'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nationality";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nationality)) {
      RECEIVE_PACKET_FIELD_ERROR(nationality);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'facing'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "facing";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(facing);
      }
      real_packet->facing = readin;
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'homecity32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "homecity32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->homecity32)) {
      RECEIVE_PACKET_FIELD_ERROR(homecity32);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'upkeep'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "upkeep";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->upkeep[i])) {
          RECEIVE_PACKET_FIELD_ERROR(upkeep);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'veteran'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
      RECEIVE_PACKET_FIELD_ERROR(veteran);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'ssa_controller'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ssa_controller";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(ssa_controller);
      }
      real_packet->ssa_controller = readin;
    }
  }
  real_packet->paradropped = BV_ISSET(fields, 9);
  real_packet->occupied = BV_ISSET(fields, 10);
  real_packet->transported = BV_ISSET(fields, 11);
  real_packet->done_moving = BV_ISSET(fields, 12);
  real_packet->stay = BV_ISSET(fields, 13);
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'transported_by32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "transported_by32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->transported_by32)) {
      RECEIVE_PACKET_FIELD_ERROR(transported_by32);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'carrying'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "carrying";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->carrying)) {
      RECEIVE_PACKET_FIELD_ERROR(carrying);
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'movesleft'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "movesleft";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->movesleft)) {
      RECEIVE_PACKET_FIELD_ERROR(movesleft);
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
      RECEIVE_PACKET_FIELD_ERROR(hp);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'fuel'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "fuel";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
      RECEIVE_PACKET_FIELD_ERROR(fuel);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'activity_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->activity_count)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_count);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'changed_from_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->changed_from_count)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_count);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'goto_tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "goto_tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->goto_tile)) {
      RECEIVE_PACKET_FIELD_ERROR(goto_tile);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity);
      }
      real_packet->activity = readin;
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'activity_tgt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_tgt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->activity_tgt)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_tgt);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'changed_from'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(changed_from);
      }
      real_packet->changed_from = readin;
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'changed_from_tgt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_tgt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->changed_from_tgt)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_tgt);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'battlegroup'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "battlegroup";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->battlegroup)) {
      RECEIVE_PACKET_FIELD_ERROR(battlegroup);
    }
  }
  real_packet->has_orders = BV_ISSET(fields, 28);
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'orders_length'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders_length";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->orders_length)) {
      RECEIVE_PACKET_FIELD_ERROR(orders_length);
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'orders_index'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders_index";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->orders_index)) {
      RECEIVE_PACKET_FIELD_ERROR(orders_index);
    }
  }
  real_packet->orders_repeat = BV_ISSET(fields, 31);
  real_packet->orders_vigilant = BV_ISSET(fields, 32);
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'orders'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->orders_length > MAX_LEN_ROUTE) {
        RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
      }
      for (i = 0; i < real_packet->orders_length; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
          RECEIVE_PACKET_FIELD_ERROR(orders);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'action_decision_want'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_decision_want";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(action_decision_want);
      }
      real_packet->action_decision_want = readin;
    }
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  got field 'action_decision_tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_decision_tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->action_decision_tile)) {
      RECEIVE_PACKET_FIELD_ERROR(action_decision_tile);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_UNIT_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_info_100(struct connection *pc, const struct packet_unit_info *packet)
{
  const struct packet_unit_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_info_100_fields fields;
  struct packet_unit_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_info_100, cmp_packet_unit_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->nationality != real_packet->nationality);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->facing != real_packet->facing);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->homecity32 != real_packet->homecity32);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->upkeep[i] != real_packet->upkeep[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (old->veteran != real_packet->veteran);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }

  differ = (old->ssa_controller != real_packet->ssa_controller);
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }

  differ = (old->paradropped != real_packet->paradropped);
  if (differ) {
    different++;
  }
  if (packet->paradropped) {
    BV_SET(fields, 9);
  }

  differ = (old->occupied != real_packet->occupied);
  if (differ) {
    different++;
  }
  if (packet->occupied) {
    BV_SET(fields, 10);
  }

  differ = (old->transported != real_packet->transported);
  if (differ) {
    different++;
  }
  if (packet->transported) {
    BV_SET(fields, 11);
  }

  differ = (old->done_moving != real_packet->done_moving);
  if (differ) {
    different++;
  }
  if (packet->done_moving) {
    BV_SET(fields, 12);
  }

  differ = (old->stay != real_packet->stay);
  if (differ) {
    different++;
  }
  if (packet->stay) {
    BV_SET(fields, 13);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    different++;
    BV_SET(fields, 14);
  }

  differ = (old->transported_by32 != real_packet->transported_by32);
  if (differ) {
    different++;
    BV_SET(fields, 15);
  }

  differ = (old->carrying != real_packet->carrying);
  if (differ) {
    different++;
    BV_SET(fields, 16);
  }

  differ = (old->movesleft != real_packet->movesleft);
  if (differ) {
    different++;
    BV_SET(fields, 17);
  }

  differ = (old->hp != real_packet->hp);
  if (differ) {
    different++;
    BV_SET(fields, 18);
  }

  differ = (old->fuel != real_packet->fuel);
  if (differ) {
    different++;
    BV_SET(fields, 19);
  }

  differ = (old->activity_count != real_packet->activity_count);
  if (differ) {
    different++;
    BV_SET(fields, 20);
  }

  differ = (old->changed_from_count != real_packet->changed_from_count);
  if (differ) {
    different++;
    BV_SET(fields, 21);
  }

  differ = (old->goto_tile != real_packet->goto_tile);
  if (differ) {
    different++;
    BV_SET(fields, 22);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    different++;
    BV_SET(fields, 23);
  }

  differ = (old->activity_tgt != real_packet->activity_tgt);
  if (differ) {
    different++;
    BV_SET(fields, 24);
  }

  differ = (old->changed_from != real_packet->changed_from);
  if (differ) {
    different++;
    BV_SET(fields, 25);
  }

  differ = (old->changed_from_tgt != real_packet->changed_from_tgt);
  if (differ) {
    different++;
    BV_SET(fields, 26);
  }

  differ = (old->battlegroup != real_packet->battlegroup);
  if (differ) {
    different++;
    BV_SET(fields, 27);
  }

  differ = (old->has_orders != real_packet->has_orders);
  if (differ) {
    different++;
  }
  if (packet->has_orders) {
    BV_SET(fields, 28);
  }

  differ = (old->orders_length != real_packet->orders_length);
  if (differ) {
    different++;
    BV_SET(fields, 29);
  }

  differ = (old->orders_index != real_packet->orders_index);
  if (differ) {
    different++;
    BV_SET(fields, 30);
  }

  differ = (old->orders_repeat != real_packet->orders_repeat);
  if (differ) {
    different++;
  }
  if (packet->orders_repeat) {
    BV_SET(fields, 31);
  }

  differ = (old->orders_vigilant != real_packet->orders_vigilant);
  if (differ) {
    different++;
  }
  if (packet->orders_vigilant) {
    BV_SET(fields, 32);
  }


    {
      differ = (old->orders_length != real_packet->orders_length);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->orders_length; i++) {
          if (!are_unit_orders_equal(&old->orders[i], &real_packet->orders[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 33);
  }

  differ = (old->action_decision_want != real_packet->action_decision_want);
  if (differ) {
    different++;
    BV_SET(fields, 34);
  }

  differ = (old->action_decision_tile != real_packet->action_decision_tile);
  if (differ) {
    different++;
    BV_SET(fields, 35);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'nationality' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationality";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->nationality);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'facing' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->facing);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'homecity32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->homecity32);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'upkeep' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->upkeep[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'veteran' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'ssa_controller' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ssa_controller";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ssa_controller);
  }
  /* field 9 is folded into the header */
  /* field 10 is folded into the header */
  /* field 11 is folded into the header */
  /* field 12 is folded into the header */
  /* field 13 is folded into the header */
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'transported_by32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->transported_by32);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'carrying' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "carrying";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->carrying);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'movesleft' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "movesleft";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->movesleft);
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'fuel' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'activity_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->activity_count);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'changed_from_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->changed_from_count);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'goto_tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goto_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->goto_tile);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'activity_tgt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_tgt);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'changed_from' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'changed_from_tgt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->changed_from_tgt);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'battlegroup' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "battlegroup";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->battlegroup);
  }
  /* field 28 is folded into the header */
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'orders_length' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->orders_length);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'orders_index' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_index";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->orders_index);
  }
  /* field 31 is folded into the header */
  /* field 32 is folded into the header */
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'orders' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->orders_length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->orders_length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'action_decision_want' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_want";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_decision_want);
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  field 'action_decision_tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->action_decision_tile);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_UNIT_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationality";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->nationality);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->facing);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->homecity32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->upkeep[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ssa_controller";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ssa_controller);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paradropped";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->paradropped);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->occupied);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->transported);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "done_moving";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->done_moving);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stay";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->stay);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->transported_by32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "carrying";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->carrying);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "movesleft";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->movesleft);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->activity_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->changed_from_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goto_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->goto_tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_tgt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->changed_from_tgt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "battlegroup";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->battlegroup);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "has_orders";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->has_orders);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->orders_length);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_index";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->orders_index);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_repeat";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->orders_repeat);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_vigilant";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->orders_vigilant);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->orders_length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->orders_length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_want";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_decision_want);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->action_decision_tile);

#endif
  SEND_PACKET_END(PACKET_UNIT_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_unit_info_101(const void *vkey)
{
  const struct packet_unit_info *key = (const struct packet_unit_info *) vkey;

  return key->id16;
}

static bool cmp_packet_unit_info_101(const void *vkey1, const void *vkey2)
{
  const struct packet_unit_info *key1 = (const struct packet_unit_info *) vkey1;
  const struct packet_unit_info *key2 = (const struct packet_unit_info *) vkey2;

  return key1->id16 == key2->id16;
}
BV_DEFINE(packet_unit_info_101_fields, 35);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_info *receive_packet_unit_info_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_info_101_fields fields;
  struct packet_unit_info *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationality";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nationality)) {
    RECEIVE_PACKET_FIELD_ERROR(nationality);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(facing);
    }
    real_packet->facing = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->homecity16)) {
    RECEIVE_PACKET_FIELD_ERROR(homecity16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->upkeep[i])) {
        RECEIVE_PACKET_FIELD_ERROR(upkeep);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ssa_controller";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(ssa_controller);
    }
    real_packet->ssa_controller = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paradropped";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->paradropped)) {
    RECEIVE_PACKET_FIELD_ERROR(paradropped);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->occupied)) {
    RECEIVE_PACKET_FIELD_ERROR(occupied);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->transported)) {
    RECEIVE_PACKET_FIELD_ERROR(transported);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "done_moving";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->done_moving)) {
    RECEIVE_PACKET_FIELD_ERROR(done_moving);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stay";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->stay)) {
    RECEIVE_PACKET_FIELD_ERROR(stay);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->transported_by16)) {
    RECEIVE_PACKET_FIELD_ERROR(transported_by16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "carrying";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->carrying)) {
    RECEIVE_PACKET_FIELD_ERROR(carrying);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "movesleft";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->movesleft)) {
    RECEIVE_PACKET_FIELD_ERROR(movesleft);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
    RECEIVE_PACKET_FIELD_ERROR(hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
    RECEIVE_PACKET_FIELD_ERROR(fuel);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->activity_count)) {
    RECEIVE_PACKET_FIELD_ERROR(activity_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->changed_from_count)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goto_tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->goto_tile)) {
    RECEIVE_PACKET_FIELD_ERROR(goto_tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
    real_packet->activity = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->activity_tgt)) {
    RECEIVE_PACKET_FIELD_ERROR(activity_tgt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from);
    }
    real_packet->changed_from = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_tgt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->changed_from_tgt)) {
    RECEIVE_PACKET_FIELD_ERROR(changed_from_tgt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "battlegroup";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->battlegroup)) {
    RECEIVE_PACKET_FIELD_ERROR(battlegroup);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "has_orders";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->has_orders)) {
    RECEIVE_PACKET_FIELD_ERROR(has_orders);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_length";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->orders_length)) {
    RECEIVE_PACKET_FIELD_ERROR(orders_length);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_index";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->orders_index)) {
    RECEIVE_PACKET_FIELD_ERROR(orders_index);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_repeat";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->orders_repeat)) {
    RECEIVE_PACKET_FIELD_ERROR(orders_repeat);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_vigilant";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->orders_vigilant)) {
    RECEIVE_PACKET_FIELD_ERROR(orders_vigilant);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->orders_length > MAX_LEN_ROUTE) {
      RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
    }
    for (i = 0; i < real_packet->orders_length; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
        RECEIVE_PACKET_FIELD_ERROR(orders);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_want";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(action_decision_want);
    }
    real_packet->action_decision_want = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->action_decision_tile)) {
    RECEIVE_PACKET_FIELD_ERROR(action_decision_tile);
  }

#endif
  log_packet_detailed("packet_unit_info_101: got info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_info_101, cmp_packet_unit_info_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id16 = real_packet->id16;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id16 = id16;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'nationality'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nationality";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nationality)) {
      RECEIVE_PACKET_FIELD_ERROR(nationality);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'facing'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "facing";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(facing);
      }
      real_packet->facing = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'homecity16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "homecity16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->homecity16)) {
      RECEIVE_PACKET_FIELD_ERROR(homecity16);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'upkeep'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "upkeep";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->upkeep[i])) {
          RECEIVE_PACKET_FIELD_ERROR(upkeep);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'veteran'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
      RECEIVE_PACKET_FIELD_ERROR(veteran);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'ssa_controller'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ssa_controller";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(ssa_controller);
      }
      real_packet->ssa_controller = readin;
    }
  }
  real_packet->paradropped = BV_ISSET(fields, 8);
  real_packet->occupied = BV_ISSET(fields, 9);
  real_packet->transported = BV_ISSET(fields, 10);
  real_packet->done_moving = BV_ISSET(fields, 11);
  real_packet->stay = BV_ISSET(fields, 12);
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'transported_by16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "transported_by16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->transported_by16)) {
      RECEIVE_PACKET_FIELD_ERROR(transported_by16);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'carrying'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "carrying";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->carrying)) {
      RECEIVE_PACKET_FIELD_ERROR(carrying);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'movesleft'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "movesleft";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->movesleft)) {
      RECEIVE_PACKET_FIELD_ERROR(movesleft);
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
      RECEIVE_PACKET_FIELD_ERROR(hp);
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'fuel'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "fuel";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
      RECEIVE_PACKET_FIELD_ERROR(fuel);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'activity_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->activity_count)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_count);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'changed_from_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->changed_from_count)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_count);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'goto_tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "goto_tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->goto_tile)) {
      RECEIVE_PACKET_FIELD_ERROR(goto_tile);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity);
      }
      real_packet->activity = readin;
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'activity_tgt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_tgt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->activity_tgt)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_tgt);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'changed_from'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(changed_from);
      }
      real_packet->changed_from = readin;
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'changed_from_tgt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "changed_from_tgt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->changed_from_tgt)) {
      RECEIVE_PACKET_FIELD_ERROR(changed_from_tgt);
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'battlegroup'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "battlegroup";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->battlegroup)) {
      RECEIVE_PACKET_FIELD_ERROR(battlegroup);
    }
  }
  real_packet->has_orders = BV_ISSET(fields, 27);
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'orders_length'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders_length";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->orders_length)) {
      RECEIVE_PACKET_FIELD_ERROR(orders_length);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'orders_index'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders_index";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->orders_index)) {
      RECEIVE_PACKET_FIELD_ERROR(orders_index);
    }
  }
  real_packet->orders_repeat = BV_ISSET(fields, 30);
  real_packet->orders_vigilant = BV_ISSET(fields, 31);
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  got field 'orders'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->orders_length > MAX_LEN_ROUTE) {
        RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
      }
      for (i = 0; i < real_packet->orders_length; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
          RECEIVE_PACKET_FIELD_ERROR(orders);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'action_decision_want'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_decision_want";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(action_decision_want);
      }
      real_packet->action_decision_want = readin;
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'action_decision_tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_decision_tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->action_decision_tile)) {
      RECEIVE_PACKET_FIELD_ERROR(action_decision_tile);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_UNIT_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_info_101(struct connection *pc, const struct packet_unit_info *packet)
{
  const struct packet_unit_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_info_101_fields fields;
  struct packet_unit_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_info_101: sending info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_info_101, cmp_packet_unit_info_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->nationality != real_packet->nationality);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->facing != real_packet->facing);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->homecity16 != real_packet->homecity16);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->upkeep[i] != real_packet->upkeep[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->veteran != real_packet->veteran);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (old->ssa_controller != real_packet->ssa_controller);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }

  differ = (old->paradropped != real_packet->paradropped);
  if (differ) {
    different++;
  }
  if (packet->paradropped) {
    BV_SET(fields, 8);
  }

  differ = (old->occupied != real_packet->occupied);
  if (differ) {
    different++;
  }
  if (packet->occupied) {
    BV_SET(fields, 9);
  }

  differ = (old->transported != real_packet->transported);
  if (differ) {
    different++;
  }
  if (packet->transported) {
    BV_SET(fields, 10);
  }

  differ = (old->done_moving != real_packet->done_moving);
  if (differ) {
    different++;
  }
  if (packet->done_moving) {
    BV_SET(fields, 11);
  }

  differ = (old->stay != real_packet->stay);
  if (differ) {
    different++;
  }
  if (packet->stay) {
    BV_SET(fields, 12);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    different++;
    BV_SET(fields, 13);
  }

  differ = (old->transported_by16 != real_packet->transported_by16);
  if (differ) {
    different++;
    BV_SET(fields, 14);
  }

  differ = (old->carrying != real_packet->carrying);
  if (differ) {
    different++;
    BV_SET(fields, 15);
  }

  differ = (old->movesleft != real_packet->movesleft);
  if (differ) {
    different++;
    BV_SET(fields, 16);
  }

  differ = (old->hp != real_packet->hp);
  if (differ) {
    different++;
    BV_SET(fields, 17);
  }

  differ = (old->fuel != real_packet->fuel);
  if (differ) {
    different++;
    BV_SET(fields, 18);
  }

  differ = (old->activity_count != real_packet->activity_count);
  if (differ) {
    different++;
    BV_SET(fields, 19);
  }

  differ = (old->changed_from_count != real_packet->changed_from_count);
  if (differ) {
    different++;
    BV_SET(fields, 20);
  }

  differ = (old->goto_tile != real_packet->goto_tile);
  if (differ) {
    different++;
    BV_SET(fields, 21);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    different++;
    BV_SET(fields, 22);
  }

  differ = (old->activity_tgt != real_packet->activity_tgt);
  if (differ) {
    different++;
    BV_SET(fields, 23);
  }

  differ = (old->changed_from != real_packet->changed_from);
  if (differ) {
    different++;
    BV_SET(fields, 24);
  }

  differ = (old->changed_from_tgt != real_packet->changed_from_tgt);
  if (differ) {
    different++;
    BV_SET(fields, 25);
  }

  differ = (old->battlegroup != real_packet->battlegroup);
  if (differ) {
    different++;
    BV_SET(fields, 26);
  }

  differ = (old->has_orders != real_packet->has_orders);
  if (differ) {
    different++;
  }
  if (packet->has_orders) {
    BV_SET(fields, 27);
  }

  differ = (old->orders_length != real_packet->orders_length);
  if (differ) {
    different++;
    BV_SET(fields, 28);
  }

  differ = (old->orders_index != real_packet->orders_index);
  if (differ) {
    different++;
    BV_SET(fields, 29);
  }

  differ = (old->orders_repeat != real_packet->orders_repeat);
  if (differ) {
    different++;
  }
  if (packet->orders_repeat) {
    BV_SET(fields, 30);
  }

  differ = (old->orders_vigilant != real_packet->orders_vigilant);
  if (differ) {
    different++;
  }
  if (packet->orders_vigilant) {
    BV_SET(fields, 31);
  }


    {
      differ = (old->orders_length != real_packet->orders_length);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->orders_length; i++) {
          if (!are_unit_orders_equal(&old->orders[i], &real_packet->orders[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 32);
  }

  differ = (old->action_decision_want != real_packet->action_decision_want);
  if (differ) {
    different++;
    BV_SET(fields, 33);
  }

  differ = (old->action_decision_tile != real_packet->action_decision_tile);
  if (differ) {
    different++;
    BV_SET(fields, 34);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'nationality' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationality";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->nationality);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'facing' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->facing);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'homecity16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->homecity16);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'upkeep' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->upkeep[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'veteran' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'ssa_controller' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ssa_controller";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ssa_controller);
  }
  /* field 8 is folded into the header */
  /* field 9 is folded into the header */
  /* field 10 is folded into the header */
  /* field 11 is folded into the header */
  /* field 12 is folded into the header */
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'transported_by16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->transported_by16);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'carrying' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "carrying";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->carrying);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'movesleft' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "movesleft";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->movesleft);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'fuel' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'activity_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->activity_count);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'changed_from_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->changed_from_count);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'goto_tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goto_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->goto_tile);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'activity_tgt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_tgt);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'changed_from' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'changed_from_tgt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->changed_from_tgt);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'battlegroup' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "battlegroup";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->battlegroup);
  }
  /* field 27 is folded into the header */
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'orders_length' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->orders_length);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'orders_index' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_index";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->orders_index);
  }
  /* field 30 is folded into the header */
  /* field 31 is folded into the header */
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  field 'orders' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->orders_length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->orders_length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'action_decision_want' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_want";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_decision_want);
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'action_decision_tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->action_decision_tile);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_UNIT_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationality";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->nationality);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->facing);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->homecity16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->upkeep[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ssa_controller";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ssa_controller);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paradropped";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->paradropped);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->occupied);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->transported);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "done_moving";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->done_moving);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stay";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->stay);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->transported_by16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "carrying";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->carrying);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "movesleft";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->movesleft);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->activity_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->changed_from_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "goto_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->goto_tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_tgt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->changed_from);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "changed_from_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->changed_from_tgt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "battlegroup";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->battlegroup);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "has_orders";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->has_orders);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->orders_length);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_index";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->orders_index);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_repeat";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->orders_repeat);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders_vigilant";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->orders_vigilant);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->orders_length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->orders_length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_want";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_decision_want);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_decision_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->action_decision_tile);

#endif
  SEND_PACKET_END(PACKET_UNIT_INFO);
}

int send_packet_unit_info(struct connection *pc, const struct packet_unit_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_INFO].packet != NULL, -1,
                        "Handler for PACKET_UNIT_INFO not installed");
  return pc->phs.handlers->send[PACKET_UNIT_INFO].packet(pc, packet);
}

void lsend_packet_unit_info(struct conn_list *dest, const struct packet_unit_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_unit_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_short_info_100 hash_const

#define cmp_packet_unit_short_info_100 cmp_const

BV_DEFINE(packet_unit_short_info_100_fields, 14);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_short_info *receive_packet_unit_short_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_short_info_100_fields fields;
  struct packet_unit_short_info *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_SHORT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_short_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(facing);
    }
    real_packet->facing = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->occupied)) {
    RECEIVE_PACKET_FIELD_ERROR(occupied);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->transported)) {
    RECEIVE_PACKET_FIELD_ERROR(transported);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
    RECEIVE_PACKET_FIELD_ERROR(hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->activity)) {
    RECEIVE_PACKET_FIELD_ERROR(activity);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->activity_tgt)) {
    RECEIVE_PACKET_FIELD_ERROR(activity_tgt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->transported_by32)) {
    RECEIVE_PACKET_FIELD_ERROR(transported_by32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "packet_use";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->packet_use)) {
    RECEIVE_PACKET_FIELD_ERROR(packet_use);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "info_city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->info_city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(info_city_id32);
  }

#endif
  log_packet_detailed("packet_unit_short_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_short_info_100, cmp_packet_unit_short_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'facing'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "facing";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(facing);
      }
      real_packet->facing = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'veteran'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
      RECEIVE_PACKET_FIELD_ERROR(veteran);
    }
  }
  real_packet->occupied = BV_ISSET(fields, 6);
  real_packet->transported = BV_ISSET(fields, 7);
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
      RECEIVE_PACKET_FIELD_ERROR(hp);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->activity)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'activity_tgt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_tgt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->activity_tgt)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_tgt);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'transported_by32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "transported_by32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->transported_by32)) {
      RECEIVE_PACKET_FIELD_ERROR(transported_by32);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'packet_use'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "packet_use";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->packet_use)) {
      RECEIVE_PACKET_FIELD_ERROR(packet_use);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'info_city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "info_city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->info_city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(info_city_id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_UNIT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_short_info_100(struct connection *pc, const struct packet_unit_short_info *packet, bool force_to_send)
{
  const struct packet_unit_short_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_short_info_100_fields fields;
  struct packet_unit_short_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_SHORT_INFO;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_SHORT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_short_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_short_info_100, cmp_packet_unit_short_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->facing != real_packet->facing);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->veteran != real_packet->veteran);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->occupied != real_packet->occupied);
  if (differ) {
    different++;
  }
  if (packet->occupied) {
    BV_SET(fields, 6);
  }

  differ = (old->transported != real_packet->transported);
  if (differ) {
    different++;
  }
  if (packet->transported) {
    BV_SET(fields, 7);
  }

  differ = (old->hp != real_packet->hp);
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }

  differ = (old->activity_tgt != real_packet->activity_tgt);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (old->transported_by32 != real_packet->transported_by32);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }

  differ = (old->packet_use != real_packet->packet_use);
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }

  differ = (old->info_city_id32 != real_packet->info_city_id32);
  if (differ) {
    different++;
    BV_SET(fields, 13);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'facing' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->facing);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'veteran' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
  }
  /* field 6 is folded into the header */
  /* field 7 is folded into the header */
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'activity_tgt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_tgt);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'transported_by32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->transported_by32);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'packet_use' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "packet_use";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->packet_use);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'info_city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "info_city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->info_city_id32);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_UNIT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->facing);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->occupied);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->transported);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_tgt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->transported_by32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "packet_use";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->packet_use);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "info_city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->info_city_id32);

#endif
  SEND_PACKET_END(PACKET_UNIT_SHORT_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_unit_short_info_101(const void *vkey)
{
  const struct packet_unit_short_info *key = (const struct packet_unit_short_info *) vkey;

  return key->id16;
}

static bool cmp_packet_unit_short_info_101(const void *vkey1, const void *vkey2)
{
  const struct packet_unit_short_info *key1 = (const struct packet_unit_short_info *) vkey1;
  const struct packet_unit_short_info *key2 = (const struct packet_unit_short_info *) vkey2;

  return key1->id16 == key2->id16;
}
BV_DEFINE(packet_unit_short_info_101_fields, 13);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_short_info *receive_packet_unit_short_info_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_short_info_101_fields fields;
  struct packet_unit_short_info *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_SHORT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_short_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(facing);
    }
    real_packet->facing = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->occupied)) {
    RECEIVE_PACKET_FIELD_ERROR(occupied);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->transported)) {
    RECEIVE_PACKET_FIELD_ERROR(transported);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
    RECEIVE_PACKET_FIELD_ERROR(hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->activity)) {
    RECEIVE_PACKET_FIELD_ERROR(activity);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->activity_tgt)) {
    RECEIVE_PACKET_FIELD_ERROR(activity_tgt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->transported_by16)) {
    RECEIVE_PACKET_FIELD_ERROR(transported_by16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "packet_use";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->packet_use)) {
    RECEIVE_PACKET_FIELD_ERROR(packet_use);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "info_city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->info_city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(info_city_id16);
  }

#endif
  log_packet_detailed("packet_unit_short_info_101: got info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_short_info_101, cmp_packet_unit_short_info_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id16 = real_packet->id16;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id16 = id16;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'facing'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "facing";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(facing);
      }
      real_packet->facing = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'veteran'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
      RECEIVE_PACKET_FIELD_ERROR(veteran);
    }
  }
  real_packet->occupied = BV_ISSET(fields, 5);
  real_packet->transported = BV_ISSET(fields, 6);
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
      RECEIVE_PACKET_FIELD_ERROR(hp);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->activity)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'activity_tgt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_tgt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->activity_tgt)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_tgt);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'transported_by16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "transported_by16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->transported_by16)) {
      RECEIVE_PACKET_FIELD_ERROR(transported_by16);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'packet_use'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "packet_use";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->packet_use)) {
      RECEIVE_PACKET_FIELD_ERROR(packet_use);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'info_city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "info_city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->info_city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(info_city_id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_UNIT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_short_info_101(struct connection *pc, const struct packet_unit_short_info *packet, bool force_to_send)
{
  const struct packet_unit_short_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_short_info_101_fields fields;
  struct packet_unit_short_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_SHORT_INFO;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_SHORT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_short_info_101: sending info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_short_info_101, cmp_packet_unit_short_info_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->owner != real_packet->owner);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->facing != real_packet->facing);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->veteran != real_packet->veteran);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->occupied != real_packet->occupied);
  if (differ) {
    different++;
  }
  if (packet->occupied) {
    BV_SET(fields, 5);
  }

  differ = (old->transported != real_packet->transported);
  if (differ) {
    different++;
  }
  if (packet->transported) {
    BV_SET(fields, 6);
  }

  differ = (old->hp != real_packet->hp);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }

  differ = (old->activity_tgt != real_packet->activity_tgt);
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }

  differ = (old->transported_by16 != real_packet->transported_by16);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (old->packet_use != real_packet->packet_use);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }

  differ = (old->info_city_id16 != real_packet->info_city_id16);
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'facing' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->facing);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'veteran' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
  }
  /* field 5 is folded into the header */
  /* field 6 is folded into the header */
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'activity_tgt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_tgt);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'transported_by16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->transported_by16);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'packet_use' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "packet_use";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->packet_use);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'info_city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "info_city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->info_city_id16);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_UNIT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "facing";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->facing);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "occupied";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->occupied);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->transported);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_tgt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_tgt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->transported_by16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "packet_use";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->packet_use);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "info_city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->info_city_id16);

#endif
  SEND_PACKET_END(PACKET_UNIT_SHORT_INFO);
}

int send_packet_unit_short_info(struct connection *pc, const struct packet_unit_short_info *packet, bool force_to_send)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_SHORT_INFO].force_to_send != NULL, -1,
                        "Handler for PACKET_UNIT_SHORT_INFO not installed");
  return pc->phs.handlers->send[PACKET_UNIT_SHORT_INFO].force_to_send(pc, packet, force_to_send);
}

void lsend_packet_unit_short_info(struct conn_list *dest, const struct packet_unit_short_info *packet, bool force_to_send)
{
  conn_list_iterate(dest, pconn) {
    send_packet_unit_short_info(pconn, packet, force_to_send);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_combat_info_100 hash_const

#define cmp_packet_unit_combat_info_100 cmp_const

BV_DEFINE(packet_unit_combat_info_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_combat_info *receive_packet_unit_combat_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_combat_info_100_fields fields;
  struct packet_unit_combat_info *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_COMBAT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_combat_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->attacker_unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(attacker_unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->defender_unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(defender_unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->attacker_hp)) {
    RECEIVE_PACKET_FIELD_ERROR(attacker_hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->defender_hp)) {
    RECEIVE_PACKET_FIELD_ERROR(defender_hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "make_att_veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->make_att_veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(make_att_veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "make_def_veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->make_def_veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(make_def_veteran);
  }

#endif
  log_packet_detailed("packet_unit_combat_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_combat_info_100, cmp_packet_unit_combat_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'attacker_unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "attacker_unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->attacker_unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(attacker_unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'defender_unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "defender_unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->defender_unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(defender_unit_id32);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'attacker_hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "attacker_hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->attacker_hp)) {
      RECEIVE_PACKET_FIELD_ERROR(attacker_hp);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'defender_hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "defender_hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->defender_hp)) {
      RECEIVE_PACKET_FIELD_ERROR(defender_hp);
    }
  }
  real_packet->make_att_veteran = BV_ISSET(fields, 4);
  real_packet->make_def_veteran = BV_ISSET(fields, 5);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_combat_info_100(struct connection *pc, const struct packet_unit_combat_info *packet)
{
  const struct packet_unit_combat_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_combat_info_100_fields fields;
  struct packet_unit_combat_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_COMBAT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_COMBAT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_combat_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_combat_info_100, cmp_packet_unit_combat_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->attacker_unit_id32 != real_packet->attacker_unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->defender_unit_id32 != real_packet->defender_unit_id32);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->attacker_hp != real_packet->attacker_hp);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->defender_hp != real_packet->defender_hp);
  if (differ) {
    BV_SET(fields, 3);
  }

  if (packet->make_att_veteran) {
    BV_SET(fields, 4);
  }

  if (packet->make_def_veteran) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'attacker_unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->attacker_unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'defender_unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->defender_unit_id32);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'attacker_hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->attacker_hp);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'defender_hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->defender_hp);
  }
  /* field 4 is folded into the header */
  /* field 5 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->attacker_unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->defender_unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->attacker_hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->defender_hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "make_att_veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->make_att_veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "make_def_veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->make_def_veteran);

#endif
  SEND_PACKET_END(PACKET_UNIT_COMBAT_INFO);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_combat_info_101 hash_const

#define cmp_packet_unit_combat_info_101 cmp_const

BV_DEFINE(packet_unit_combat_info_101_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_combat_info *receive_packet_unit_combat_info_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_combat_info_101_fields fields;
  struct packet_unit_combat_info *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_COMBAT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_combat_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->attacker_unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(attacker_unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->defender_unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(defender_unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->attacker_hp)) {
    RECEIVE_PACKET_FIELD_ERROR(attacker_hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->defender_hp)) {
    RECEIVE_PACKET_FIELD_ERROR(defender_hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "make_att_veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->make_att_veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(make_att_veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "make_def_veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->make_def_veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(make_def_veteran);
  }

#endif
  log_packet_detailed("packet_unit_combat_info_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_combat_info_101, cmp_packet_unit_combat_info_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'attacker_unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "attacker_unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->attacker_unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(attacker_unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'defender_unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "defender_unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->defender_unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(defender_unit_id16);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'attacker_hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "attacker_hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->attacker_hp)) {
      RECEIVE_PACKET_FIELD_ERROR(attacker_hp);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'defender_hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "defender_hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->defender_hp)) {
      RECEIVE_PACKET_FIELD_ERROR(defender_hp);
    }
  }
  real_packet->make_att_veteran = BV_ISSET(fields, 4);
  real_packet->make_def_veteran = BV_ISSET(fields, 5);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_combat_info_101(struct connection *pc, const struct packet_unit_combat_info *packet)
{
  const struct packet_unit_combat_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_combat_info_101_fields fields;
  struct packet_unit_combat_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_COMBAT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_COMBAT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_combat_info_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_combat_info_101, cmp_packet_unit_combat_info_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->attacker_unit_id16 != real_packet->attacker_unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->defender_unit_id16 != real_packet->defender_unit_id16);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->attacker_hp != real_packet->attacker_hp);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->defender_hp != real_packet->defender_hp);
  if (differ) {
    BV_SET(fields, 3);
  }

  if (packet->make_att_veteran) {
    BV_SET(fields, 4);
  }

  if (packet->make_def_veteran) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'attacker_unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->attacker_unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'defender_unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->defender_unit_id16);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'attacker_hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->attacker_hp);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'defender_hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->defender_hp);
  }
  /* field 4 is folded into the header */
  /* field 5 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->attacker_unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->defender_unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attacker_hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->attacker_hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defender_hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->defender_hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "make_att_veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->make_att_veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "make_def_veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->make_def_veteran);

#endif
  SEND_PACKET_END(PACKET_UNIT_COMBAT_INFO);
}

int send_packet_unit_combat_info(struct connection *pc, const struct packet_unit_combat_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_COMBAT_INFO].packet != NULL, -1,
                        "Handler for PACKET_UNIT_COMBAT_INFO not installed");
  return pc->phs.handlers->send[PACKET_UNIT_COMBAT_INFO].packet(pc, packet);
}

void lsend_packet_unit_combat_info(struct conn_list *dest, const struct packet_unit_combat_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_unit_combat_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_sscs_set_100 hash_const

#define cmp_packet_unit_sscs_set_100 cmp_const

BV_DEFINE(packet_unit_sscs_set_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_sscs_set *receive_packet_unit_sscs_set_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_sscs_set_100_fields fields;
  struct packet_unit_sscs_set *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_SSCS_SET;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_sscs_set, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }

#endif
  log_packet_detailed("packet_unit_sscs_set_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_sscs_set_100, cmp_packet_unit_sscs_set_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_sscs_set_100(struct connection *pc, const struct packet_unit_sscs_set *packet)
{
  const struct packet_unit_sscs_set *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_sscs_set_100_fields fields;
  struct packet_unit_sscs_set *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_SSCS_SET;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_SSCS_SET);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_sscs_set_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_sscs_set_100, cmp_packet_unit_sscs_set_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id32 != real_packet->unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->value);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->value);

#endif
  SEND_PACKET_END(PACKET_UNIT_SSCS_SET);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_sscs_set_101 hash_const

#define cmp_packet_unit_sscs_set_101 cmp_const

BV_DEFINE(packet_unit_sscs_set_101_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_sscs_set *receive_packet_unit_sscs_set_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_sscs_set_101_fields fields;
  struct packet_unit_sscs_set *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_SSCS_SET;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_sscs_set, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }

#endif
  log_packet_detailed("packet_unit_sscs_set_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_sscs_set_101, cmp_packet_unit_sscs_set_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_sscs_set_101(struct connection *pc, const struct packet_unit_sscs_set *packet)
{
  const struct packet_unit_sscs_set *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_sscs_set_101_fields fields;
  struct packet_unit_sscs_set *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_SSCS_SET;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_SSCS_SET);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_sscs_set_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_sscs_set_101, cmp_packet_unit_sscs_set_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id16 != real_packet->unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->value);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->value);

#endif
  SEND_PACKET_END(PACKET_UNIT_SSCS_SET);
}

int send_packet_unit_sscs_set(struct connection *pc, const struct packet_unit_sscs_set *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_SSCS_SET].packet != NULL, -1,
                        "Handler for PACKET_UNIT_SSCS_SET not installed");
  return pc->phs.handlers->send[PACKET_UNIT_SSCS_SET].packet(pc, packet);
}

int dsend_packet_unit_sscs_set(struct connection *pc, int unit_id16, int unit_id32, enum unit_ss_data_type type, int value)
{
  struct packet_unit_sscs_set packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  real_packet->type = type;
  real_packet->value = value;
  
  return send_packet_unit_sscs_set(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_orders_100 hash_const

#define cmp_packet_unit_orders_100 cmp_const

BV_DEFINE(packet_unit_orders_100_fields, 7);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_orders *receive_packet_unit_orders_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_orders_100_fields fields;
  struct packet_unit_orders *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_ORDERS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_orders, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "src_tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->src_tile)) {
    RECEIVE_PACKET_FIELD_ERROR(src_tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->length)) {
    RECEIVE_PACKET_FIELD_ERROR(length);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "repeat";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->repeat)) {
    RECEIVE_PACKET_FIELD_ERROR(repeat);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vigilant";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->vigilant)) {
    RECEIVE_PACKET_FIELD_ERROR(vigilant);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->length > MAX_LEN_ROUTE) {
      RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
    }
    for (i = 0; i < real_packet->length; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
        RECEIVE_PACKET_FIELD_ERROR(orders);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "dest_tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->dest_tile)) {
    RECEIVE_PACKET_FIELD_ERROR(dest_tile);
  }

#endif
  log_packet_detailed("packet_unit_orders_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_orders_100, cmp_packet_unit_orders_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'src_tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "src_tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->src_tile)) {
      RECEIVE_PACKET_FIELD_ERROR(src_tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'length'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "length";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->length)) {
      RECEIVE_PACKET_FIELD_ERROR(length);
    }
  }
  real_packet->repeat = BV_ISSET(fields, 3);
  real_packet->vigilant = BV_ISSET(fields, 4);
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'orders'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->length > MAX_LEN_ROUTE) {
        RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
      }
      for (i = 0; i < real_packet->length; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
          RECEIVE_PACKET_FIELD_ERROR(orders);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'dest_tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "dest_tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->dest_tile)) {
      RECEIVE_PACKET_FIELD_ERROR(dest_tile);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_orders_100(struct connection *pc, const struct packet_unit_orders *packet)
{
  const struct packet_unit_orders *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_orders_100_fields fields;
  struct packet_unit_orders *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_ORDERS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_ORDERS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_orders_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_orders_100, cmp_packet_unit_orders_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id32 != real_packet->unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->src_tile != real_packet->src_tile);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->length != real_packet->length);
  if (differ) {
    BV_SET(fields, 2);
  }

  if (packet->repeat) {
    BV_SET(fields, 3);
  }

  if (packet->vigilant) {
    BV_SET(fields, 4);
  }


    {
      differ = (old->length != real_packet->length);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->length; i++) {
          if (!are_unit_orders_equal(&old->orders[i], &real_packet->orders[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->dest_tile != real_packet->dest_tile);
  if (differ) {
    BV_SET(fields, 6);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'src_tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "src_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->src_tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'length' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->length);
  }
  /* field 3 is folded into the header */
  /* field 4 is folded into the header */
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'orders' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'dest_tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "dest_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->dest_tile);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "src_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->src_tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->length);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "repeat";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->repeat);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vigilant";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->vigilant);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "dest_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->dest_tile);

#endif
  SEND_PACKET_END(PACKET_UNIT_ORDERS);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_orders_101 hash_const

#define cmp_packet_unit_orders_101 cmp_const

BV_DEFINE(packet_unit_orders_101_fields, 7);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_orders *receive_packet_unit_orders_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_orders_101_fields fields;
  struct packet_unit_orders *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_ORDERS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_orders, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "src_tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->src_tile)) {
    RECEIVE_PACKET_FIELD_ERROR(src_tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->length)) {
    RECEIVE_PACKET_FIELD_ERROR(length);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "repeat";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->repeat)) {
    RECEIVE_PACKET_FIELD_ERROR(repeat);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vigilant";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->vigilant)) {
    RECEIVE_PACKET_FIELD_ERROR(vigilant);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->length > MAX_LEN_ROUTE) {
      RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
    }
    for (i = 0; i < real_packet->length; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
        RECEIVE_PACKET_FIELD_ERROR(orders);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "dest_tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->dest_tile)) {
    RECEIVE_PACKET_FIELD_ERROR(dest_tile);
  }

#endif
  log_packet_detailed("packet_unit_orders_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_orders_101, cmp_packet_unit_orders_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'src_tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "src_tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->src_tile)) {
      RECEIVE_PACKET_FIELD_ERROR(src_tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'length'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "length";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->length)) {
      RECEIVE_PACKET_FIELD_ERROR(length);
    }
  }
  real_packet->repeat = BV_ISSET(fields, 3);
  real_packet->vigilant = BV_ISSET(fields, 4);
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'orders'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "orders";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->length > MAX_LEN_ROUTE) {
        RECEIVE_PACKET_FIELD_ERROR(orders, ": truncation array");
      }
      for (i = 0; i < real_packet->length; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(unit_order, &din, &field_addr, &real_packet->orders[i])) {
          RECEIVE_PACKET_FIELD_ERROR(orders);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'dest_tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "dest_tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->dest_tile)) {
      RECEIVE_PACKET_FIELD_ERROR(dest_tile);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_orders_101(struct connection *pc, const struct packet_unit_orders *packet)
{
  const struct packet_unit_orders *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_orders_101_fields fields;
  struct packet_unit_orders *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_ORDERS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_ORDERS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_orders_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_orders_101, cmp_packet_unit_orders_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id16 != real_packet->unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->src_tile != real_packet->src_tile);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->length != real_packet->length);
  if (differ) {
    BV_SET(fields, 2);
  }

  if (packet->repeat) {
    BV_SET(fields, 3);
  }

  if (packet->vigilant) {
    BV_SET(fields, 4);
  }


    {
      differ = (old->length != real_packet->length);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->length; i++) {
          if (!are_unit_orders_equal(&old->orders[i], &real_packet->orders[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->dest_tile != real_packet->dest_tile);
  if (differ) {
    BV_SET(fields, 6);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'src_tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "src_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->src_tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'length' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->length);
  }
  /* field 3 is folded into the header */
  /* field 4 is folded into the header */
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'orders' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'dest_tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "dest_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->dest_tile);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "src_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->src_tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "length";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->length);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "repeat";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->repeat);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vigilant";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->vigilant);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "orders";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->length);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->length; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(unit_order, &dout, &field_addr, &real_packet->orders[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "dest_tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->dest_tile);

#endif
  SEND_PACKET_END(PACKET_UNIT_ORDERS);
}

int send_packet_unit_orders(struct connection *pc, const struct packet_unit_orders *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_ORDERS].packet != NULL, -1,
                        "Handler for PACKET_UNIT_ORDERS not installed");
  return pc->phs.handlers->send[PACKET_UNIT_ORDERS].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_server_side_agent_set_100 hash_const

#define cmp_packet_unit_server_side_agent_set_100 cmp_const

BV_DEFINE(packet_unit_server_side_agent_set_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_server_side_agent_set *receive_packet_unit_server_side_agent_set_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_server_side_agent_set_100_fields fields;
  struct packet_unit_server_side_agent_set *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_SERVER_SIDE_AGENT_SET;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_server_side_agent_set, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "agent";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(agent);
    }
    real_packet->agent = readin;
  }

#endif
  log_packet_detailed("packet_unit_server_side_agent_set_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_server_side_agent_set_100, cmp_packet_unit_server_side_agent_set_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'agent'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "agent";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(agent);
      }
      real_packet->agent = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_server_side_agent_set_100(struct connection *pc, const struct packet_unit_server_side_agent_set *packet)
{
  const struct packet_unit_server_side_agent_set *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_server_side_agent_set_100_fields fields;
  struct packet_unit_server_side_agent_set *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_SERVER_SIDE_AGENT_SET;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_SERVER_SIDE_AGENT_SET);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_server_side_agent_set_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_server_side_agent_set_100, cmp_packet_unit_server_side_agent_set_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id32 != real_packet->unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->agent != real_packet->agent);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'agent' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "agent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->agent);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "agent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->agent);

#endif
  SEND_PACKET_END(PACKET_UNIT_SERVER_SIDE_AGENT_SET);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_server_side_agent_set_101 hash_const

#define cmp_packet_unit_server_side_agent_set_101 cmp_const

BV_DEFINE(packet_unit_server_side_agent_set_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_server_side_agent_set *receive_packet_unit_server_side_agent_set_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_server_side_agent_set_101_fields fields;
  struct packet_unit_server_side_agent_set *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_SERVER_SIDE_AGENT_SET;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_server_side_agent_set, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "agent";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(agent);
    }
    real_packet->agent = readin;
  }

#endif
  log_packet_detailed("packet_unit_server_side_agent_set_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_server_side_agent_set_101, cmp_packet_unit_server_side_agent_set_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'agent'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "agent";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(agent);
      }
      real_packet->agent = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_server_side_agent_set_101(struct connection *pc, const struct packet_unit_server_side_agent_set *packet)
{
  const struct packet_unit_server_side_agent_set *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_server_side_agent_set_101_fields fields;
  struct packet_unit_server_side_agent_set *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_SERVER_SIDE_AGENT_SET;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_SERVER_SIDE_AGENT_SET);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_server_side_agent_set_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_server_side_agent_set_101, cmp_packet_unit_server_side_agent_set_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id16 != real_packet->unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->agent != real_packet->agent);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'agent' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "agent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->agent);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "agent";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->agent);

#endif
  SEND_PACKET_END(PACKET_UNIT_SERVER_SIDE_AGENT_SET);
}

int send_packet_unit_server_side_agent_set(struct connection *pc, const struct packet_unit_server_side_agent_set *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_SERVER_SIDE_AGENT_SET].packet != NULL, -1,
                        "Handler for PACKET_UNIT_SERVER_SIDE_AGENT_SET not installed");
  return pc->phs.handlers->send[PACKET_UNIT_SERVER_SIDE_AGENT_SET].packet(pc, packet);
}

int dsend_packet_unit_server_side_agent_set(struct connection *pc, int unit_id16, int unit_id32, enum server_side_agent agent)
{
  struct packet_unit_server_side_agent_set packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  real_packet->agent = agent;
  
  return send_packet_unit_server_side_agent_set(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_action_query_100 hash_const

#define cmp_packet_unit_action_query_100 cmp_const

BV_DEFINE(packet_unit_action_query_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_action_query *receive_packet_unit_action_query_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_action_query_100_fields fields;
  struct packet_unit_action_query *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_ACTION_QUERY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_action_query, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(action_type);
    }
    real_packet->action_type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }

#endif
  log_packet_detailed("packet_unit_action_query_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_action_query_100, cmp_packet_unit_action_query_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_id);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'action_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(action_type);
      }
      real_packet->action_type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_action_query_100(struct connection *pc, const struct packet_unit_action_query *packet)
{
  const struct packet_unit_action_query *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_action_query_100_fields fields;
  struct packet_unit_action_query *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_ACTION_QUERY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_ACTION_QUERY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_action_query_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_action_query_100, cmp_packet_unit_action_query_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_id32 != real_packet->actor_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_id != real_packet->target_id);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->action_type != real_packet->action_type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'action_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);

#endif
  SEND_PACKET_END(PACKET_UNIT_ACTION_QUERY);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_action_query_101 hash_const

#define cmp_packet_unit_action_query_101 cmp_const

BV_DEFINE(packet_unit_action_query_101_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_action_query *receive_packet_unit_action_query_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_action_query_101_fields fields;
  struct packet_unit_action_query *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_ACTION_QUERY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_action_query, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(action_type);
    }
    real_packet->action_type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }

#endif
  log_packet_detailed("packet_unit_action_query_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_action_query_101, cmp_packet_unit_action_query_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_id);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'action_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(action_type);
      }
      real_packet->action_type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_action_query_101(struct connection *pc, const struct packet_unit_action_query *packet)
{
  const struct packet_unit_action_query *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_action_query_101_fields fields;
  struct packet_unit_action_query *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_ACTION_QUERY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_ACTION_QUERY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_action_query_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_action_query_101, cmp_packet_unit_action_query_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_id16 != real_packet->actor_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_id != real_packet->target_id);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->action_type != real_packet->action_type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'action_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);

#endif
  SEND_PACKET_END(PACKET_UNIT_ACTION_QUERY);
}

int send_packet_unit_action_query(struct connection *pc, const struct packet_unit_action_query *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_ACTION_QUERY].packet != NULL, -1,
                        "Handler for PACKET_UNIT_ACTION_QUERY not installed");
  return pc->phs.handlers->send[PACKET_UNIT_ACTION_QUERY].packet(pc, packet);
}

int dsend_packet_unit_action_query(struct connection *pc, int actor_id16, int actor_id32, int target_id, action_id action_type, int request_kind)
{
  struct packet_unit_action_query packet, *real_packet = &packet;

  real_packet->actor_id16 = actor_id16;
  real_packet->actor_id32 = actor_id32;
  real_packet->target_id = target_id;
  real_packet->action_type = action_type;
  real_packet->request_kind = request_kind;
  
  return send_packet_unit_action_query(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_type_upgrade_100 hash_const

#define cmp_packet_unit_type_upgrade_100 cmp_const

BV_DEFINE(packet_unit_type_upgrade_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_type_upgrade *receive_packet_unit_type_upgrade_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_type_upgrade_100_fields fields;
  struct packet_unit_type_upgrade *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_TYPE_UPGRADE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_type_upgrade, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }

#endif
  log_packet_detailed("packet_unit_type_upgrade_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_type_upgrade_100, cmp_packet_unit_type_upgrade_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_type_upgrade_100(struct connection *pc, const struct packet_unit_type_upgrade *packet)
{
  const struct packet_unit_type_upgrade *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_type_upgrade_100_fields fields;
  struct packet_unit_type_upgrade *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_TYPE_UPGRADE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_TYPE_UPGRADE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_type_upgrade_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_type_upgrade_100, cmp_packet_unit_type_upgrade_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);

#endif
  SEND_PACKET_END(PACKET_UNIT_TYPE_UPGRADE);
}

int send_packet_unit_type_upgrade(struct connection *pc, const struct packet_unit_type_upgrade *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_TYPE_UPGRADE].packet != NULL, -1,
                        "Handler for PACKET_UNIT_TYPE_UPGRADE not installed");
  return pc->phs.handlers->send[PACKET_UNIT_TYPE_UPGRADE].packet(pc, packet);
}

int dsend_packet_unit_type_upgrade(struct connection *pc, Unit_type_id type)
{
  struct packet_unit_type_upgrade packet, *real_packet = &packet;

  real_packet->type = type;
  
  return send_packet_unit_type_upgrade(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_do_action_100 hash_const

#define cmp_packet_unit_do_action_100 cmp_const

BV_DEFINE(packet_unit_do_action_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_do_action *receive_packet_unit_do_action_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_do_action_100_fields fields;
  struct packet_unit_do_action *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_DO_ACTION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_do_action, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_tgt_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->sub_tgt_id)) {
    RECEIVE_PACKET_FIELD_ERROR(sub_tgt_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(action_type);
    }
    real_packet->action_type = readin;
  }

#endif
  log_packet_detailed("packet_unit_do_action_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_do_action_100, cmp_packet_unit_do_action_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_id);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'sub_tgt_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sub_tgt_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->sub_tgt_id)) {
      RECEIVE_PACKET_FIELD_ERROR(sub_tgt_id);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'action_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(action_type);
      }
      real_packet->action_type = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_do_action_100(struct connection *pc, const struct packet_unit_do_action *packet)
{
  const struct packet_unit_do_action *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_do_action_100_fields fields;
  struct packet_unit_do_action *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_DO_ACTION;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_DO_ACTION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_do_action_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_do_action_100, cmp_packet_unit_do_action_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_id32 != real_packet->actor_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_id != real_packet->target_id);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->sub_tgt_id != real_packet->sub_tgt_id);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->action_type != real_packet->action_type);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'sub_tgt_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_tgt_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->sub_tgt_id);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'action_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_tgt_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->sub_tgt_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);

#endif
  SEND_PACKET_END(PACKET_UNIT_DO_ACTION);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_do_action_101 hash_const

#define cmp_packet_unit_do_action_101 cmp_const

BV_DEFINE(packet_unit_do_action_101_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_do_action *receive_packet_unit_do_action_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_do_action_101_fields fields;
  struct packet_unit_do_action *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_DO_ACTION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_do_action, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_tgt_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->sub_tgt_id)) {
    RECEIVE_PACKET_FIELD_ERROR(sub_tgt_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(action_type);
    }
    real_packet->action_type = readin;
  }

#endif
  log_packet_detailed("packet_unit_do_action_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_do_action_101, cmp_packet_unit_do_action_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_id);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'sub_tgt_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sub_tgt_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->sub_tgt_id)) {
      RECEIVE_PACKET_FIELD_ERROR(sub_tgt_id);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'action_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(action_type);
      }
      real_packet->action_type = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_do_action_101(struct connection *pc, const struct packet_unit_do_action *packet)
{
  const struct packet_unit_do_action *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_do_action_101_fields fields;
  struct packet_unit_do_action *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_DO_ACTION;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_DO_ACTION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_do_action_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_do_action_101, cmp_packet_unit_do_action_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_id16 != real_packet->actor_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_id != real_packet->target_id);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->sub_tgt_id != real_packet->sub_tgt_id);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->action_type != real_packet->action_type);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'sub_tgt_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_tgt_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->sub_tgt_id);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'action_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_tgt_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->sub_tgt_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);

#endif
  SEND_PACKET_END(PACKET_UNIT_DO_ACTION);
}

int send_packet_unit_do_action(struct connection *pc, const struct packet_unit_do_action *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_DO_ACTION].packet != NULL, -1,
                        "Handler for PACKET_UNIT_DO_ACTION not installed");
  return pc->phs.handlers->send[PACKET_UNIT_DO_ACTION].packet(pc, packet);
}

int dsend_packet_unit_do_action(struct connection *pc, int actor_id16, int actor_id32, int target_id, int sub_tgt_id, const char *name, action_id action_type)
{
  struct packet_unit_do_action packet, *real_packet = &packet;

  real_packet->actor_id16 = actor_id16;
  real_packet->actor_id32 = actor_id32;
  real_packet->target_id = target_id;
  real_packet->sub_tgt_id = sub_tgt_id;
  sz_strlcpy(real_packet->name, name);
  real_packet->action_type = action_type;
  
  return send_packet_unit_do_action(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_action_answer_100 hash_const

#define cmp_packet_unit_action_answer_100 cmp_const

BV_DEFINE(packet_unit_action_answer_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_action_answer *receive_packet_unit_action_answer_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_action_answer_100_fields fields;
  struct packet_unit_action_answer *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_ACTION_ANSWER;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_action_answer, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->cost)) {
    RECEIVE_PACKET_FIELD_ERROR(cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(action_type);
    }
    real_packet->action_type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }

#endif
  log_packet_detailed("packet_unit_action_answer_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_action_answer_100, cmp_packet_unit_action_answer_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_id);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->cost)) {
      RECEIVE_PACKET_FIELD_ERROR(cost);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'action_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(action_type);
      }
      real_packet->action_type = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_action_answer_100(struct connection *pc, const struct packet_unit_action_answer *packet)
{
  const struct packet_unit_action_answer *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_action_answer_100_fields fields;
  struct packet_unit_action_answer *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_ACTION_ANSWER;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_ACTION_ANSWER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_action_answer_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_action_answer_100, cmp_packet_unit_action_answer_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_id32 != real_packet->actor_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_id != real_packet->target_id);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->cost != real_packet->cost);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->action_type != real_packet->action_type);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->cost);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'action_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);

#endif
  SEND_PACKET_END(PACKET_UNIT_ACTION_ANSWER);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_action_answer_101 hash_const

#define cmp_packet_unit_action_answer_101 cmp_const

BV_DEFINE(packet_unit_action_answer_101_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_action_answer *receive_packet_unit_action_answer_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_action_answer_101_fields fields;
  struct packet_unit_action_answer *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_ACTION_ANSWER;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_action_answer, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->cost)) {
    RECEIVE_PACKET_FIELD_ERROR(cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(action_type);
    }
    real_packet->action_type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }

#endif
  log_packet_detailed("packet_unit_action_answer_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_action_answer_101, cmp_packet_unit_action_answer_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_id);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->cost)) {
      RECEIVE_PACKET_FIELD_ERROR(cost);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'action_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(action_type);
      }
      real_packet->action_type = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_action_answer_101(struct connection *pc, const struct packet_unit_action_answer *packet)
{
  const struct packet_unit_action_answer *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_action_answer_101_fields fields;
  struct packet_unit_action_answer *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_ACTION_ANSWER;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_ACTION_ANSWER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_action_answer_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_action_answer_101, cmp_packet_unit_action_answer_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_id16 != real_packet->actor_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_id != real_packet->target_id);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->cost != real_packet->cost);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->action_type != real_packet->action_type);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->cost);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'action_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->action_type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);

#endif
  SEND_PACKET_END(PACKET_UNIT_ACTION_ANSWER);
}

int send_packet_unit_action_answer(struct connection *pc, const struct packet_unit_action_answer *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_ACTION_ANSWER].packet != NULL, -1,
                        "Handler for PACKET_UNIT_ACTION_ANSWER not installed");
  return pc->phs.handlers->send[PACKET_UNIT_ACTION_ANSWER].packet(pc, packet);
}

int dsend_packet_unit_action_answer(struct connection *pc, int actor_id16, int actor_id32, int target_id, int cost, action_id action_type, int request_kind)
{
  struct packet_unit_action_answer packet, *real_packet = &packet;

  real_packet->actor_id16 = actor_id16;
  real_packet->actor_id32 = actor_id32;
  real_packet->target_id = target_id;
  real_packet->cost = cost;
  real_packet->action_type = action_type;
  real_packet->request_kind = request_kind;
  
  return send_packet_unit_action_answer(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_get_actions_100 hash_const

#define cmp_packet_unit_get_actions_100 cmp_const

BV_DEFINE(packet_unit_get_actions_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_get_actions *receive_packet_unit_get_actions_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_get_actions_100_fields fields;
  struct packet_unit_get_actions *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_GET_ACTIONS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_get_actions, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->target_unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(target_unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_tile_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target_extra_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_extra_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }

#endif
  log_packet_detailed("packet_unit_get_actions_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_get_actions_100, cmp_packet_unit_get_actions_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->target_unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(target_unit_id32);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'target_tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_tile_id);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'target_extra_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_extra_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target_extra_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_extra_id);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_get_actions_100(struct connection *pc, const struct packet_unit_get_actions *packet)
{
  const struct packet_unit_get_actions *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_get_actions_100_fields fields;
  struct packet_unit_get_actions *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_GET_ACTIONS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_GET_ACTIONS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_get_actions_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_get_actions_100, cmp_packet_unit_get_actions_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_unit_id32 != real_packet->actor_unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_unit_id32 != real_packet->target_unit_id32);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->target_tile_id != real_packet->target_tile_id);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->target_extra_id != real_packet->target_extra_id);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->target_unit_id32);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'target_tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_tile_id);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'target_extra_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_extra_id);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->target_unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_tile_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_extra_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);

#endif
  SEND_PACKET_END(PACKET_UNIT_GET_ACTIONS);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_get_actions_101 hash_const

#define cmp_packet_unit_get_actions_101 cmp_const

BV_DEFINE(packet_unit_get_actions_101_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_get_actions *receive_packet_unit_get_actions_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_get_actions_101_fields fields;
  struct packet_unit_get_actions *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_GET_ACTIONS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_get_actions, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->target_unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(target_unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_tile_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target_extra_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_extra_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }

#endif
  log_packet_detailed("packet_unit_get_actions_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_get_actions_101, cmp_packet_unit_get_actions_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->target_unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(target_unit_id16);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'target_tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_tile_id);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'target_extra_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_extra_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target_extra_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_extra_id);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_get_actions_101(struct connection *pc, const struct packet_unit_get_actions *packet)
{
  const struct packet_unit_get_actions *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_get_actions_101_fields fields;
  struct packet_unit_get_actions *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_GET_ACTIONS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_GET_ACTIONS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_get_actions_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_get_actions_101, cmp_packet_unit_get_actions_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_unit_id16 != real_packet->actor_unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_unit_id16 != real_packet->target_unit_id16);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->target_tile_id != real_packet->target_tile_id);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->target_extra_id != real_packet->target_extra_id);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->target_unit_id16);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'target_tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_tile_id);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'target_extra_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_extra_id);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->target_unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_tile_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_extra_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);

#endif
  SEND_PACKET_END(PACKET_UNIT_GET_ACTIONS);
}

int send_packet_unit_get_actions(struct connection *pc, const struct packet_unit_get_actions *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_GET_ACTIONS].packet != NULL, -1,
                        "Handler for PACKET_UNIT_GET_ACTIONS not installed");
  return pc->phs.handlers->send[PACKET_UNIT_GET_ACTIONS].packet(pc, packet);
}

int dsend_packet_unit_get_actions(struct connection *pc, int actor_unit_id16, int actor_unit_id32, int target_unit_id16, int target_unit_id32, int target_tile_id, int target_extra_id, int request_kind)
{
  struct packet_unit_get_actions packet, *real_packet = &packet;

  real_packet->actor_unit_id16 = actor_unit_id16;
  real_packet->actor_unit_id32 = actor_unit_id32;
  real_packet->target_unit_id16 = target_unit_id16;
  real_packet->target_unit_id32 = target_unit_id32;
  real_packet->target_tile_id = target_tile_id;
  real_packet->target_extra_id = target_extra_id;
  real_packet->request_kind = request_kind;
  
  return send_packet_unit_get_actions(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_actions_100 hash_const

#define cmp_packet_unit_actions_100 cmp_const

BV_DEFINE(packet_unit_actions_100_fields, 7);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_actions *receive_packet_unit_actions_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_actions_100_fields fields;
  struct packet_unit_actions *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_ACTIONS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_actions, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->target_unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(target_unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_city_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->target_city_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(target_city_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_tile_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target_extra_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_extra_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_probabilities";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < MAX_NUM_ACTIONS; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(action_probability, &din, &field_addr, &real_packet->action_probabilities[i])) {
        RECEIVE_PACKET_FIELD_ERROR(action_probabilities);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_unit_actions_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_actions_100, cmp_packet_unit_actions_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->actor_unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->target_unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(target_unit_id32);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'target_city_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_city_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->target_city_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(target_city_id32);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'target_tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_tile_id);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'target_extra_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_extra_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target_extra_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_extra_id);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'action_probabilities'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_probabilities";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < MAX_NUM_ACTIONS; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(action_probability, &din, &field_addr, &real_packet->action_probabilities[i])) {
          RECEIVE_PACKET_FIELD_ERROR(action_probabilities);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_actions_100(struct connection *pc, const struct packet_unit_actions *packet)
{
  const struct packet_unit_actions *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_actions_100_fields fields;
  struct packet_unit_actions *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_ACTIONS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_ACTIONS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_actions_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_actions_100, cmp_packet_unit_actions_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_unit_id32 != real_packet->actor_unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_unit_id32 != real_packet->target_unit_id32);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->target_city_id32 != real_packet->target_city_id32);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->target_tile_id != real_packet->target_tile_id);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->target_extra_id != real_packet->target_extra_id);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 5);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < MAX_NUM_ACTIONS; i++) {
          if (!are_action_probabilitys_equal(&old->action_probabilities[i], &real_packet->action_probabilities[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 6);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->target_unit_id32);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'target_city_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->target_city_id32);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'target_tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_tile_id);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'target_extra_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_extra_id);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'action_probabilities' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_probabilities";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_NUM_ACTIONS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_NUM_ACTIONS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(action_probability, &dout, &field_addr, &real_packet->action_probabilities[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->actor_unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->target_unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_city_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->target_city_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_tile_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_extra_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_probabilities";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_NUM_ACTIONS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_NUM_ACTIONS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(action_probability, &dout, &field_addr, &real_packet->action_probabilities[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_UNIT_ACTIONS);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_actions_101 hash_const

#define cmp_packet_unit_actions_101 cmp_const

BV_DEFINE(packet_unit_actions_101_fields, 7);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_actions *receive_packet_unit_actions_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_actions_101_fields fields;
  struct packet_unit_actions *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_ACTIONS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_actions, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->target_unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(target_unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_city_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->target_city_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(target_city_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_tile_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_tile_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target_extra_id)) {
    RECEIVE_PACKET_FIELD_ERROR(target_extra_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(request_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_probabilities";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < MAX_NUM_ACTIONS; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(action_probability, &din, &field_addr, &real_packet->action_probabilities[i])) {
        RECEIVE_PACKET_FIELD_ERROR(action_probabilities);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_unit_actions_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_actions_101, cmp_packet_unit_actions_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'actor_unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->actor_unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'target_unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->target_unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(target_unit_id16);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'target_city_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_city_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->target_city_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(target_city_id16);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'target_tile_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_tile_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->target_tile_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_tile_id);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'target_extra_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_extra_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target_extra_id)) {
      RECEIVE_PACKET_FIELD_ERROR(target_extra_id);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'request_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "request_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->request_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(request_kind);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'action_probabilities'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "action_probabilities";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < MAX_NUM_ACTIONS; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(action_probability, &din, &field_addr, &real_packet->action_probabilities[i])) {
          RECEIVE_PACKET_FIELD_ERROR(action_probabilities);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_actions_101(struct connection *pc, const struct packet_unit_actions *packet)
{
  const struct packet_unit_actions *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_actions_101_fields fields;
  struct packet_unit_actions *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_ACTIONS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_ACTIONS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_actions_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_actions_101, cmp_packet_unit_actions_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->actor_unit_id16 != real_packet->actor_unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->target_unit_id16 != real_packet->target_unit_id16);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->target_city_id16 != real_packet->target_city_id16);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->target_tile_id != real_packet->target_tile_id);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->target_extra_id != real_packet->target_extra_id);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->request_kind != real_packet->request_kind);
  if (differ) {
    BV_SET(fields, 5);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < MAX_NUM_ACTIONS; i++) {
          if (!are_action_probabilitys_equal(&old->action_probabilities[i], &real_packet->action_probabilities[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 6);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'actor_unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'target_unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->target_unit_id16);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'target_city_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->target_city_id16);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'target_tile_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_tile_id);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'target_extra_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_extra_id);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'request_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'action_probabilities' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_probabilities";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_NUM_ACTIONS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_NUM_ACTIONS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(action_probability, &dout, &field_addr, &real_packet->action_probabilities[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->actor_unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->target_unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_city_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->target_city_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_tile_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->target_tile_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_extra_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_extra_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "request_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->request_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "action_probabilities";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, MAX_NUM_ACTIONS);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < MAX_NUM_ACTIONS; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(action_probability, &dout, &field_addr, &real_packet->action_probabilities[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_UNIT_ACTIONS);
}

int send_packet_unit_actions(struct connection *pc, const struct packet_unit_actions *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_ACTIONS].packet != NULL, -1,
                        "Handler for PACKET_UNIT_ACTIONS not installed");
  return pc->phs.handlers->send[PACKET_UNIT_ACTIONS].packet(pc, packet);
}

int dsend_packet_unit_actions(struct connection *pc, int actor_unit_id16, int actor_unit_id32, int target_unit_id16, int target_unit_id32, int target_city_id16, int target_city_id32, int target_tile_id, int target_extra_id, int request_kind, const struct act_prob *action_probabilities)
{
  struct packet_unit_actions packet, *real_packet = &packet;

  real_packet->actor_unit_id16 = actor_unit_id16;
  real_packet->actor_unit_id32 = actor_unit_id32;
  real_packet->target_unit_id16 = target_unit_id16;
  real_packet->target_unit_id32 = target_unit_id32;
  real_packet->target_city_id16 = target_city_id16;
  real_packet->target_city_id32 = target_city_id32;
  real_packet->target_tile_id = target_tile_id;
  real_packet->target_extra_id = target_extra_id;
  real_packet->request_kind = request_kind;
  {
    int i;

    for (i = 0; i < MAX_NUM_ACTIONS; i++) {
      real_packet->action_probabilities[i] = action_probabilities[i];
    }
  }
  
  return send_packet_unit_actions(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_change_activity_100 hash_const

#define cmp_packet_unit_change_activity_100 cmp_const

BV_DEFINE(packet_unit_change_activity_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_change_activity *receive_packet_unit_change_activity_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_change_activity_100_fields fields;
  struct packet_unit_change_activity *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_CHANGE_ACTIVITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_change_activity, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
    real_packet->activity = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target)) {
    RECEIVE_PACKET_FIELD_ERROR(target);
  }

#endif
  log_packet_detailed("packet_unit_change_activity_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_change_activity_100, cmp_packet_unit_change_activity_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->unit_id32)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity);
      }
      real_packet->activity = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'target'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target)) {
      RECEIVE_PACKET_FIELD_ERROR(target);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_change_activity_100(struct connection *pc, const struct packet_unit_change_activity *packet)
{
  const struct packet_unit_change_activity *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_change_activity_100_fields fields;
  struct packet_unit_change_activity *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_CHANGE_ACTIVITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_CHANGE_ACTIVITY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_change_activity_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_change_activity_100, cmp_packet_unit_change_activity_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id32 != real_packet->unit_id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->target != real_packet->target);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'target' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->unit_id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target);

#endif
  SEND_PACKET_END(PACKET_UNIT_CHANGE_ACTIVITY);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_unit_change_activity_101 hash_const

#define cmp_packet_unit_change_activity_101 cmp_const

BV_DEFINE(packet_unit_change_activity_101_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_unit_change_activity *receive_packet_unit_change_activity_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_change_activity_101_fields fields;
  struct packet_unit_change_activity *old;
  struct genhash **hash = pc->phs.received + PACKET_UNIT_CHANGE_ACTIVITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_unit_change_activity, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
    real_packet->activity = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target)) {
    RECEIVE_PACKET_FIELD_ERROR(target);
  }

#endif
  log_packet_detailed("packet_unit_change_activity_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_change_activity_101, cmp_packet_unit_change_activity_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit_id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->unit_id16)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_id16);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity);
      }
      real_packet->activity = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'target'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->target)) {
      RECEIVE_PACKET_FIELD_ERROR(target);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_unit_change_activity_101(struct connection *pc, const struct packet_unit_change_activity *packet)
{
  const struct packet_unit_change_activity *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_unit_change_activity_101_fields fields;
  struct packet_unit_change_activity *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_UNIT_CHANGE_ACTIVITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_UNIT_CHANGE_ACTIVITY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_unit_change_activity_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_unit_change_activity_101, cmp_packet_unit_change_activity_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit_id16 != real_packet->unit_id16);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->target != real_packet->target);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit_id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'target' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->unit_id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target);

#endif
  SEND_PACKET_END(PACKET_UNIT_CHANGE_ACTIVITY);
}

int send_packet_unit_change_activity(struct connection *pc, const struct packet_unit_change_activity *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_UNIT_CHANGE_ACTIVITY].packet != NULL, -1,
                        "Handler for PACKET_UNIT_CHANGE_ACTIVITY not installed");
  return pc->phs.handlers->send[PACKET_UNIT_CHANGE_ACTIVITY].packet(pc, packet);
}

int dsend_packet_unit_change_activity(struct connection *pc, int unit_id16, int unit_id32, enum unit_activity activity, int target)
{
  struct packet_unit_change_activity packet, *real_packet = &packet;

  real_packet->unit_id16 = unit_id16;
  real_packet->unit_id32 = unit_id32;
  real_packet->activity = activity;
  real_packet->target = target;
  
  return send_packet_unit_change_activity(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_init_meeting_req_100 hash_const

#define cmp_packet_diplomacy_init_meeting_req_100 cmp_const

BV_DEFINE(packet_diplomacy_init_meeting_req_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_init_meeting_req *receive_packet_diplomacy_init_meeting_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_init_meeting_req_100_fields fields;
  struct packet_diplomacy_init_meeting_req *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_INIT_MEETING_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_init_meeting_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }

#endif
  log_packet_detailed("packet_diplomacy_init_meeting_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_init_meeting_req_100, cmp_packet_diplomacy_init_meeting_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_init_meeting_req_100(struct connection *pc, const struct packet_diplomacy_init_meeting_req *packet)
{
  const struct packet_diplomacy_init_meeting_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_init_meeting_req_100_fields fields;
  struct packet_diplomacy_init_meeting_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_INIT_MEETING_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_INIT_MEETING_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_init_meeting_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_init_meeting_req_100, cmp_packet_diplomacy_init_meeting_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_INIT_MEETING_REQ);
}

int send_packet_diplomacy_init_meeting_req(struct connection *pc, const struct packet_diplomacy_init_meeting_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_INIT_MEETING_REQ].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_INIT_MEETING_REQ not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_INIT_MEETING_REQ].packet(pc, packet);
}

int dsend_packet_diplomacy_init_meeting_req(struct connection *pc, int counterpart)
{
  struct packet_diplomacy_init_meeting_req packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  
  return send_packet_diplomacy_init_meeting_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_init_meeting_100 hash_const

#define cmp_packet_diplomacy_init_meeting_100 cmp_const

BV_DEFINE(packet_diplomacy_init_meeting_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_init_meeting *receive_packet_diplomacy_init_meeting_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_init_meeting_100_fields fields;
  struct packet_diplomacy_init_meeting *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_INIT_MEETING;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_init_meeting, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initiated_from";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->initiated_from)) {
    RECEIVE_PACKET_FIELD_ERROR(initiated_from);
  }

#endif
  log_packet_detailed("packet_diplomacy_init_meeting_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_init_meeting_100, cmp_packet_diplomacy_init_meeting_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'initiated_from'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "initiated_from";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->initiated_from)) {
      RECEIVE_PACKET_FIELD_ERROR(initiated_from);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_init_meeting_100(struct connection *pc, const struct packet_diplomacy_init_meeting *packet)
{
  const struct packet_diplomacy_init_meeting *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_init_meeting_100_fields fields;
  struct packet_diplomacy_init_meeting *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_INIT_MEETING;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_INIT_MEETING);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_init_meeting_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_init_meeting_100, cmp_packet_diplomacy_init_meeting_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->initiated_from != real_packet->initiated_from);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'initiated_from' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initiated_from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->initiated_from);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initiated_from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->initiated_from);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_INIT_MEETING);
}

int send_packet_diplomacy_init_meeting(struct connection *pc, const struct packet_diplomacy_init_meeting *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_INIT_MEETING].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_INIT_MEETING not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_INIT_MEETING].packet(pc, packet);
}

void lsend_packet_diplomacy_init_meeting(struct conn_list *dest, const struct packet_diplomacy_init_meeting *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_diplomacy_init_meeting(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_diplomacy_init_meeting(struct connection *pc, int counterpart, int initiated_from)
{
  struct packet_diplomacy_init_meeting packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->initiated_from = initiated_from;
  
  return send_packet_diplomacy_init_meeting(pc, real_packet);
}

void dlsend_packet_diplomacy_init_meeting(struct conn_list *dest, int counterpart, int initiated_from)
{
  struct packet_diplomacy_init_meeting packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->initiated_from = initiated_from;
  
  lsend_packet_diplomacy_init_meeting(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_cancel_meeting_req_100 hash_const

#define cmp_packet_diplomacy_cancel_meeting_req_100 cmp_const

BV_DEFINE(packet_diplomacy_cancel_meeting_req_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_cancel_meeting_req *receive_packet_diplomacy_cancel_meeting_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_cancel_meeting_req_100_fields fields;
  struct packet_diplomacy_cancel_meeting_req *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_CANCEL_MEETING_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_cancel_meeting_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }

#endif
  log_packet_detailed("packet_diplomacy_cancel_meeting_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_cancel_meeting_req_100, cmp_packet_diplomacy_cancel_meeting_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_cancel_meeting_req_100(struct connection *pc, const struct packet_diplomacy_cancel_meeting_req *packet)
{
  const struct packet_diplomacy_cancel_meeting_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_cancel_meeting_req_100_fields fields;
  struct packet_diplomacy_cancel_meeting_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_CANCEL_MEETING_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_CANCEL_MEETING_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_cancel_meeting_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_cancel_meeting_req_100, cmp_packet_diplomacy_cancel_meeting_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_CANCEL_MEETING_REQ);
}

int send_packet_diplomacy_cancel_meeting_req(struct connection *pc, const struct packet_diplomacy_cancel_meeting_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_CANCEL_MEETING_REQ].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_CANCEL_MEETING_REQ not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_CANCEL_MEETING_REQ].packet(pc, packet);
}

int dsend_packet_diplomacy_cancel_meeting_req(struct connection *pc, int counterpart)
{
  struct packet_diplomacy_cancel_meeting_req packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  
  return send_packet_diplomacy_cancel_meeting_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_cancel_meeting_100 hash_const

#define cmp_packet_diplomacy_cancel_meeting_100 cmp_const

BV_DEFINE(packet_diplomacy_cancel_meeting_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_cancel_meeting *receive_packet_diplomacy_cancel_meeting_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_cancel_meeting_100_fields fields;
  struct packet_diplomacy_cancel_meeting *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_CANCEL_MEETING;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_cancel_meeting, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initiated_from";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->initiated_from)) {
    RECEIVE_PACKET_FIELD_ERROR(initiated_from);
  }

#endif
  log_packet_detailed("packet_diplomacy_cancel_meeting_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_cancel_meeting_100, cmp_packet_diplomacy_cancel_meeting_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'initiated_from'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "initiated_from";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->initiated_from)) {
      RECEIVE_PACKET_FIELD_ERROR(initiated_from);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_cancel_meeting_100(struct connection *pc, const struct packet_diplomacy_cancel_meeting *packet)
{
  const struct packet_diplomacy_cancel_meeting *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_cancel_meeting_100_fields fields;
  struct packet_diplomacy_cancel_meeting *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_CANCEL_MEETING;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_CANCEL_MEETING);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_cancel_meeting_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_cancel_meeting_100, cmp_packet_diplomacy_cancel_meeting_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->initiated_from != real_packet->initiated_from);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'initiated_from' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initiated_from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->initiated_from);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initiated_from";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->initiated_from);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_CANCEL_MEETING);
}

int send_packet_diplomacy_cancel_meeting(struct connection *pc, const struct packet_diplomacy_cancel_meeting *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_CANCEL_MEETING].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_CANCEL_MEETING not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_CANCEL_MEETING].packet(pc, packet);
}

void lsend_packet_diplomacy_cancel_meeting(struct conn_list *dest, const struct packet_diplomacy_cancel_meeting *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_diplomacy_cancel_meeting(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_diplomacy_cancel_meeting(struct connection *pc, int counterpart, int initiated_from)
{
  struct packet_diplomacy_cancel_meeting packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->initiated_from = initiated_from;
  
  return send_packet_diplomacy_cancel_meeting(pc, real_packet);
}

void dlsend_packet_diplomacy_cancel_meeting(struct conn_list *dest, int counterpart, int initiated_from)
{
  struct packet_diplomacy_cancel_meeting packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->initiated_from = initiated_from;
  
  lsend_packet_diplomacy_cancel_meeting(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_create_clause_req_100 hash_const

#define cmp_packet_diplomacy_create_clause_req_100 cmp_const

BV_DEFINE(packet_diplomacy_create_clause_req_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_create_clause_req *receive_packet_diplomacy_create_clause_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_create_clause_req_100_fields fields;
  struct packet_diplomacy_create_clause_req *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_CREATE_CLAUSE_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_create_clause_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->giver)) {
    RECEIVE_PACKET_FIELD_ERROR(giver);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }

#endif
  log_packet_detailed("packet_diplomacy_create_clause_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_create_clause_req_100, cmp_packet_diplomacy_create_clause_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'giver'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "giver";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->giver)) {
      RECEIVE_PACKET_FIELD_ERROR(giver);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_create_clause_req_100(struct connection *pc, const struct packet_diplomacy_create_clause_req *packet)
{
  const struct packet_diplomacy_create_clause_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_create_clause_req_100_fields fields;
  struct packet_diplomacy_create_clause_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_CREATE_CLAUSE_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_CREATE_CLAUSE_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_create_clause_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_create_clause_req_100, cmp_packet_diplomacy_create_clause_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->giver != real_packet->giver);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'giver' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->giver);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->value);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->giver);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->value);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_CREATE_CLAUSE_REQ);
}

int send_packet_diplomacy_create_clause_req(struct connection *pc, const struct packet_diplomacy_create_clause_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_CREATE_CLAUSE_REQ].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_CREATE_CLAUSE_REQ not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_CREATE_CLAUSE_REQ].packet(pc, packet);
}

int dsend_packet_diplomacy_create_clause_req(struct connection *pc, int counterpart, int giver, enum clause_type type, int value)
{
  struct packet_diplomacy_create_clause_req packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->giver = giver;
  real_packet->type = type;
  real_packet->value = value;
  
  return send_packet_diplomacy_create_clause_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_create_clause_100 hash_const

#define cmp_packet_diplomacy_create_clause_100 cmp_const

BV_DEFINE(packet_diplomacy_create_clause_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_create_clause *receive_packet_diplomacy_create_clause_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_create_clause_100_fields fields;
  struct packet_diplomacy_create_clause *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_CREATE_CLAUSE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_create_clause, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->giver)) {
    RECEIVE_PACKET_FIELD_ERROR(giver);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }

#endif
  log_packet_detailed("packet_diplomacy_create_clause_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_create_clause_100, cmp_packet_diplomacy_create_clause_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'giver'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "giver";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->giver)) {
      RECEIVE_PACKET_FIELD_ERROR(giver);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_create_clause_100(struct connection *pc, const struct packet_diplomacy_create_clause *packet)
{
  const struct packet_diplomacy_create_clause *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_create_clause_100_fields fields;
  struct packet_diplomacy_create_clause *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_CREATE_CLAUSE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_CREATE_CLAUSE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_create_clause_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_create_clause_100, cmp_packet_diplomacy_create_clause_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->giver != real_packet->giver);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'giver' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->giver);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->value);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->giver);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->value);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_CREATE_CLAUSE);
}

int send_packet_diplomacy_create_clause(struct connection *pc, const struct packet_diplomacy_create_clause *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_CREATE_CLAUSE].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_CREATE_CLAUSE not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_CREATE_CLAUSE].packet(pc, packet);
}

void lsend_packet_diplomacy_create_clause(struct conn_list *dest, const struct packet_diplomacy_create_clause *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_diplomacy_create_clause(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_diplomacy_create_clause(struct connection *pc, int counterpart, int giver, enum clause_type type, int value)
{
  struct packet_diplomacy_create_clause packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->giver = giver;
  real_packet->type = type;
  real_packet->value = value;
  
  return send_packet_diplomacy_create_clause(pc, real_packet);
}

void dlsend_packet_diplomacy_create_clause(struct conn_list *dest, int counterpart, int giver, enum clause_type type, int value)
{
  struct packet_diplomacy_create_clause packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->giver = giver;
  real_packet->type = type;
  real_packet->value = value;
  
  lsend_packet_diplomacy_create_clause(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_remove_clause_req_100 hash_const

#define cmp_packet_diplomacy_remove_clause_req_100 cmp_const

BV_DEFINE(packet_diplomacy_remove_clause_req_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_remove_clause_req *receive_packet_diplomacy_remove_clause_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_remove_clause_req_100_fields fields;
  struct packet_diplomacy_remove_clause_req *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_remove_clause_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->giver)) {
    RECEIVE_PACKET_FIELD_ERROR(giver);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }

#endif
  log_packet_detailed("packet_diplomacy_remove_clause_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_remove_clause_req_100, cmp_packet_diplomacy_remove_clause_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'giver'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "giver";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->giver)) {
      RECEIVE_PACKET_FIELD_ERROR(giver);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_remove_clause_req_100(struct connection *pc, const struct packet_diplomacy_remove_clause_req *packet)
{
  const struct packet_diplomacy_remove_clause_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_remove_clause_req_100_fields fields;
  struct packet_diplomacy_remove_clause_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_remove_clause_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_remove_clause_req_100, cmp_packet_diplomacy_remove_clause_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->giver != real_packet->giver);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'giver' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->giver);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->value);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->giver);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->value);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ);
}

int send_packet_diplomacy_remove_clause_req(struct connection *pc, const struct packet_diplomacy_remove_clause_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ].packet(pc, packet);
}

int dsend_packet_diplomacy_remove_clause_req(struct connection *pc, int counterpart, int giver, enum clause_type type, int value)
{
  struct packet_diplomacy_remove_clause_req packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->giver = giver;
  real_packet->type = type;
  real_packet->value = value;
  
  return send_packet_diplomacy_remove_clause_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_remove_clause_100 hash_const

#define cmp_packet_diplomacy_remove_clause_100 cmp_const

BV_DEFINE(packet_diplomacy_remove_clause_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_remove_clause *receive_packet_diplomacy_remove_clause_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_remove_clause_100_fields fields;
  struct packet_diplomacy_remove_clause *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_REMOVE_CLAUSE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_remove_clause, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->giver)) {
    RECEIVE_PACKET_FIELD_ERROR(giver);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }

#endif
  log_packet_detailed("packet_diplomacy_remove_clause_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_remove_clause_100, cmp_packet_diplomacy_remove_clause_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'giver'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "giver";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->giver)) {
      RECEIVE_PACKET_FIELD_ERROR(giver);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_remove_clause_100(struct connection *pc, const struct packet_diplomacy_remove_clause *packet)
{
  const struct packet_diplomacy_remove_clause *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_remove_clause_100_fields fields;
  struct packet_diplomacy_remove_clause *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_REMOVE_CLAUSE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_REMOVE_CLAUSE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_remove_clause_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_remove_clause_100, cmp_packet_diplomacy_remove_clause_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->giver != real_packet->giver);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'giver' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->giver);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->value);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->giver);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->value);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_REMOVE_CLAUSE);
}

int send_packet_diplomacy_remove_clause(struct connection *pc, const struct packet_diplomacy_remove_clause *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_REMOVE_CLAUSE].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_REMOVE_CLAUSE not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_REMOVE_CLAUSE].packet(pc, packet);
}

void lsend_packet_diplomacy_remove_clause(struct conn_list *dest, const struct packet_diplomacy_remove_clause *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_diplomacy_remove_clause(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_diplomacy_remove_clause(struct connection *pc, int counterpart, int giver, enum clause_type type, int value)
{
  struct packet_diplomacy_remove_clause packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->giver = giver;
  real_packet->type = type;
  real_packet->value = value;
  
  return send_packet_diplomacy_remove_clause(pc, real_packet);
}

void dlsend_packet_diplomacy_remove_clause(struct conn_list *dest, int counterpart, int giver, enum clause_type type, int value)
{
  struct packet_diplomacy_remove_clause packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->giver = giver;
  real_packet->type = type;
  real_packet->value = value;
  
  lsend_packet_diplomacy_remove_clause(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_accept_treaty_req_100 hash_const

#define cmp_packet_diplomacy_accept_treaty_req_100 cmp_const

BV_DEFINE(packet_diplomacy_accept_treaty_req_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_accept_treaty_req *receive_packet_diplomacy_accept_treaty_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_accept_treaty_req_100_fields fields;
  struct packet_diplomacy_accept_treaty_req *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_ACCEPT_TREATY_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_accept_treaty_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }

#endif
  log_packet_detailed("packet_diplomacy_accept_treaty_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_accept_treaty_req_100, cmp_packet_diplomacy_accept_treaty_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_accept_treaty_req_100(struct connection *pc, const struct packet_diplomacy_accept_treaty_req *packet)
{
  const struct packet_diplomacy_accept_treaty_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_accept_treaty_req_100_fields fields;
  struct packet_diplomacy_accept_treaty_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_ACCEPT_TREATY_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_ACCEPT_TREATY_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_accept_treaty_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_accept_treaty_req_100, cmp_packet_diplomacy_accept_treaty_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_ACCEPT_TREATY_REQ);
}

int send_packet_diplomacy_accept_treaty_req(struct connection *pc, const struct packet_diplomacy_accept_treaty_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_ACCEPT_TREATY_REQ].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_ACCEPT_TREATY_REQ not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_ACCEPT_TREATY_REQ].packet(pc, packet);
}

int dsend_packet_diplomacy_accept_treaty_req(struct connection *pc, int counterpart)
{
  struct packet_diplomacy_accept_treaty_req packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  
  return send_packet_diplomacy_accept_treaty_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_accept_treaty_100 hash_const

#define cmp_packet_diplomacy_accept_treaty_100 cmp_const

BV_DEFINE(packet_diplomacy_accept_treaty_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_accept_treaty *receive_packet_diplomacy_accept_treaty_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_accept_treaty_100_fields fields;
  struct packet_diplomacy_accept_treaty *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_ACCEPT_TREATY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_accept_treaty, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
    RECEIVE_PACKET_FIELD_ERROR(counterpart);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "I_accepted";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->I_accepted)) {
    RECEIVE_PACKET_FIELD_ERROR(I_accepted);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "other_accepted";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->other_accepted)) {
    RECEIVE_PACKET_FIELD_ERROR(other_accepted);
  }

#endif
  log_packet_detailed("packet_diplomacy_accept_treaty_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_accept_treaty_100, cmp_packet_diplomacy_accept_treaty_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'counterpart'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "counterpart";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->counterpart)) {
      RECEIVE_PACKET_FIELD_ERROR(counterpart);
    }
  }
  real_packet->I_accepted = BV_ISSET(fields, 1);
  real_packet->other_accepted = BV_ISSET(fields, 2);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_accept_treaty_100(struct connection *pc, const struct packet_diplomacy_accept_treaty *packet)
{
  const struct packet_diplomacy_accept_treaty *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_accept_treaty_100_fields fields;
  struct packet_diplomacy_accept_treaty *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_ACCEPT_TREATY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_ACCEPT_TREATY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_accept_treaty_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_accept_treaty_100, cmp_packet_diplomacy_accept_treaty_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->counterpart != real_packet->counterpart);
  if (differ) {
    BV_SET(fields, 0);
  }

  if (packet->I_accepted) {
    BV_SET(fields, 1);
  }

  if (packet->other_accepted) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'counterpart' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
  }
  /* field 1 is folded into the header */
  /* field 2 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "counterpart";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->counterpart);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "I_accepted";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->I_accepted);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "other_accepted";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->other_accepted);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_ACCEPT_TREATY);
}

int send_packet_diplomacy_accept_treaty(struct connection *pc, const struct packet_diplomacy_accept_treaty *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_ACCEPT_TREATY].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_ACCEPT_TREATY not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_ACCEPT_TREATY].packet(pc, packet);
}

void lsend_packet_diplomacy_accept_treaty(struct conn_list *dest, const struct packet_diplomacy_accept_treaty *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_diplomacy_accept_treaty(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_diplomacy_accept_treaty(struct connection *pc, int counterpart, bool I_accepted, bool other_accepted)
{
  struct packet_diplomacy_accept_treaty packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->I_accepted = I_accepted;
  real_packet->other_accepted = other_accepted;
  
  return send_packet_diplomacy_accept_treaty(pc, real_packet);
}

void dlsend_packet_diplomacy_accept_treaty(struct conn_list *dest, int counterpart, bool I_accepted, bool other_accepted)
{
  struct packet_diplomacy_accept_treaty packet, *real_packet = &packet;

  real_packet->counterpart = counterpart;
  real_packet->I_accepted = I_accepted;
  real_packet->other_accepted = other_accepted;
  
  lsend_packet_diplomacy_accept_treaty(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_diplomacy_cancel_pact_100 hash_const

#define cmp_packet_diplomacy_cancel_pact_100 cmp_const

BV_DEFINE(packet_diplomacy_cancel_pact_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_diplomacy_cancel_pact *receive_packet_diplomacy_cancel_pact_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_cancel_pact_100_fields fields;
  struct packet_diplomacy_cancel_pact *old;
  struct genhash **hash = pc->phs.received + PACKET_DIPLOMACY_CANCEL_PACT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_diplomacy_cancel_pact, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "other_player_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->other_player_id)) {
    RECEIVE_PACKET_FIELD_ERROR(other_player_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "clause";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(clause);
    }
    real_packet->clause = readin;
  }

#endif
  log_packet_detailed("packet_diplomacy_cancel_pact_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_cancel_pact_100, cmp_packet_diplomacy_cancel_pact_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'other_player_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "other_player_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->other_player_id)) {
      RECEIVE_PACKET_FIELD_ERROR(other_player_id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'clause'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "clause";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(clause);
      }
      real_packet->clause = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_diplomacy_cancel_pact_100(struct connection *pc, const struct packet_diplomacy_cancel_pact *packet)
{
  const struct packet_diplomacy_cancel_pact *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_diplomacy_cancel_pact_100_fields fields;
  struct packet_diplomacy_cancel_pact *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_DIPLOMACY_CANCEL_PACT;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_DIPLOMACY_CANCEL_PACT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_diplomacy_cancel_pact_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_diplomacy_cancel_pact_100, cmp_packet_diplomacy_cancel_pact_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->other_player_id != real_packet->other_player_id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->clause != real_packet->clause);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'other_player_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "other_player_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->other_player_id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'clause' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "clause";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->clause);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "other_player_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->other_player_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "clause";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->clause);

#endif
  SEND_PACKET_END(PACKET_DIPLOMACY_CANCEL_PACT);
}

int send_packet_diplomacy_cancel_pact(struct connection *pc, const struct packet_diplomacy_cancel_pact *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_DIPLOMACY_CANCEL_PACT].packet != NULL, -1,
                        "Handler for PACKET_DIPLOMACY_CANCEL_PACT not installed");
  return pc->phs.handlers->send[PACKET_DIPLOMACY_CANCEL_PACT].packet(pc, packet);
}

int dsend_packet_diplomacy_cancel_pact(struct connection *pc, int other_player_id, enum clause_type clause)
{
  struct packet_diplomacy_cancel_pact packet, *real_packet = &packet;

  real_packet->other_player_id = other_player_id;
  real_packet->clause = clause;
  
  return send_packet_diplomacy_cancel_pact(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_page_msg_100 hash_const

#define cmp_packet_page_msg_100 cmp_const

BV_DEFINE(packet_page_msg_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_page_msg *receive_packet_page_msg_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_page_msg_100_fields fields;
  struct packet_page_msg *old;
  struct genhash **hash = pc->phs.received + PACKET_PAGE_MSG;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_page_msg, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caption";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->caption, sizeof(real_packet->caption))) {
    RECEIVE_PACKET_FIELD_ERROR(caption);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "headline";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->headline, sizeof(real_packet->headline))) {
    RECEIVE_PACKET_FIELD_ERROR(headline);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "event";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(event);
    }
    real_packet->event = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "len";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->len)) {
    RECEIVE_PACKET_FIELD_ERROR(len);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "parts";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->parts)) {
    RECEIVE_PACKET_FIELD_ERROR(parts);
  }

#endif
  log_packet_detailed("packet_page_msg_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_page_msg_100, cmp_packet_page_msg_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'caption'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "caption";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->caption, sizeof(real_packet->caption))) {
      RECEIVE_PACKET_FIELD_ERROR(caption);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'headline'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "headline";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->headline, sizeof(real_packet->headline))) {
      RECEIVE_PACKET_FIELD_ERROR(headline);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'event'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "event";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(event);
      }
      real_packet->event = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'len'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "len";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->len)) {
      RECEIVE_PACKET_FIELD_ERROR(len);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'parts'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "parts";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->parts)) {
      RECEIVE_PACKET_FIELD_ERROR(parts);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_page_msg_100(struct connection *pc, const struct packet_page_msg *packet)
{
  const struct packet_page_msg *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_page_msg_100_fields fields;
  struct packet_page_msg *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PAGE_MSG;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PAGE_MSG);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_page_msg_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_page_msg_100, cmp_packet_page_msg_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->caption, real_packet->caption) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->headline, real_packet->headline) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->event != real_packet->event);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->len != real_packet->len);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->parts != real_packet->parts);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'caption' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caption";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->caption);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'headline' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "headline";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->headline);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'event' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "event";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->event);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'len' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "len";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->len);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'parts' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "parts";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->parts);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "caption";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->caption);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "headline";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->headline);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "event";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->event);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "len";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->len);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "parts";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->parts);

#endif
  SEND_PACKET_END(PACKET_PAGE_MSG);
}

int send_packet_page_msg(struct connection *pc, const struct packet_page_msg *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PAGE_MSG].packet != NULL, -1,
                        "Handler for PACKET_PAGE_MSG not installed");
  return pc->phs.handlers->send[PACKET_PAGE_MSG].packet(pc, packet);
}

void lsend_packet_page_msg(struct conn_list *dest, const struct packet_page_msg *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_page_msg(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_page_msg_part_100 hash_const

#define cmp_packet_page_msg_part_100 cmp_const

BV_DEFINE(packet_page_msg_part_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_page_msg_part *receive_packet_page_msg_part_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_page_msg_part_100_fields fields;
  struct packet_page_msg_part *old;
  struct genhash **hash = pc->phs.received + PACKET_PAGE_MSG_PART;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_page_msg_part, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lines";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->lines, sizeof(real_packet->lines))) {
    RECEIVE_PACKET_FIELD_ERROR(lines);
  }

#endif
  log_packet_detailed("packet_page_msg_part_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_page_msg_part_100, cmp_packet_page_msg_part_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'lines'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "lines";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->lines, sizeof(real_packet->lines))) {
      RECEIVE_PACKET_FIELD_ERROR(lines);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_page_msg_part_100(struct connection *pc, const struct packet_page_msg_part *packet)
{
  const struct packet_page_msg_part *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_page_msg_part_100_fields fields;
  struct packet_page_msg_part *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PAGE_MSG_PART;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PAGE_MSG_PART);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_page_msg_part_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_page_msg_part_100, cmp_packet_page_msg_part_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->lines, real_packet->lines) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'lines' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lines";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->lines);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lines";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->lines);

#endif
  SEND_PACKET_END(PACKET_PAGE_MSG_PART);
}

int send_packet_page_msg_part(struct connection *pc, const struct packet_page_msg_part *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PAGE_MSG_PART].packet != NULL, -1,
                        "Handler for PACKET_PAGE_MSG_PART not installed");
  return pc->phs.handlers->send[PACKET_PAGE_MSG_PART].packet(pc, packet);
}

void lsend_packet_page_msg_part(struct conn_list *dest, const struct packet_page_msg_part *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_page_msg_part(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_report_req_100 hash_const

#define cmp_packet_report_req_100 cmp_const

BV_DEFINE(packet_report_req_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_report_req *receive_packet_report_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_report_req_100_fields fields;
  struct packet_report_req *old;
  struct genhash **hash = pc->phs.received + PACKET_REPORT_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_report_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }

#endif
  log_packet_detailed("packet_report_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_report_req_100, cmp_packet_report_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_report_req_100(struct connection *pc, const struct packet_report_req *packet)
{
  const struct packet_report_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_report_req_100_fields fields;
  struct packet_report_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_REPORT_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_REPORT_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_report_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_report_req_100, cmp_packet_report_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);

#endif
  SEND_PACKET_END(PACKET_REPORT_REQ);
}

int send_packet_report_req(struct connection *pc, const struct packet_report_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_REPORT_REQ].packet != NULL, -1,
                        "Handler for PACKET_REPORT_REQ not installed");
  return pc->phs.handlers->send[PACKET_REPORT_REQ].packet(pc, packet);
}

int dsend_packet_report_req(struct connection *pc, enum report_type type)
{
  struct packet_report_req packet, *real_packet = &packet;

  real_packet->type = type;
  
  return send_packet_report_req(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_conn_info_100(const void *vkey)
{
  const struct packet_conn_info *key = (const struct packet_conn_info *) vkey;

  return key->id;
}

static bool cmp_packet_conn_info_100(const void *vkey1, const void *vkey2)
{
  const struct packet_conn_info *key1 = (const struct packet_conn_info *) vkey1;
  const struct packet_conn_info *key2 = (const struct packet_conn_info *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_conn_info_100_fields, 8);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_conn_info *receive_packet_conn_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_conn_info_100_fields fields;
  struct packet_conn_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CONN_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_conn_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "used";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->used)) {
    RECEIVE_PACKET_FIELD_ERROR(used);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "established";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->established)) {
    RECEIVE_PACKET_FIELD_ERROR(established);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "observer";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->observer)) {
    RECEIVE_PACKET_FIELD_ERROR(observer);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_num)) {
    RECEIVE_PACKET_FIELD_ERROR(player_num);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "access_level";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(access_level);
    }
    real_packet->access_level = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->username, sizeof(real_packet->username))) {
    RECEIVE_PACKET_FIELD_ERROR(username);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "addr";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->addr, sizeof(real_packet->addr))) {
    RECEIVE_PACKET_FIELD_ERROR(addr);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capability";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->capability, sizeof(real_packet->capability))) {
    RECEIVE_PACKET_FIELD_ERROR(capability);
  }

#endif
  log_packet_detailed("packet_conn_info_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_conn_info_100, cmp_packet_conn_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  real_packet->used = BV_ISSET(fields, 0);
  real_packet->established = BV_ISSET(fields, 1);
  real_packet->observer = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'player_num'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "player_num";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_num)) {
      RECEIVE_PACKET_FIELD_ERROR(player_num);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'access_level'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "access_level";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(access_level);
      }
      real_packet->access_level = readin;
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'username'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "username";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->username, sizeof(real_packet->username))) {
      RECEIVE_PACKET_FIELD_ERROR(username);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'addr'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "addr";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->addr, sizeof(real_packet->addr))) {
      RECEIVE_PACKET_FIELD_ERROR(addr);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'capability'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "capability";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->capability, sizeof(real_packet->capability))) {
      RECEIVE_PACKET_FIELD_ERROR(capability);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_conn_info_100(struct connection *pc, const struct packet_conn_info *packet)
{
  const struct packet_conn_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_conn_info_100_fields fields;
  struct packet_conn_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CONN_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CONN_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_conn_info_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_conn_info_100, cmp_packet_conn_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->used != real_packet->used);
  if (differ) {
    different++;
  }
  if (packet->used) {
    BV_SET(fields, 0);
  }

  differ = (old->established != real_packet->established);
  if (differ) {
    different++;
  }
  if (packet->established) {
    BV_SET(fields, 1);
  }

  differ = (old->observer != real_packet->observer);
  if (differ) {
    different++;
  }
  if (packet->observer) {
    BV_SET(fields, 2);
  }

  differ = (old->player_num != real_packet->player_num);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->access_level != real_packet->access_level);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (strcmp(old->username, real_packet->username) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (strcmp(old->addr, real_packet->addr) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (strcmp(old->capability, real_packet->capability) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->id);

  /* field 0 is folded into the header */
  /* field 1 is folded into the header */
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'player_num' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_num);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'access_level' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "access_level";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->access_level);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'username' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->username);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'addr' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "addr";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->addr);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'capability' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capability";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->capability);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "used";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->used);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "established";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->established);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "observer";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->observer);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_num);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "access_level";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->access_level);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->username);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "addr";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->addr);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "capability";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->capability);

#endif
  SEND_PACKET_END(PACKET_CONN_INFO);
}

int send_packet_conn_info(struct connection *pc, const struct packet_conn_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CONN_INFO].packet != NULL, -1,
                        "Handler for PACKET_CONN_INFO not installed");
  return pc->phs.handlers->send[PACKET_CONN_INFO].packet(pc, packet);
}

void lsend_packet_conn_info(struct conn_list *dest, const struct packet_conn_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_conn_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_conn_ping_info_100 hash_const

#define cmp_packet_conn_ping_info_100 cmp_const

BV_DEFINE(packet_conn_ping_info_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_conn_ping_info *receive_packet_conn_ping_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_conn_ping_info_100_fields fields;
  struct packet_conn_ping_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CONN_PING_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_conn_ping_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "connections";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->connections)) {
    RECEIVE_PACKET_FIELD_ERROR(connections);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->connections > MAX_NUM_CONNECTIONS) {
      RECEIVE_PACKET_FIELD_ERROR(conn_id, ": truncation array");
    }
    for (i = 0; i < real_packet->connections; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sint16, &din, &field_addr, &real_packet->conn_id[i])) {
        RECEIVE_PACKET_FIELD_ERROR(conn_id);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ping_time";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->connections > MAX_NUM_CONNECTIONS) {
      RECEIVE_PACKET_FIELD_ERROR(ping_time, ": truncation array");
    }
    for (i = 0; i < real_packet->connections; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(sfloat, &din, &field_addr, &real_packet->ping_time[i], 100000)) {
        RECEIVE_PACKET_FIELD_ERROR(ping_time);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_conn_ping_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_conn_ping_info_100, cmp_packet_conn_ping_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'connections'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "connections";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->connections)) {
      RECEIVE_PACKET_FIELD_ERROR(connections);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'conn_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "conn_id";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->connections > MAX_NUM_CONNECTIONS) {
        RECEIVE_PACKET_FIELD_ERROR(conn_id, ": truncation array");
      }
      for (i = 0; i < real_packet->connections; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint16, &din, &field_addr, &real_packet->conn_id[i])) {
          RECEIVE_PACKET_FIELD_ERROR(conn_id);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'ping_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ping_time";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->connections > MAX_NUM_CONNECTIONS) {
        RECEIVE_PACKET_FIELD_ERROR(ping_time, ": truncation array");
      }
      for (i = 0; i < real_packet->connections; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sfloat, &din, &field_addr, &real_packet->ping_time[i], 100000)) {
          RECEIVE_PACKET_FIELD_ERROR(ping_time);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_conn_ping_info_100(struct connection *pc, const struct packet_conn_ping_info *packet)
{
  const struct packet_conn_ping_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_conn_ping_info_100_fields fields;
  struct packet_conn_ping_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CONN_PING_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CONN_PING_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_conn_ping_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_conn_ping_info_100, cmp_packet_conn_ping_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->connections != real_packet->connections);
  if (differ) {
    BV_SET(fields, 0);
  }


    {
      differ = (old->connections != real_packet->connections);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->connections; i++) {
          if (old->conn_id[i] != real_packet->conn_id[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 1);
  }


    {
      differ = (old->connections != real_packet->connections);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->connections; i++) {
          if (old->ping_time[i] != real_packet->ping_time[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'connections' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "connections";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->connections);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'conn_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->connections);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->connections; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->conn_id[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'ping_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ping_time";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->connections);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->connections; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(sfloat, &dout, &field_addr, real_packet->ping_time[i], 100000);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "connections";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->connections);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conn_id";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->connections);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->connections; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint16, &dout, &field_addr, real_packet->conn_id[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ping_time";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->connections);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->connections; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(sfloat, &dout, &field_addr, real_packet->ping_time[i], 100000);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_CONN_PING_INFO);
}

int send_packet_conn_ping_info(struct connection *pc, const struct packet_conn_ping_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CONN_PING_INFO].packet != NULL, -1,
                        "Handler for PACKET_CONN_PING_INFO not installed");
  return pc->phs.handlers->send[PACKET_CONN_PING_INFO].packet(pc, packet);
}

void lsend_packet_conn_ping_info(struct conn_list *dest, const struct packet_conn_ping_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_conn_ping_info(pconn, packet);
  } conn_list_iterate_end;
}

static struct packet_conn_ping *receive_packet_conn_ping_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_conn_ping, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_conn_ping_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_conn_ping_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_CONN_PING);

  log_packet_detailed("packet_conn_ping_100: sending info about ()");
  SEND_PACKET_END(PACKET_CONN_PING);
}

int send_packet_conn_ping(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CONN_PING].no_packet != NULL, -1,
                        "Handler for PACKET_CONN_PING not installed");
  return pc->phs.handlers->send[PACKET_CONN_PING].no_packet(pc);
}

static struct packet_conn_pong *receive_packet_conn_pong_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_conn_pong, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_conn_pong_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_conn_pong_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_CONN_PONG);

  log_packet_detailed("packet_conn_pong_100: sending info about ()");
  SEND_PACKET_END(PACKET_CONN_PONG);
}

int send_packet_conn_pong(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CONN_PONG].no_packet != NULL, -1,
                        "Handler for PACKET_CONN_PONG not installed");
  return pc->phs.handlers->send[PACKET_CONN_PONG].no_packet(pc);
}

static struct packet_client_heartbeat *receive_packet_client_heartbeat_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_client_heartbeat, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_client_heartbeat_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_client_heartbeat_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_CLIENT_HEARTBEAT);

  log_packet_detailed("packet_client_heartbeat_100: sending info about ()");
  SEND_PACKET_END(PACKET_CLIENT_HEARTBEAT);
}

int send_packet_client_heartbeat(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CLIENT_HEARTBEAT].no_packet != NULL, -1,
                        "Handler for PACKET_CLIENT_HEARTBEAT not installed");
  return pc->phs.handlers->send[PACKET_CLIENT_HEARTBEAT].no_packet(pc);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_client_info_100 hash_const

#define cmp_packet_client_info_100 cmp_const

BV_DEFINE(packet_client_info_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_client_info *receive_packet_client_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_client_info_100_fields fields;
  struct packet_client_info *old;
  struct genhash **hash = pc->phs.received + PACKET_CLIENT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_client_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(gui);
    }
    real_packet->gui = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "emerg_version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->emerg_version)) {
    RECEIVE_PACKET_FIELD_ERROR(emerg_version);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "distribution";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->distribution, sizeof(real_packet->distribution))) {
    RECEIVE_PACKET_FIELD_ERROR(distribution);
  }

#endif
  log_packet_detailed("packet_client_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_client_info_100, cmp_packet_client_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'gui'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gui";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(gui);
      }
      real_packet->gui = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'emerg_version'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "emerg_version";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->emerg_version)) {
      RECEIVE_PACKET_FIELD_ERROR(emerg_version);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'distribution'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "distribution";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->distribution, sizeof(real_packet->distribution))) {
      RECEIVE_PACKET_FIELD_ERROR(distribution);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_client_info_100(struct connection *pc, const struct packet_client_info *packet)
{
  const struct packet_client_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_client_info_100_fields fields;
  struct packet_client_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_CLIENT_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_CLIENT_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_client_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_client_info_100, cmp_packet_client_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->gui != real_packet->gui);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->emerg_version != real_packet->emerg_version);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->distribution, real_packet->distribution) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'gui' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gui);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'emerg_version' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "emerg_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->emerg_version);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'distribution' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "distribution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->distribution);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gui);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "emerg_version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->emerg_version);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "distribution";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->distribution);

#endif
  SEND_PACKET_END(PACKET_CLIENT_INFO);
}

int send_packet_client_info(struct connection *pc, const struct packet_client_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_CLIENT_INFO].packet != NULL, -1,
                        "Handler for PACKET_CLIENT_INFO not installed");
  return pc->phs.handlers->send[PACKET_CLIENT_INFO].packet(pc, packet);
}

static struct packet_end_phase *receive_packet_end_phase_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_end_phase, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_end_phase_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_end_phase_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_END_PHASE);

  log_packet_detailed("packet_end_phase_100: sending info about ()");
  SEND_PACKET_END(PACKET_END_PHASE);
}

int send_packet_end_phase(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_END_PHASE].no_packet != NULL, -1,
                        "Handler for PACKET_END_PHASE not installed");
  return pc->phs.handlers->send[PACKET_END_PHASE].no_packet(pc);
}

void lsend_packet_end_phase(struct conn_list *dest)
{
  conn_list_iterate(dest, pconn) {
    send_packet_end_phase(pconn);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_start_phase_100 hash_const

#define cmp_packet_start_phase_100 cmp_const

BV_DEFINE(packet_start_phase_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_start_phase *receive_packet_start_phase_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_start_phase_100_fields fields;
  struct packet_start_phase *old;
  struct genhash **hash = pc->phs.received + PACKET_START_PHASE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_start_phase, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->phase)) {
    RECEIVE_PACKET_FIELD_ERROR(phase);
  }

#endif
  log_packet_detailed("packet_start_phase_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_start_phase_100, cmp_packet_start_phase_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'phase'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "phase";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->phase)) {
      RECEIVE_PACKET_FIELD_ERROR(phase);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_start_phase_100(struct connection *pc, const struct packet_start_phase *packet)
{
  const struct packet_start_phase *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_start_phase_100_fields fields;
  struct packet_start_phase *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_START_PHASE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_START_PHASE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_start_phase_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_start_phase_100, cmp_packet_start_phase_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->phase != real_packet->phase);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'phase' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->phase);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->phase);

#endif
  SEND_PACKET_END(PACKET_START_PHASE);
}

int send_packet_start_phase(struct connection *pc, const struct packet_start_phase *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_START_PHASE].packet != NULL, -1,
                        "Handler for PACKET_START_PHASE not installed");
  return pc->phs.handlers->send[PACKET_START_PHASE].packet(pc, packet);
}

void lsend_packet_start_phase(struct conn_list *dest, const struct packet_start_phase *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_start_phase(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_start_phase(struct connection *pc, int phase)
{
  struct packet_start_phase packet, *real_packet = &packet;

  real_packet->phase = phase;
  
  return send_packet_start_phase(pc, real_packet);
}

void dlsend_packet_start_phase(struct conn_list *dest, int phase)
{
  struct packet_start_phase packet, *real_packet = &packet;

  real_packet->phase = phase;
  
  lsend_packet_start_phase(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_new_year_100 hash_const

#define cmp_packet_new_year_100 cmp_const

BV_DEFINE(packet_new_year_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_new_year *receive_packet_new_year_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_new_year_100_fields fields;
  struct packet_new_year *old;
  struct genhash **hash = pc->phs.received + PACKET_NEW_YEAR;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_new_year, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "year";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->year)) {
    RECEIVE_PACKET_FIELD_ERROR(year);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fragments";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->fragments)) {
    RECEIVE_PACKET_FIELD_ERROR(fragments);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
    RECEIVE_PACKET_FIELD_ERROR(turn);
  }

#endif
  log_packet_detailed("packet_new_year_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_new_year_100, cmp_packet_new_year_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'year'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "year";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->year)) {
      RECEIVE_PACKET_FIELD_ERROR(year);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'fragments'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "fragments";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->fragments)) {
      RECEIVE_PACKET_FIELD_ERROR(fragments);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'turn'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn)) {
      RECEIVE_PACKET_FIELD_ERROR(turn);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_new_year_100(struct connection *pc, const struct packet_new_year *packet)
{
  const struct packet_new_year *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_new_year_100_fields fields;
  struct packet_new_year *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_NEW_YEAR;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_NEW_YEAR);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_new_year_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_new_year_100, cmp_packet_new_year_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->year != real_packet->year);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->fragments != real_packet->fragments);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->turn != real_packet->turn);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'year' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "year";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->year);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'fragments' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fragments";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->fragments);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'turn' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "year";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->year);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fragments";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->fragments);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn);

#endif
  SEND_PACKET_END(PACKET_NEW_YEAR);
}

int send_packet_new_year(struct connection *pc, const struct packet_new_year *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_NEW_YEAR].packet != NULL, -1,
                        "Handler for PACKET_NEW_YEAR not installed");
  return pc->phs.handlers->send[PACKET_NEW_YEAR].packet(pc, packet);
}

void lsend_packet_new_year(struct conn_list *dest, const struct packet_new_year *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_new_year(pconn, packet);
  } conn_list_iterate_end;
}

static struct packet_begin_turn *receive_packet_begin_turn_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_begin_turn, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_begin_turn_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_begin_turn_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_BEGIN_TURN);

  log_packet_detailed("packet_begin_turn_100: sending info about ()");
  SEND_PACKET_END(PACKET_BEGIN_TURN);
}

int send_packet_begin_turn(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_BEGIN_TURN].no_packet != NULL, -1,
                        "Handler for PACKET_BEGIN_TURN not installed");
  return pc->phs.handlers->send[PACKET_BEGIN_TURN].no_packet(pc);
}

void lsend_packet_begin_turn(struct conn_list *dest)
{
  conn_list_iterate(dest, pconn) {
    send_packet_begin_turn(pconn);
  } conn_list_iterate_end;
}

static struct packet_end_turn *receive_packet_end_turn_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_end_turn, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_end_turn_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_end_turn_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_END_TURN);

  log_packet_detailed("packet_end_turn_100: sending info about ()");
  SEND_PACKET_END(PACKET_END_TURN);
}

int send_packet_end_turn(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_END_TURN].no_packet != NULL, -1,
                        "Handler for PACKET_END_TURN not installed");
  return pc->phs.handlers->send[PACKET_END_TURN].no_packet(pc);
}

void lsend_packet_end_turn(struct conn_list *dest)
{
  conn_list_iterate(dest, pconn) {
    send_packet_end_turn(pconn);
  } conn_list_iterate_end;
}

static struct packet_freeze_client *receive_packet_freeze_client_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_freeze_client, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_freeze_client_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_freeze_client_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_FREEZE_CLIENT);

  log_packet_detailed("packet_freeze_client_100: sending info about ()");
  SEND_PACKET_END(PACKET_FREEZE_CLIENT);
}

int send_packet_freeze_client(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_FREEZE_CLIENT].no_packet != NULL, -1,
                        "Handler for PACKET_FREEZE_CLIENT not installed");
  return pc->phs.handlers->send[PACKET_FREEZE_CLIENT].no_packet(pc);
}

void lsend_packet_freeze_client(struct conn_list *dest)
{
  conn_list_iterate(dest, pconn) {
    send_packet_freeze_client(pconn);
  } conn_list_iterate_end;
}

static struct packet_thaw_client *receive_packet_thaw_client_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_thaw_client, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_thaw_client_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_thaw_client_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_THAW_CLIENT);

  log_packet_detailed("packet_thaw_client_100: sending info about ()");
  SEND_PACKET_END(PACKET_THAW_CLIENT);
}

int send_packet_thaw_client(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_THAW_CLIENT].no_packet != NULL, -1,
                        "Handler for PACKET_THAW_CLIENT not installed");
  return pc->phs.handlers->send[PACKET_THAW_CLIENT].no_packet(pc);
}

void lsend_packet_thaw_client(struct conn_list *dest)
{
  conn_list_iterate(dest, pconn) {
    send_packet_thaw_client(pconn);
  } conn_list_iterate_end;
}

static struct packet_spaceship_launch *receive_packet_spaceship_launch_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_spaceship_launch, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_spaceship_launch_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_spaceship_launch_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_SPACESHIP_LAUNCH);

  log_packet_detailed("packet_spaceship_launch_100: sending info about ()");
  SEND_PACKET_END(PACKET_SPACESHIP_LAUNCH);
}

int send_packet_spaceship_launch(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SPACESHIP_LAUNCH].no_packet != NULL, -1,
                        "Handler for PACKET_SPACESHIP_LAUNCH not installed");
  return pc->phs.handlers->send[PACKET_SPACESHIP_LAUNCH].no_packet(pc);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_spaceship_place_100 hash_const

#define cmp_packet_spaceship_place_100 cmp_const

BV_DEFINE(packet_spaceship_place_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_spaceship_place *receive_packet_spaceship_place_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_spaceship_place_100_fields fields;
  struct packet_spaceship_place *old;
  struct genhash **hash = pc->phs.received + PACKET_SPACESHIP_PLACE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_spaceship_place, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->num)) {
    RECEIVE_PACKET_FIELD_ERROR(num);
  }

#endif
  log_packet_detailed("packet_spaceship_place_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_spaceship_place_100, cmp_packet_spaceship_place_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'num'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->num)) {
      RECEIVE_PACKET_FIELD_ERROR(num);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_spaceship_place_100(struct connection *pc, const struct packet_spaceship_place *packet)
{
  const struct packet_spaceship_place *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_spaceship_place_100_fields fields;
  struct packet_spaceship_place *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SPACESHIP_PLACE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SPACESHIP_PLACE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_spaceship_place_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_spaceship_place_100, cmp_packet_spaceship_place_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->num != real_packet->num);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'num' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->num);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->num);

#endif
  SEND_PACKET_END(PACKET_SPACESHIP_PLACE);
}

int send_packet_spaceship_place(struct connection *pc, const struct packet_spaceship_place *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SPACESHIP_PLACE].packet != NULL, -1,
                        "Handler for PACKET_SPACESHIP_PLACE not installed");
  return pc->phs.handlers->send[PACKET_SPACESHIP_PLACE].packet(pc, packet);
}

int dsend_packet_spaceship_place(struct connection *pc, enum spaceship_place_type type, int num)
{
  struct packet_spaceship_place packet, *real_packet = &packet;

  real_packet->type = type;
  real_packet->num = num;
  
  return send_packet_spaceship_place(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_spaceship_info_100(const void *vkey)
{
  const struct packet_spaceship_info *key = (const struct packet_spaceship_info *) vkey;

  return key->player_num;
}

static bool cmp_packet_spaceship_info_100(const void *vkey1, const void *vkey2)
{
  const struct packet_spaceship_info *key1 = (const struct packet_spaceship_info *) vkey1;
  const struct packet_spaceship_info *key2 = (const struct packet_spaceship_info *) vkey2;

  return key1->player_num == key2->player_num;
}
BV_DEFINE(packet_spaceship_info_100_fields, 17);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_spaceship_info *receive_packet_spaceship_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_spaceship_info_100_fields fields;
  struct packet_spaceship_info *old;
  struct genhash **hash = pc->phs.received + PACKET_SPACESHIP_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_spaceship_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_num)) {
    RECEIVE_PACKET_FIELD_ERROR(player_num);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player_num)) {
    RECEIVE_PACKET_FIELD_ERROR(player_num);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sship_state";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->sship_state)) {
    RECEIVE_PACKET_FIELD_ERROR(sship_state);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "structurals";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->structurals)) {
    RECEIVE_PACKET_FIELD_ERROR(structurals);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "components";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->components)) {
    RECEIVE_PACKET_FIELD_ERROR(components);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "modules";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->modules)) {
    RECEIVE_PACKET_FIELD_ERROR(modules);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
    RECEIVE_PACKET_FIELD_ERROR(fuel);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "propulsion";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->propulsion)) {
    RECEIVE_PACKET_FIELD_ERROR(propulsion);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "habitation";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->habitation)) {
    RECEIVE_PACKET_FIELD_ERROR(habitation);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "life_support";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->life_support)) {
    RECEIVE_PACKET_FIELD_ERROR(life_support);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "solar_panels";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->solar_panels)) {
    RECEIVE_PACKET_FIELD_ERROR(solar_panels);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "launch_year";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->launch_year)) {
    RECEIVE_PACKET_FIELD_ERROR(launch_year);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "population";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->population)) {
    RECEIVE_PACKET_FIELD_ERROR(population);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mass";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->mass)) {
    RECEIVE_PACKET_FIELD_ERROR(mass);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "structure";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->structure)) {
    RECEIVE_PACKET_FIELD_ERROR(structure);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "support_rate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->support_rate, 10000)) {
    RECEIVE_PACKET_FIELD_ERROR(support_rate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "energy_rate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->energy_rate, 10000)) {
    RECEIVE_PACKET_FIELD_ERROR(energy_rate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "success_rate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->success_rate, 10000)) {
    RECEIVE_PACKET_FIELD_ERROR(success_rate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "travel_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->travel_time, 10000)) {
    RECEIVE_PACKET_FIELD_ERROR(travel_time);
  }

#endif
  log_packet_detailed("packet_spaceship_info_100: got info about (%d)",
    real_packet->player_num);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_spaceship_info_100, cmp_packet_spaceship_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int player_num = real_packet->player_num;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->player_num = player_num;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'sship_state'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sship_state";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->sship_state)) {
      RECEIVE_PACKET_FIELD_ERROR(sship_state);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'structurals'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "structurals";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->structurals)) {
      RECEIVE_PACKET_FIELD_ERROR(structurals);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'components'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "components";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->components)) {
      RECEIVE_PACKET_FIELD_ERROR(components);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'modules'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "modules";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->modules)) {
      RECEIVE_PACKET_FIELD_ERROR(modules);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'fuel'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "fuel";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
      RECEIVE_PACKET_FIELD_ERROR(fuel);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'propulsion'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "propulsion";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->propulsion)) {
      RECEIVE_PACKET_FIELD_ERROR(propulsion);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'habitation'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "habitation";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->habitation)) {
      RECEIVE_PACKET_FIELD_ERROR(habitation);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'life_support'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "life_support";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->life_support)) {
      RECEIVE_PACKET_FIELD_ERROR(life_support);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'solar_panels'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "solar_panels";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->solar_panels)) {
      RECEIVE_PACKET_FIELD_ERROR(solar_panels);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'launch_year'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "launch_year";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->launch_year)) {
      RECEIVE_PACKET_FIELD_ERROR(launch_year);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'population'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "population";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->population)) {
      RECEIVE_PACKET_FIELD_ERROR(population);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'mass'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "mass";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->mass)) {
      RECEIVE_PACKET_FIELD_ERROR(mass);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'structure'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "structure";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->structure)) {
      RECEIVE_PACKET_FIELD_ERROR(structure);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'support_rate'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "support_rate";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->support_rate, 10000)) {
      RECEIVE_PACKET_FIELD_ERROR(support_rate);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'energy_rate'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "energy_rate";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->energy_rate, 10000)) {
      RECEIVE_PACKET_FIELD_ERROR(energy_rate);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'success_rate'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "success_rate";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->success_rate, 10000)) {
      RECEIVE_PACKET_FIELD_ERROR(success_rate);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'travel_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "travel_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->travel_time, 10000)) {
      RECEIVE_PACKET_FIELD_ERROR(travel_time);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_spaceship_info_100(struct connection *pc, const struct packet_spaceship_info *packet)
{
  const struct packet_spaceship_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_spaceship_info_100_fields fields;
  struct packet_spaceship_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SPACESHIP_INFO;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SPACESHIP_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_spaceship_info_100: sending info about (%d)",
    real_packet->player_num);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_spaceship_info_100, cmp_packet_spaceship_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->sship_state != real_packet->sship_state);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->structurals != real_packet->structurals);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->components != real_packet->components);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->modules != real_packet->modules);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->fuel != real_packet->fuel);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->propulsion != real_packet->propulsion);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->habitation != real_packet->habitation);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (old->life_support != real_packet->life_support);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }

  differ = (old->solar_panels != real_packet->solar_panels);
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }

  differ = (old->launch_year != real_packet->launch_year);
  if (differ) {
    different++;
    BV_SET(fields, 9);
  }

  differ = (old->population != real_packet->population);
  if (differ) {
    different++;
    BV_SET(fields, 10);
  }

  differ = (old->mass != real_packet->mass);
  if (differ) {
    different++;
    BV_SET(fields, 11);
  }

  differ = !BV_ARE_EQUAL(old->structure, real_packet->structure);
  if (differ) {
    different++;
    BV_SET(fields, 12);
  }

  differ = (old->support_rate != real_packet->support_rate);
  if (differ) {
    different++;
    BV_SET(fields, 13);
  }

  differ = (old->energy_rate != real_packet->energy_rate);
  if (differ) {
    different++;
    BV_SET(fields, 14);
  }

  differ = (old->success_rate != real_packet->success_rate);
  if (differ) {
    different++;
    BV_SET(fields, 15);
  }

  differ = (old->travel_time != real_packet->travel_time);
  if (differ) {
    different++;
    BV_SET(fields, 16);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_num);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'sship_state' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sship_state";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->sship_state);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'structurals' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "structurals";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->structurals);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'components' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "components";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->components);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'modules' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "modules";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->modules);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'fuel' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'propulsion' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "propulsion";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->propulsion);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'habitation' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "habitation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->habitation);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'life_support' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "life_support";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->life_support);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'solar_panels' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "solar_panels";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->solar_panels);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'launch_year' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "launch_year";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->launch_year);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'population' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "population";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->population);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'mass' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mass";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->mass);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'structure' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "structure";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->structure);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'support_rate' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "support_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->support_rate, 10000);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'energy_rate' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "energy_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->energy_rate, 10000);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'success_rate' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "success_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->success_rate, 10000);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'travel_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "travel_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->travel_time, 10000);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player_num);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sship_state";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->sship_state);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "structurals";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->structurals);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "components";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->components);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "modules";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->modules);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "propulsion";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->propulsion);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "habitation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->habitation);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "life_support";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->life_support);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "solar_panels";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->solar_panels);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "launch_year";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->launch_year);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "population";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->population);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mass";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->mass);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "structure";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->structure);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "support_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->support_rate, 10000);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "energy_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->energy_rate, 10000);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "success_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->success_rate, 10000);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "travel_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->travel_time, 10000);

#endif
  SEND_PACKET_END(PACKET_SPACESHIP_INFO);
}

int send_packet_spaceship_info(struct connection *pc, const struct packet_spaceship_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SPACESHIP_INFO].packet != NULL, -1,
                        "Handler for PACKET_SPACESHIP_INFO not installed");
  return pc->phs.handlers->send[PACKET_SPACESHIP_INFO].packet(pc, packet);
}

void lsend_packet_spaceship_info(struct conn_list *dest, const struct packet_spaceship_info *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_spaceship_info(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_unit_100 hash_const

#define cmp_packet_ruleset_unit_100 cmp_const

BV_DEFINE(packet_ruleset_unit_100_fields, 48);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_unit *receive_packet_ruleset_unit_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_100_fields fields;
  struct packet_ruleset_unit *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_UNIT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_unit, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_str);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_move";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->sound_move, sizeof(real_packet->sound_move))) {
    RECEIVE_PACKET_FIELD_ERROR(sound_move);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_move_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->sound_move_alt, sizeof(real_packet->sound_move_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(sound_move_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_fight";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->sound_fight, sizeof(real_packet->sound_fight))) {
    RECEIVE_PACKET_FIELD_ERROR(sound_fight);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_fight_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->sound_fight_alt, sizeof(real_packet->sound_fight_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(sound_fight_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_class_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->unit_class_id)) {
    RECEIVE_PACKET_FIELD_ERROR(unit_class_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->build_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(build_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pop_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->pop_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(pop_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attack_strength";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->attack_strength)) {
    RECEIVE_PACKET_FIELD_ERROR(attack_strength);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defense_strength";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->defense_strength)) {
    RECEIVE_PACKET_FIELD_ERROR(defense_strength);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_rate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->move_rate)) {
    RECEIVE_PACKET_FIELD_ERROR(move_rate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_requirement";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech_requirement)) {
    RECEIVE_PACKET_FIELD_ERROR(tech_requirement);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(build_reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->build_reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(build_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->build_reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->build_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(build_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_radius_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->vision_radius_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(vision_radius_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transport_capacity";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->transport_capacity)) {
    RECEIVE_PACKET_FIELD_ERROR(transport_capacity);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
    RECEIVE_PACKET_FIELD_ERROR(hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "firepower";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->firepower)) {
    RECEIVE_PACKET_FIELD_ERROR(firepower);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "obsoleted_by";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->obsoleted_by)) {
    RECEIVE_PACKET_FIELD_ERROR(obsoleted_by);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "converted_to";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->converted_to)) {
    RECEIVE_PACKET_FIELD_ERROR(converted_to);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "convert_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->convert_time)) {
    RECEIVE_PACKET_FIELD_ERROR(convert_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
    RECEIVE_PACKET_FIELD_ERROR(fuel);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->happy_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(happy_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->upkeep[i])) {
        RECEIVE_PACKET_FIELD_ERROR(upkeep);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paratroopers_range";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->paratroopers_range)) {
    RECEIVE_PACKET_FIELD_ERROR(paratroopers_range);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_levels";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran_levels)) {
    RECEIVE_PACKET_FIELD_ERROR(veteran_levels);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_name";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(veteran_name, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->veteran_name[i], sizeof(real_packet->veteran_name[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(veteran_name);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "power_fact";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(power_fact, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->power_fact[i])) {
        RECEIVE_PACKET_FIELD_ERROR(power_fact);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_bonus";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(move_bonus, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint32, &din, &field_addr, &real_packet->move_bonus[i])) {
        RECEIVE_PACKET_FIELD_ERROR(move_bonus);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_raise_chance";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(base_raise_chance, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->base_raise_chance[i])) {
        RECEIVE_PACKET_FIELD_ERROR(base_raise_chance);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "work_raise_chance";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(work_raise_chance, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->work_raise_chance[i])) {
        RECEIVE_PACKET_FIELD_ERROR(work_raise_chance);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bombard_rate";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->bombard_rate)) {
    RECEIVE_PACKET_FIELD_ERROR(bombard_rate);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_size)) {
    RECEIVE_PACKET_FIELD_ERROR(city_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_slots";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_slots)) {
    RECEIVE_PACKET_FIELD_ERROR(city_slots);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tp_defense";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(tp_defense);
    }
    real_packet->tp_defense = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cargo";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->cargo)) {
    RECEIVE_PACKET_FIELD_ERROR(cargo);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "targets";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->targets)) {
    RECEIVE_PACKET_FIELD_ERROR(targets);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "embarks";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->embarks)) {
    RECEIVE_PACKET_FIELD_ERROR(embarks);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disembarks";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->disembarks)) {
    RECEIVE_PACKET_FIELD_ERROR(disembarks);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vlayer";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(vlayer);
    }
    real_packet->vlayer = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "roles";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->roles)) {
    RECEIVE_PACKET_FIELD_ERROR(roles);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worker";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->worker)) {
    RECEIVE_PACKET_FIELD_ERROR(worker);
  }

#endif
  log_packet_detailed("packet_ruleset_unit_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_100, cmp_packet_ruleset_unit_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(id);
      }
      real_packet->id = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'graphic_str'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_str";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_str);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'graphic_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'sound_move'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sound_move";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->sound_move, sizeof(real_packet->sound_move))) {
      RECEIVE_PACKET_FIELD_ERROR(sound_move);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'sound_move_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sound_move_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->sound_move_alt, sizeof(real_packet->sound_move_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(sound_move_alt);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'sound_fight'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sound_fight";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->sound_fight, sizeof(real_packet->sound_fight))) {
      RECEIVE_PACKET_FIELD_ERROR(sound_fight);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'sound_fight_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sound_fight_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->sound_fight_alt, sizeof(real_packet->sound_fight_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(sound_fight_alt);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'unit_class_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit_class_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->unit_class_id)) {
      RECEIVE_PACKET_FIELD_ERROR(unit_class_id);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'build_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "build_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->build_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(build_cost);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'pop_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "pop_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->pop_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(pop_cost);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'attack_strength'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "attack_strength";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->attack_strength)) {
      RECEIVE_PACKET_FIELD_ERROR(attack_strength);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'defense_strength'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "defense_strength";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->defense_strength)) {
      RECEIVE_PACKET_FIELD_ERROR(defense_strength);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'move_rate'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "move_rate";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->move_rate)) {
      RECEIVE_PACKET_FIELD_ERROR(move_rate);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'tech_requirement'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tech_requirement";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tech_requirement)) {
      RECEIVE_PACKET_FIELD_ERROR(tech_requirement);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'build_reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "build_reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(build_reqs_count);
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'build_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "build_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->build_reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(build_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->build_reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->build_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(build_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'vision_radius_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "vision_radius_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->vision_radius_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(vision_radius_sq);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'transport_capacity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "transport_capacity";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->transport_capacity)) {
      RECEIVE_PACKET_FIELD_ERROR(transport_capacity);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
      RECEIVE_PACKET_FIELD_ERROR(hp);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'firepower'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "firepower";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->firepower)) {
      RECEIVE_PACKET_FIELD_ERROR(firepower);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'obsoleted_by'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "obsoleted_by";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->obsoleted_by)) {
      RECEIVE_PACKET_FIELD_ERROR(obsoleted_by);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'converted_to'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "converted_to";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->converted_to)) {
      RECEIVE_PACKET_FIELD_ERROR(converted_to);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'convert_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "convert_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->convert_time)) {
      RECEIVE_PACKET_FIELD_ERROR(convert_time);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'fuel'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "fuel";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
      RECEIVE_PACKET_FIELD_ERROR(fuel);
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'happy_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "happy_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->happy_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(happy_cost);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'upkeep'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "upkeep";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->upkeep[i])) {
          RECEIVE_PACKET_FIELD_ERROR(upkeep);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'paratroopers_range'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "paratroopers_range";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->paratroopers_range)) {
      RECEIVE_PACKET_FIELD_ERROR(paratroopers_range);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'veteran_levels'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran_levels";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran_levels)) {
      RECEIVE_PACKET_FIELD_ERROR(veteran_levels);
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'veteran_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran_name";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(veteran_name, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->veteran_name[i], sizeof(real_packet->veteran_name[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(veteran_name);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  got field 'power_fact'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "power_fact";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(power_fact, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->power_fact[i])) {
          RECEIVE_PACKET_FIELD_ERROR(power_fact);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  got field 'move_bonus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "move_bonus";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(move_bonus, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint32, &din, &field_addr, &real_packet->move_bonus[i])) {
          RECEIVE_PACKET_FIELD_ERROR(move_bonus);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'base_raise_chance'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "base_raise_chance";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(base_raise_chance, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->base_raise_chance[i])) {
          RECEIVE_PACKET_FIELD_ERROR(base_raise_chance);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'work_raise_chance'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "work_raise_chance";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(work_raise_chance, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->work_raise_chance[i])) {
          RECEIVE_PACKET_FIELD_ERROR(work_raise_chance);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  got field 'bombard_rate'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "bombard_rate";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->bombard_rate)) {
      RECEIVE_PACKET_FIELD_ERROR(bombard_rate);
    }
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  got field 'city_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_size)) {
      RECEIVE_PACKET_FIELD_ERROR(city_size);
    }
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  got field 'city_slots'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_slots";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->city_slots)) {
      RECEIVE_PACKET_FIELD_ERROR(city_slots);
    }
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  got field 'tp_defense'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tp_defense";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(tp_defense);
      }
      real_packet->tp_defense = readin;
    }
  }
  if (BV_ISSET(fields, 39)) {
    log_packet_detailed("  got field 'cargo'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cargo";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->cargo)) {
      RECEIVE_PACKET_FIELD_ERROR(cargo);
    }
  }
  if (BV_ISSET(fields, 40)) {
    log_packet_detailed("  got field 'targets'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "targets";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->targets)) {
      RECEIVE_PACKET_FIELD_ERROR(targets);
    }
  }
  if (BV_ISSET(fields, 41)) {
    log_packet_detailed("  got field 'embarks'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "embarks";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->embarks)) {
      RECEIVE_PACKET_FIELD_ERROR(embarks);
    }
  }
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  got field 'disembarks'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "disembarks";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->disembarks)) {
      RECEIVE_PACKET_FIELD_ERROR(disembarks);
    }
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  got field 'vlayer'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "vlayer";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(vlayer);
      }
      real_packet->vlayer = readin;
    }
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  got field 'roles'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "roles";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->roles)) {
      RECEIVE_PACKET_FIELD_ERROR(roles);
    }
  }
  real_packet->worker = BV_ISSET(fields, 47);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_unit_100(struct connection *pc, const struct packet_ruleset_unit *packet)
{
  const struct packet_ruleset_unit *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_100_fields fields;
  struct packet_ruleset_unit *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_UNIT;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_UNIT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_unit_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_100, cmp_packet_ruleset_unit_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->graphic_str, real_packet->graphic_str) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (strcmp(old->graphic_alt, real_packet->graphic_alt) != 0);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (strcmp(old->sound_move, real_packet->sound_move) != 0);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (strcmp(old->sound_move_alt, real_packet->sound_move_alt) != 0);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (strcmp(old->sound_fight, real_packet->sound_fight) != 0);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (strcmp(old->sound_fight_alt, real_packet->sound_fight_alt) != 0);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (old->unit_class_id != real_packet->unit_class_id);
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (old->build_cost != real_packet->build_cost);
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (old->pop_cost != real_packet->pop_cost);
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (old->attack_strength != real_packet->attack_strength);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = (old->defense_strength != real_packet->defense_strength);
  if (differ) {
    BV_SET(fields, 13);
  }

  differ = (old->move_rate != real_packet->move_rate);
  if (differ) {
    BV_SET(fields, 14);
  }

  differ = (old->tech_requirement != real_packet->tech_requirement);
  if (differ) {
    BV_SET(fields, 15);
  }

  differ = (old->build_reqs_count != real_packet->build_reqs_count);
  if (differ) {
    BV_SET(fields, 16);
  }


    {
      differ = (old->build_reqs_count != real_packet->build_reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->build_reqs_count; i++) {
          if (!are_requirements_equal(&old->build_reqs[i], &real_packet->build_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 17);
  }

  differ = (old->vision_radius_sq != real_packet->vision_radius_sq);
  if (differ) {
    BV_SET(fields, 18);
  }

  differ = (old->transport_capacity != real_packet->transport_capacity);
  if (differ) {
    BV_SET(fields, 19);
  }

  differ = (old->hp != real_packet->hp);
  if (differ) {
    BV_SET(fields, 20);
  }

  differ = (old->firepower != real_packet->firepower);
  if (differ) {
    BV_SET(fields, 21);
  }

  differ = (old->obsoleted_by != real_packet->obsoleted_by);
  if (differ) {
    BV_SET(fields, 22);
  }

  differ = (old->converted_to != real_packet->converted_to);
  if (differ) {
    BV_SET(fields, 23);
  }

  differ = (old->convert_time != real_packet->convert_time);
  if (differ) {
    BV_SET(fields, 24);
  }

  differ = (old->fuel != real_packet->fuel);
  if (differ) {
    BV_SET(fields, 25);
  }

  differ = (old->happy_cost != real_packet->happy_cost);
  if (differ) {
    BV_SET(fields, 26);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->upkeep[i] != real_packet->upkeep[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 27);
  }

  differ = (old->paratroopers_range != real_packet->paratroopers_range);
  if (differ) {
    BV_SET(fields, 28);
  }

  differ = (old->veteran_levels != real_packet->veteran_levels);
  if (differ) {
    BV_SET(fields, 29);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (strcmp(old->veteran_name[i], real_packet->veteran_name[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 30);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (old->power_fact[i] != real_packet->power_fact[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 31);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (old->move_bonus[i] != real_packet->move_bonus[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 32);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (old->base_raise_chance[i] != real_packet->base_raise_chance[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 33);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (old->work_raise_chance[i] != real_packet->work_raise_chance[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 34);
  }

  differ = (old->bombard_rate != real_packet->bombard_rate);
  if (differ) {
    BV_SET(fields, 35);
  }

  differ = (old->city_size != real_packet->city_size);
  if (differ) {
    BV_SET(fields, 36);
  }

  differ = (old->city_slots != real_packet->city_slots);
  if (differ) {
    BV_SET(fields, 37);
  }

  differ = (old->tp_defense != real_packet->tp_defense);
  if (differ) {
    BV_SET(fields, 38);
  }

  differ = !BV_ARE_EQUAL(old->cargo, real_packet->cargo);
  if (differ) {
    BV_SET(fields, 39);
  }

  differ = !BV_ARE_EQUAL(old->targets, real_packet->targets);
  if (differ) {
    BV_SET(fields, 40);
  }

  differ = !BV_ARE_EQUAL(old->embarks, real_packet->embarks);
  if (differ) {
    BV_SET(fields, 41);
  }

  differ = !BV_ARE_EQUAL(old->disembarks, real_packet->disembarks);
  if (differ) {
    BV_SET(fields, 42);
  }

  differ = (old->vlayer != real_packet->vlayer);
  if (differ) {
    BV_SET(fields, 43);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 44);
  }

  differ = !BV_ARE_EQUAL(old->flags, real_packet->flags);
  if (differ) {
    BV_SET(fields, 45);
  }

  differ = !BV_ARE_EQUAL(old->roles, real_packet->roles);
  if (differ) {
    BV_SET(fields, 46);
  }

  if (packet->worker) {
    BV_SET(fields, 47);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'graphic_str' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'graphic_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'sound_move' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_move";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->sound_move);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'sound_move_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_move_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->sound_move_alt);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'sound_fight' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_fight";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->sound_fight);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'sound_fight_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_fight_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->sound_fight_alt);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'unit_class_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_class_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->unit_class_id);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'build_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->build_cost);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'pop_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pop_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->pop_cost);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'attack_strength' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attack_strength";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->attack_strength);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'defense_strength' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defense_strength";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->defense_strength);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'move_rate' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->move_rate);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'tech_requirement' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_requirement";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_requirement);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'build_reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_reqs_count);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'build_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->build_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->build_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->build_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'vision_radius_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->vision_radius_sq);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'transport_capacity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transport_capacity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->transport_capacity);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'firepower' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "firepower";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->firepower);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'obsoleted_by' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "obsoleted_by";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->obsoleted_by);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'converted_to' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "converted_to";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->converted_to);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'convert_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "convert_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->convert_time);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'fuel' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'happy_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->happy_cost);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'upkeep' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->upkeep[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'paratroopers_range' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paratroopers_range";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->paratroopers_range);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'veteran_levels' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_levels";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran_levels);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'veteran_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_name";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->veteran_name[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  field 'power_fact' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "power_fact";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->power_fact[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  field 'move_bonus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_bonus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint32, &dout, &field_addr, real_packet->move_bonus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'base_raise_chance' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_raise_chance";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->base_raise_chance[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'work_raise_chance' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "work_raise_chance";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->work_raise_chance[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  field 'bombard_rate' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bombard_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->bombard_rate);
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  field 'city_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_size);
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  field 'city_slots' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_slots";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_slots);
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  field 'tp_defense' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tp_defense";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tp_defense);
  }
  if (BV_ISSET(fields, 39)) {
    log_packet_detailed("  field 'cargo' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cargo";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->cargo);
  }
  if (BV_ISSET(fields, 40)) {
    log_packet_detailed("  field 'targets' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "targets";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->targets);
  }
  if (BV_ISSET(fields, 41)) {
    log_packet_detailed("  field 'embarks' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "embarks";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->embarks);
  }
  if (BV_ISSET(fields, 42)) {
    log_packet_detailed("  field 'disembarks' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disembarks";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->disembarks);
  }
  if (BV_ISSET(fields, 43)) {
    log_packet_detailed("  field 'vlayer' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vlayer";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->vlayer);
  }
  if (BV_ISSET(fields, 44)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }
  if (BV_ISSET(fields, 45)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
  }
  if (BV_ISSET(fields, 46)) {
    log_packet_detailed("  field 'roles' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "roles";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->roles);
  }
  /* field 47 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_move";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->sound_move);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_move_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->sound_move_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_fight";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->sound_fight);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sound_fight_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->sound_fight_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit_class_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->unit_class_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->build_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pop_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->pop_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "attack_strength";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->attack_strength);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defense_strength";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->defense_strength);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->move_rate);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tech_requirement";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tech_requirement);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->build_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->build_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->build_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_radius_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->vision_radius_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transport_capacity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->transport_capacity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "firepower";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->firepower);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "obsoleted_by";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->obsoleted_by);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "converted_to";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->converted_to);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "convert_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->convert_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "happy_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->happy_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->upkeep[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paratroopers_range";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->paratroopers_range);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_levels";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran_levels);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_name";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->veteran_name[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "power_fact";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->power_fact[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_bonus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint32, &dout, &field_addr, real_packet->move_bonus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_raise_chance";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->base_raise_chance[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "work_raise_chance";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->work_raise_chance[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bombard_rate";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->bombard_rate);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_slots";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->city_slots);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tp_defense";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tp_defense);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cargo";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->cargo);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "targets";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->targets);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "embarks";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->embarks);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disembarks";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->disembarks);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vlayer";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->vlayer);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "roles";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->roles);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "worker";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->worker);

#endif
  SEND_PACKET_END(PACKET_RULESET_UNIT);
}

int send_packet_ruleset_unit(struct connection *pc, const struct packet_ruleset_unit *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_UNIT].packet != NULL, -1,
                        "Handler for PACKET_RULESET_UNIT not installed");
  return pc->phs.handlers->send[PACKET_RULESET_UNIT].packet(pc, packet);
}

void lsend_packet_ruleset_unit(struct conn_list *dest, const struct packet_ruleset_unit *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_unit(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_unit_bonus_100 hash_const

#define cmp_packet_ruleset_unit_bonus_100 cmp_const

BV_DEFINE(packet_ruleset_unit_bonus_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_unit_bonus *receive_packet_ruleset_unit_bonus_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_bonus_100_fields fields;
  struct packet_ruleset_unit_bonus *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_UNIT_BONUS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_unit_bonus, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(unit);
    }
    real_packet->unit = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flag";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(flag);
    }
    real_packet->flag = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "quiet";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->quiet)) {
    RECEIVE_PACKET_FIELD_ERROR(quiet);
  }

#endif
  log_packet_detailed("packet_ruleset_unit_bonus_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_bonus_100, cmp_packet_ruleset_unit_bonus_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'unit'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "unit";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(unit);
      }
      real_packet->unit = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'flag'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flag";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(flag);
      }
      real_packet->flag = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }
  real_packet->quiet = BV_ISSET(fields, 4);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_unit_bonus_100(struct connection *pc, const struct packet_ruleset_unit_bonus *packet)
{
  const struct packet_ruleset_unit_bonus *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_bonus_100_fields fields;
  struct packet_ruleset_unit_bonus *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_UNIT_BONUS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_UNIT_BONUS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_unit_bonus_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_bonus_100, cmp_packet_ruleset_unit_bonus_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->unit != real_packet->unit);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->flag != real_packet->flag);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 3);
  }

  if (packet->quiet) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'unit' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->unit);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'flag' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->flag);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->value);
  }
  /* field 4 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unit";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->unit);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->flag);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "quiet";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->quiet);

#endif
  SEND_PACKET_END(PACKET_RULESET_UNIT_BONUS);
}

int send_packet_ruleset_unit_bonus(struct connection *pc, const struct packet_ruleset_unit_bonus *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_UNIT_BONUS].packet != NULL, -1,
                        "Handler for PACKET_RULESET_UNIT_BONUS not installed");
  return pc->phs.handlers->send[PACKET_RULESET_UNIT_BONUS].packet(pc, packet);
}

void lsend_packet_ruleset_unit_bonus(struct conn_list *dest, const struct packet_ruleset_unit_bonus *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_unit_bonus(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_unit_flag_100 hash_const

#define cmp_packet_ruleset_unit_flag_100 cmp_const

BV_DEFINE(packet_ruleset_unit_flag_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_unit_flag *receive_packet_ruleset_unit_flag_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_flag_100_fields fields;
  struct packet_ruleset_unit_flag *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_UNIT_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_unit_flag, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
    RECEIVE_PACKET_FIELD_ERROR(helptxt);
  }

#endif
  log_packet_detailed("packet_ruleset_unit_flag_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_flag_100, cmp_packet_ruleset_unit_flag_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'helptxt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptxt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
      RECEIVE_PACKET_FIELD_ERROR(helptxt);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_unit_flag_100(struct connection *pc, const struct packet_ruleset_unit_flag *packet)
{
  const struct packet_ruleset_unit_flag *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_flag_100_fields fields;
  struct packet_ruleset_unit_flag *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_UNIT_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_UNIT_FLAG);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_unit_flag_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_flag_100, cmp_packet_ruleset_unit_flag_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->helptxt, real_packet->helptxt) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'helptxt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);

#endif
  SEND_PACKET_END(PACKET_RULESET_UNIT_FLAG);
}

int send_packet_ruleset_unit_flag(struct connection *pc, const struct packet_ruleset_unit_flag *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_UNIT_FLAG].packet != NULL, -1,
                        "Handler for PACKET_RULESET_UNIT_FLAG not installed");
  return pc->phs.handlers->send[PACKET_RULESET_UNIT_FLAG].packet(pc, packet);
}

void lsend_packet_ruleset_unit_flag(struct conn_list *dest, const struct packet_ruleset_unit_flag *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_unit_flag(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_unit_class_flag_100 hash_const

#define cmp_packet_ruleset_unit_class_flag_100 cmp_const

BV_DEFINE(packet_ruleset_unit_class_flag_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_unit_class_flag *receive_packet_ruleset_unit_class_flag_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_class_flag_100_fields fields;
  struct packet_ruleset_unit_class_flag *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_UNIT_CLASS_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_unit_class_flag, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
    RECEIVE_PACKET_FIELD_ERROR(helptxt);
  }

#endif
  log_packet_detailed("packet_ruleset_unit_class_flag_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_class_flag_100, cmp_packet_ruleset_unit_class_flag_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'helptxt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptxt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
      RECEIVE_PACKET_FIELD_ERROR(helptxt);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_unit_class_flag_100(struct connection *pc, const struct packet_ruleset_unit_class_flag *packet)
{
  const struct packet_ruleset_unit_class_flag *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_class_flag_100_fields fields;
  struct packet_ruleset_unit_class_flag *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_UNIT_CLASS_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_UNIT_CLASS_FLAG);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_unit_class_flag_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_class_flag_100, cmp_packet_ruleset_unit_class_flag_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->helptxt, real_packet->helptxt) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'helptxt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);

#endif
  SEND_PACKET_END(PACKET_RULESET_UNIT_CLASS_FLAG);
}

int send_packet_ruleset_unit_class_flag(struct connection *pc, const struct packet_ruleset_unit_class_flag *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_UNIT_CLASS_FLAG].packet != NULL, -1,
                        "Handler for PACKET_RULESET_UNIT_CLASS_FLAG not installed");
  return pc->phs.handlers->send[PACKET_RULESET_UNIT_CLASS_FLAG].packet(pc, packet);
}

void lsend_packet_ruleset_unit_class_flag(struct conn_list *dest, const struct packet_ruleset_unit_class_flag *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_unit_class_flag(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_game_100 hash_const

#define cmp_packet_ruleset_game_100 cmp_const

BV_DEFINE(packet_ruleset_game_100_fields, 14);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_game *receive_packet_ruleset_game_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_game_100_fields fields;
  struct packet_ruleset_game *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_GAME;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_game, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_specialist";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->default_specialist)) {
    RECEIVE_PACKET_FIELD_ERROR(default_specialist);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_techs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->global_init_techs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(global_init_techs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_techs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->global_init_techs_count > MAX_NUM_TECH_LIST) {
      RECEIVE_PACKET_FIELD_ERROR(global_init_techs, ": truncation array");
    }
    for (i = 0; i < real_packet->global_init_techs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->global_init_techs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(global_init_techs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_buildings_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->global_init_buildings_count)) {
    RECEIVE_PACKET_FIELD_ERROR(global_init_buildings_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_buildings";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->global_init_buildings_count > MAX_NUM_BUILDING_LIST) {
      RECEIVE_PACKET_FIELD_ERROR(global_init_buildings, ": truncation array");
    }
    for (i = 0; i < real_packet->global_init_buildings_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      {
        int readin;
  
        if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
          RECEIVE_PACKET_FIELD_ERROR(global_init_buildings);
        }
        real_packet->global_init_buildings[i] = readin;
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_levels";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran_levels)) {
    RECEIVE_PACKET_FIELD_ERROR(veteran_levels);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_name";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(veteran_name, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->veteran_name[i], sizeof(real_packet->veteran_name[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(veteran_name);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "power_fact";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(power_fact, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->power_fact[i])) {
        RECEIVE_PACKET_FIELD_ERROR(power_fact);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_bonus";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(move_bonus, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint32, &din, &field_addr, &real_packet->move_bonus[i])) {
        RECEIVE_PACKET_FIELD_ERROR(move_bonus);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_raise_chance";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(base_raise_chance, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->base_raise_chance[i])) {
        RECEIVE_PACKET_FIELD_ERROR(base_raise_chance);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "work_raise_chance";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->veteran_levels > MAX_VET_LEVELS) {
      RECEIVE_PACKET_FIELD_ERROR(work_raise_chance, ": truncation array");
    }
    for (i = 0; i < real_packet->veteran_levels; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->work_raise_chance[i])) {
        RECEIVE_PACKET_FIELD_ERROR(work_raise_chance);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "background_red";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->background_red)) {
    RECEIVE_PACKET_FIELD_ERROR(background_red);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "background_green";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->background_green)) {
    RECEIVE_PACKET_FIELD_ERROR(background_green);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "background_blue";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->background_blue)) {
    RECEIVE_PACKET_FIELD_ERROR(background_blue);
  }

#endif
  log_packet_detailed("packet_ruleset_game_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_game_100, cmp_packet_ruleset_game_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'default_specialist'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "default_specialist";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->default_specialist)) {
      RECEIVE_PACKET_FIELD_ERROR(default_specialist);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'global_init_techs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "global_init_techs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->global_init_techs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(global_init_techs_count);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'global_init_techs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "global_init_techs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->global_init_techs_count > MAX_NUM_TECH_LIST) {
        RECEIVE_PACKET_FIELD_ERROR(global_init_techs, ": truncation array");
      }
      for (i = 0; i < real_packet->global_init_techs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->global_init_techs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(global_init_techs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'global_init_buildings_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "global_init_buildings_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->global_init_buildings_count)) {
      RECEIVE_PACKET_FIELD_ERROR(global_init_buildings_count);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'global_init_buildings'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "global_init_buildings";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->global_init_buildings_count > MAX_NUM_BUILDING_LIST) {
        RECEIVE_PACKET_FIELD_ERROR(global_init_buildings, ": truncation array");
      }
      for (i = 0; i < real_packet->global_init_buildings_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        {
          int readin;
    
          if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
            RECEIVE_PACKET_FIELD_ERROR(global_init_buildings);
          }
          real_packet->global_init_buildings[i] = readin;
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'veteran_levels'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran_levels";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran_levels)) {
      RECEIVE_PACKET_FIELD_ERROR(veteran_levels);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'veteran_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran_name";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(veteran_name, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->veteran_name[i], sizeof(real_packet->veteran_name[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(veteran_name);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'power_fact'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "power_fact";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(power_fact, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->power_fact[i])) {
          RECEIVE_PACKET_FIELD_ERROR(power_fact);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'move_bonus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "move_bonus";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(move_bonus, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint32, &din, &field_addr, &real_packet->move_bonus[i])) {
          RECEIVE_PACKET_FIELD_ERROR(move_bonus);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'base_raise_chance'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "base_raise_chance";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(base_raise_chance, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->base_raise_chance[i])) {
          RECEIVE_PACKET_FIELD_ERROR(base_raise_chance);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'work_raise_chance'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "work_raise_chance";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->veteran_levels > MAX_VET_LEVELS) {
        RECEIVE_PACKET_FIELD_ERROR(work_raise_chance, ": truncation array");
      }
      for (i = 0; i < real_packet->veteran_levels; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->work_raise_chance[i])) {
          RECEIVE_PACKET_FIELD_ERROR(work_raise_chance);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'background_red'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "background_red";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->background_red)) {
      RECEIVE_PACKET_FIELD_ERROR(background_red);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'background_green'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "background_green";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->background_green)) {
      RECEIVE_PACKET_FIELD_ERROR(background_green);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'background_blue'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "background_blue";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->background_blue)) {
      RECEIVE_PACKET_FIELD_ERROR(background_blue);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_game_100(struct connection *pc, const struct packet_ruleset_game *packet)
{
  const struct packet_ruleset_game *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_game_100_fields fields;
  struct packet_ruleset_game *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_GAME;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_GAME);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_game_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_game_100, cmp_packet_ruleset_game_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->default_specialist != real_packet->default_specialist);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->global_init_techs_count != real_packet->global_init_techs_count);
  if (differ) {
    BV_SET(fields, 1);
  }


    {
      differ = (old->global_init_techs_count != real_packet->global_init_techs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->global_init_techs_count; i++) {
          if (old->global_init_techs[i] != real_packet->global_init_techs[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->global_init_buildings_count != real_packet->global_init_buildings_count);
  if (differ) {
    BV_SET(fields, 3);
  }


    {
      differ = (old->global_init_buildings_count != real_packet->global_init_buildings_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->global_init_buildings_count; i++) {
          if (old->global_init_buildings[i] != real_packet->global_init_buildings[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->veteran_levels != real_packet->veteran_levels);
  if (differ) {
    BV_SET(fields, 5);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (strcmp(old->veteran_name[i], real_packet->veteran_name[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 6);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (old->power_fact[i] != real_packet->power_fact[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 7);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (old->move_bonus[i] != real_packet->move_bonus[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 8);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (old->base_raise_chance[i] != real_packet->base_raise_chance[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 9);
  }


    {
      differ = (old->veteran_levels != real_packet->veteran_levels);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->veteran_levels; i++) {
          if (old->work_raise_chance[i] != real_packet->work_raise_chance[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (old->background_red != real_packet->background_red);
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (old->background_green != real_packet->background_green);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = (old->background_blue != real_packet->background_blue);
  if (differ) {
    BV_SET(fields, 13);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'default_specialist' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_specialist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->default_specialist);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'global_init_techs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_techs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->global_init_techs_count);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'global_init_techs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_techs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->global_init_techs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->global_init_techs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->global_init_techs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'global_init_buildings_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_buildings_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->global_init_buildings_count);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'global_init_buildings' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_buildings";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->global_init_buildings_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->global_init_buildings_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->global_init_buildings[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'veteran_levels' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_levels";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran_levels);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'veteran_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_name";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->veteran_name[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'power_fact' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "power_fact";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->power_fact[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'move_bonus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_bonus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint32, &dout, &field_addr, real_packet->move_bonus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'base_raise_chance' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_raise_chance";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->base_raise_chance[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'work_raise_chance' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "work_raise_chance";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->work_raise_chance[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'background_red' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "background_red";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->background_red);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'background_green' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "background_green";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->background_green);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'background_blue' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "background_blue";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->background_blue);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_specialist";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->default_specialist);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_techs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->global_init_techs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_techs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->global_init_techs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->global_init_techs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->global_init_techs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_buildings_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->global_init_buildings_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "global_init_buildings";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->global_init_buildings_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->global_init_buildings_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->global_init_buildings[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_levels";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran_levels);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran_name";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->veteran_name[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "power_fact";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->power_fact[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_bonus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint32, &dout, &field_addr, real_packet->move_bonus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_raise_chance";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->base_raise_chance[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "work_raise_chance";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->veteran_levels);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->veteran_levels; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->work_raise_chance[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "background_red";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->background_red);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "background_green";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->background_green);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "background_blue";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->background_blue);

#endif
  SEND_PACKET_END(PACKET_RULESET_GAME);
}

int send_packet_ruleset_game(struct connection *pc, const struct packet_ruleset_game *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_GAME].packet != NULL, -1,
                        "Handler for PACKET_RULESET_GAME not installed");
  return pc->phs.handlers->send[PACKET_RULESET_GAME].packet(pc, packet);
}

void lsend_packet_ruleset_game(struct conn_list *dest, const struct packet_ruleset_game *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_game(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_specialist_100 hash_const

#define cmp_packet_ruleset_specialist_100 cmp_const

BV_DEFINE(packet_ruleset_specialist_100_fields, 9);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_specialist *receive_packet_ruleset_specialist_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_specialist_100_fields fields;
  struct packet_ruleset_specialist *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_specialist, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plural_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->plural_name, sizeof(real_packet->plural_name))) {
    RECEIVE_PACKET_FIELD_ERROR(plural_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "short_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->short_name, sizeof(real_packet->short_name))) {
    RECEIVE_PACKET_FIELD_ERROR(short_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_str);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }

#endif
  log_packet_detailed("packet_ruleset_specialist_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_specialist_100, cmp_packet_ruleset_specialist_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(id);
      }
      real_packet->id = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'plural_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "plural_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->plural_name, sizeof(real_packet->plural_name))) {
      RECEIVE_PACKET_FIELD_ERROR(plural_name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'short_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "short_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->short_name, sizeof(real_packet->short_name))) {
      RECEIVE_PACKET_FIELD_ERROR(short_name);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'graphic_str'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_str";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_str);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'graphic_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_specialist_100(struct connection *pc, const struct packet_ruleset_specialist *packet)
{
  const struct packet_ruleset_specialist *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_specialist_100_fields fields;
  struct packet_ruleset_specialist *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_SPECIALIST;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_SPECIALIST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_specialist_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_specialist_100, cmp_packet_ruleset_specialist_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->plural_name, real_packet->plural_name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->short_name, real_packet->short_name) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (strcmp(old->graphic_str, real_packet->graphic_str) != 0);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (strcmp(old->graphic_alt, real_packet->graphic_alt) != 0);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 6);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 8);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'plural_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plural_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->plural_name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'short_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "short_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->short_name);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'graphic_str' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'graphic_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plural_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->plural_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "short_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->short_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);

#endif
  SEND_PACKET_END(PACKET_RULESET_SPECIALIST);
}

int send_packet_ruleset_specialist(struct connection *pc, const struct packet_ruleset_specialist *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_SPECIALIST].packet != NULL, -1,
                        "Handler for PACKET_RULESET_SPECIALIST not installed");
  return pc->phs.handlers->send[PACKET_RULESET_SPECIALIST].packet(pc, packet);
}

void lsend_packet_ruleset_specialist(struct conn_list *dest, const struct packet_ruleset_specialist *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_specialist(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_government_ruler_title_100 hash_const

#define cmp_packet_ruleset_government_ruler_title_100 cmp_const

BV_DEFINE(packet_ruleset_government_ruler_title_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_government_ruler_title *receive_packet_ruleset_government_ruler_title_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_government_ruler_title_100_fields fields;
  struct packet_ruleset_government_ruler_title *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_GOVERNMENT_RULER_TITLE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_government_ruler_title, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gov";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(gov);
    }
    real_packet->gov = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(nation);
    }
    real_packet->nation = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "male_title";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->male_title, sizeof(real_packet->male_title))) {
    RECEIVE_PACKET_FIELD_ERROR(male_title);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "female_title";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->female_title, sizeof(real_packet->female_title))) {
    RECEIVE_PACKET_FIELD_ERROR(female_title);
  }

#endif
  log_packet_detailed("packet_ruleset_government_ruler_title_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_government_ruler_title_100, cmp_packet_ruleset_government_ruler_title_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'gov'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gov";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(gov);
      }
      real_packet->gov = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'nation'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(nation);
      }
      real_packet->nation = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'male_title'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "male_title";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->male_title, sizeof(real_packet->male_title))) {
      RECEIVE_PACKET_FIELD_ERROR(male_title);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'female_title'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "female_title";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->female_title, sizeof(real_packet->female_title))) {
      RECEIVE_PACKET_FIELD_ERROR(female_title);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_government_ruler_title_100(struct connection *pc, const struct packet_ruleset_government_ruler_title *packet)
{
  const struct packet_ruleset_government_ruler_title *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_government_ruler_title_100_fields fields;
  struct packet_ruleset_government_ruler_title *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_GOVERNMENT_RULER_TITLE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_GOVERNMENT_RULER_TITLE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_government_ruler_title_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_government_ruler_title_100, cmp_packet_ruleset_government_ruler_title_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->gov != real_packet->gov);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->nation != real_packet->nation);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->male_title, real_packet->male_title) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->female_title, real_packet->female_title) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'gov' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gov";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->gov);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'nation' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nation);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'male_title' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "male_title";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->male_title);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'female_title' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "female_title";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->female_title);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gov";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->gov);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nation);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "male_title";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->male_title);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "female_title";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->female_title);

#endif
  SEND_PACKET_END(PACKET_RULESET_GOVERNMENT_RULER_TITLE);
}

int send_packet_ruleset_government_ruler_title(struct connection *pc, const struct packet_ruleset_government_ruler_title *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_GOVERNMENT_RULER_TITLE].packet != NULL, -1,
                        "Handler for PACKET_RULESET_GOVERNMENT_RULER_TITLE not installed");
  return pc->phs.handlers->send[PACKET_RULESET_GOVERNMENT_RULER_TITLE].packet(pc, packet);
}

void lsend_packet_ruleset_government_ruler_title(struct conn_list *dest, const struct packet_ruleset_government_ruler_title *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_government_ruler_title(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_tech_100 hash_const

#define cmp_packet_ruleset_tech_100 cmp_const

BV_DEFINE(packet_ruleset_tech_100_fields, 14);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_tech *receive_packet_ruleset_tech_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_tech_100_fields fields;
  struct packet_ruleset_tech *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_TECH;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_tech, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "root_req";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->root_req)) {
    RECEIVE_PACKET_FIELD_ERROR(root_req);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "research_reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->research_reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(research_reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "research_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->research_reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(research_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->research_reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->research_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(research_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tclass";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tclass)) {
    RECEIVE_PACKET_FIELD_ERROR(tclass);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removed";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->removed)) {
    RECEIVE_PACKET_FIELD_ERROR(removed);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->cost, 100)) {
    RECEIVE_PACKET_FIELD_ERROR(cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->num_reqs)) {
    RECEIVE_PACKET_FIELD_ERROR(num_reqs);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_str);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
  }

#endif
  log_packet_detailed("packet_ruleset_tech_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_tech_100, cmp_packet_ruleset_tech_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'root_req'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "root_req";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->root_req)) {
      RECEIVE_PACKET_FIELD_ERROR(root_req);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'research_reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "research_reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->research_reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(research_reqs_count);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'research_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "research_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->research_reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(research_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->research_reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->research_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(research_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'tclass'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tclass";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tclass)) {
      RECEIVE_PACKET_FIELD_ERROR(tclass);
    }
  }
  real_packet->removed = BV_ISSET(fields, 5);
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(ufloat, &din, &field_addr, &real_packet->cost, 100)) {
      RECEIVE_PACKET_FIELD_ERROR(cost);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'num_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->num_reqs)) {
      RECEIVE_PACKET_FIELD_ERROR(num_reqs);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'graphic_str'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_str";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_str);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'graphic_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_tech_100(struct connection *pc, const struct packet_ruleset_tech *packet)
{
  const struct packet_ruleset_tech *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_tech_100_fields fields;
  struct packet_ruleset_tech *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_TECH;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_TECH);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_tech_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_tech_100, cmp_packet_ruleset_tech_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->root_req != real_packet->root_req);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->research_reqs_count != real_packet->research_reqs_count);
  if (differ) {
    BV_SET(fields, 2);
  }


    {
      differ = (old->research_reqs_count != real_packet->research_reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->research_reqs_count; i++) {
          if (!are_requirements_equal(&old->research_reqs[i], &real_packet->research_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->tclass != real_packet->tclass);
  if (differ) {
    BV_SET(fields, 4);
  }

  if (packet->removed) {
    BV_SET(fields, 5);
  }

  differ = !BV_ARE_EQUAL(old->flags, real_packet->flags);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->cost != real_packet->cost);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->num_reqs != real_packet->num_reqs);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (strcmp(old->graphic_str, real_packet->graphic_str) != 0);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = (strcmp(old->graphic_alt, real_packet->graphic_alt) != 0);
  if (differ) {
    BV_SET(fields, 13);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'root_req' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "root_req";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->root_req);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'research_reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "research_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->research_reqs_count);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'research_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "research_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->research_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->research_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->research_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'tclass' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tclass";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tclass);
  }
  /* field 5 is folded into the header */
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->cost, 100);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'num_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_reqs";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->num_reqs);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'graphic_str' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'graphic_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "root_req";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->root_req);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "research_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->research_reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "research_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->research_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->research_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->research_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tclass";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tclass);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removed";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->removed);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(ufloat, &dout, &field_addr, real_packet->cost, 100);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_reqs";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->num_reqs);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);

#endif
  SEND_PACKET_END(PACKET_RULESET_TECH);
}

int send_packet_ruleset_tech(struct connection *pc, const struct packet_ruleset_tech *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_TECH].packet != NULL, -1,
                        "Handler for PACKET_RULESET_TECH not installed");
  return pc->phs.handlers->send[PACKET_RULESET_TECH].packet(pc, packet);
}

void lsend_packet_ruleset_tech(struct conn_list *dest, const struct packet_ruleset_tech *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_tech(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_tech_class_100 hash_const

#define cmp_packet_ruleset_tech_class_100 cmp_const

BV_DEFINE(packet_ruleset_tech_class_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_tech_class *receive_packet_ruleset_tech_class_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_tech_class_100_fields fields;
  struct packet_ruleset_tech_class *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_TECH_CLASS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_tech_class, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->cost_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(cost_pct);
  }

#endif
  log_packet_detailed("packet_ruleset_tech_class_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_tech_class_100, cmp_packet_ruleset_tech_class_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'cost_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cost_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->cost_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(cost_pct);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_tech_class_100(struct connection *pc, const struct packet_ruleset_tech_class *packet)
{
  const struct packet_ruleset_tech_class *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_tech_class_100_fields fields;
  struct packet_ruleset_tech_class *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_TECH_CLASS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_TECH_CLASS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_tech_class_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_tech_class_100, cmp_packet_ruleset_tech_class_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->cost_pct != real_packet->cost_pct);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'cost_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->cost_pct);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cost_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->cost_pct);

#endif
  SEND_PACKET_END(PACKET_RULESET_TECH_CLASS);
}

int send_packet_ruleset_tech_class(struct connection *pc, const struct packet_ruleset_tech_class *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_TECH_CLASS].packet != NULL, -1,
                        "Handler for PACKET_RULESET_TECH_CLASS not installed");
  return pc->phs.handlers->send[PACKET_RULESET_TECH_CLASS].packet(pc, packet);
}

void lsend_packet_ruleset_tech_class(struct conn_list *dest, const struct packet_ruleset_tech_class *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_tech_class(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_tech_flag_100 hash_const

#define cmp_packet_ruleset_tech_flag_100 cmp_const

BV_DEFINE(packet_ruleset_tech_flag_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_tech_flag *receive_packet_ruleset_tech_flag_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_tech_flag_100_fields fields;
  struct packet_ruleset_tech_flag *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_TECH_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_tech_flag, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
    RECEIVE_PACKET_FIELD_ERROR(helptxt);
  }

#endif
  log_packet_detailed("packet_ruleset_tech_flag_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_tech_flag_100, cmp_packet_ruleset_tech_flag_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'helptxt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptxt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
      RECEIVE_PACKET_FIELD_ERROR(helptxt);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_tech_flag_100(struct connection *pc, const struct packet_ruleset_tech_flag *packet)
{
  const struct packet_ruleset_tech_flag *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_tech_flag_100_fields fields;
  struct packet_ruleset_tech_flag *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_TECH_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_TECH_FLAG);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_tech_flag_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_tech_flag_100, cmp_packet_ruleset_tech_flag_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->helptxt, real_packet->helptxt) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'helptxt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);

#endif
  SEND_PACKET_END(PACKET_RULESET_TECH_FLAG);
}

int send_packet_ruleset_tech_flag(struct connection *pc, const struct packet_ruleset_tech_flag *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_TECH_FLAG].packet != NULL, -1,
                        "Handler for PACKET_RULESET_TECH_FLAG not installed");
  return pc->phs.handlers->send[PACKET_RULESET_TECH_FLAG].packet(pc, packet);
}

void lsend_packet_ruleset_tech_flag(struct conn_list *dest, const struct packet_ruleset_tech_flag *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_tech_flag(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_government_100 hash_const

#define cmp_packet_ruleset_government_100 cmp_const

BV_DEFINE(packet_ruleset_government_100_fields, 8);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_government *receive_packet_ruleset_government_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_government_100_fields fields;
  struct packet_ruleset_government *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_GOVERNMENT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_government, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_str);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }

#endif
  log_packet_detailed("packet_ruleset_government_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_government_100, cmp_packet_ruleset_government_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(id);
      }
      real_packet->id = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'graphic_str'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_str";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_str);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'graphic_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_government_100(struct connection *pc, const struct packet_ruleset_government *packet)
{
  const struct packet_ruleset_government *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_government_100_fields fields;
  struct packet_ruleset_government *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_GOVERNMENT;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_GOVERNMENT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_government_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_government_100, cmp_packet_ruleset_government_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 1);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (strcmp(old->graphic_str, real_packet->graphic_str) != 0);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (strcmp(old->graphic_alt, real_packet->graphic_alt) != 0);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 7);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'graphic_str' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'graphic_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);

#endif
  SEND_PACKET_END(PACKET_RULESET_GOVERNMENT);
}

int send_packet_ruleset_government(struct connection *pc, const struct packet_ruleset_government *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_GOVERNMENT].packet != NULL, -1,
                        "Handler for PACKET_RULESET_GOVERNMENT not installed");
  return pc->phs.handlers->send[PACKET_RULESET_GOVERNMENT].packet(pc, packet);
}

void lsend_packet_ruleset_government(struct conn_list *dest, const struct packet_ruleset_government *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_government(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_terrain_control_100 hash_const

#define cmp_packet_ruleset_terrain_control_100 cmp_const

BV_DEFINE(packet_ruleset_terrain_control_100_fields, 12);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_terrain_control *receive_packet_ruleset_terrain_control_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_terrain_control_100_fields fields;
  struct packet_ruleset_terrain_control *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_TERRAIN_CONTROL;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_terrain_control, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ocean_reclaim_requirement_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ocean_reclaim_requirement_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(ocean_reclaim_requirement_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "land_channel_requirement_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->land_channel_requirement_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(land_channel_requirement_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_thaw_requirement_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->terrain_thaw_requirement_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(terrain_thaw_requirement_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_freeze_requirement_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->terrain_freeze_requirement_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(terrain_freeze_requirement_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lake_max_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->lake_max_size)) {
    RECEIVE_PACKET_FIELD_ERROR(lake_max_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_start_native_area";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->min_start_native_area)) {
    RECEIVE_PACKET_FIELD_ERROR(min_start_native_area);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_fragments";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->move_fragments)) {
    RECEIVE_PACKET_FIELD_ERROR(move_fragments);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "igter_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->igter_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(igter_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pythagorean_diagonal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->pythagorean_diagonal)) {
    RECEIVE_PACKET_FIELD_ERROR(pythagorean_diagonal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infrapoints";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->infrapoints)) {
    RECEIVE_PACKET_FIELD_ERROR(infrapoints);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type_base0";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->gui_type_base0, sizeof(real_packet->gui_type_base0))) {
    RECEIVE_PACKET_FIELD_ERROR(gui_type_base0);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type_base1";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->gui_type_base1, sizeof(real_packet->gui_type_base1))) {
    RECEIVE_PACKET_FIELD_ERROR(gui_type_base1);
  }

#endif
  log_packet_detailed("packet_ruleset_terrain_control_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_terrain_control_100, cmp_packet_ruleset_terrain_control_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'ocean_reclaim_requirement_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ocean_reclaim_requirement_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ocean_reclaim_requirement_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(ocean_reclaim_requirement_pct);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'land_channel_requirement_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "land_channel_requirement_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->land_channel_requirement_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(land_channel_requirement_pct);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'terrain_thaw_requirement_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "terrain_thaw_requirement_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->terrain_thaw_requirement_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(terrain_thaw_requirement_pct);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'terrain_freeze_requirement_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "terrain_freeze_requirement_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->terrain_freeze_requirement_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(terrain_freeze_requirement_pct);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'lake_max_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "lake_max_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->lake_max_size)) {
      RECEIVE_PACKET_FIELD_ERROR(lake_max_size);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'min_start_native_area'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "min_start_native_area";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->min_start_native_area)) {
      RECEIVE_PACKET_FIELD_ERROR(min_start_native_area);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'move_fragments'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "move_fragments";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->move_fragments)) {
      RECEIVE_PACKET_FIELD_ERROR(move_fragments);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'igter_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "igter_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->igter_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(igter_cost);
    }
  }
  real_packet->pythagorean_diagonal = BV_ISSET(fields, 8);
  real_packet->infrapoints = BV_ISSET(fields, 9);
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'gui_type_base0'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gui_type_base0";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->gui_type_base0, sizeof(real_packet->gui_type_base0))) {
      RECEIVE_PACKET_FIELD_ERROR(gui_type_base0);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'gui_type_base1'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gui_type_base1";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->gui_type_base1, sizeof(real_packet->gui_type_base1))) {
      RECEIVE_PACKET_FIELD_ERROR(gui_type_base1);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_terrain_control_100(struct connection *pc, const struct packet_ruleset_terrain_control *packet)
{
  const struct packet_ruleset_terrain_control *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_terrain_control_100_fields fields;
  struct packet_ruleset_terrain_control *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_TERRAIN_CONTROL;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_TERRAIN_CONTROL);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_terrain_control_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_terrain_control_100, cmp_packet_ruleset_terrain_control_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->ocean_reclaim_requirement_pct != real_packet->ocean_reclaim_requirement_pct);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->land_channel_requirement_pct != real_packet->land_channel_requirement_pct);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->terrain_thaw_requirement_pct != real_packet->terrain_thaw_requirement_pct);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->terrain_freeze_requirement_pct != real_packet->terrain_freeze_requirement_pct);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->lake_max_size != real_packet->lake_max_size);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->min_start_native_area != real_packet->min_start_native_area);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->move_fragments != real_packet->move_fragments);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->igter_cost != real_packet->igter_cost);
  if (differ) {
    BV_SET(fields, 7);
  }

  if (packet->pythagorean_diagonal) {
    BV_SET(fields, 8);
  }

  if (packet->infrapoints) {
    BV_SET(fields, 9);
  }

  differ = (strcmp(old->gui_type_base0, real_packet->gui_type_base0) != 0);
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (strcmp(old->gui_type_base1, real_packet->gui_type_base1) != 0);
  if (differ) {
    BV_SET(fields, 11);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'ocean_reclaim_requirement_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ocean_reclaim_requirement_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ocean_reclaim_requirement_pct);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'land_channel_requirement_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "land_channel_requirement_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->land_channel_requirement_pct);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'terrain_thaw_requirement_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_thaw_requirement_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain_thaw_requirement_pct);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'terrain_freeze_requirement_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_freeze_requirement_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain_freeze_requirement_pct);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'lake_max_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lake_max_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->lake_max_size);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'min_start_native_area' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_start_native_area";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->min_start_native_area);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'move_fragments' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_fragments";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->move_fragments);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'igter_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "igter_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->igter_cost);
  }
  /* field 8 is folded into the header */
  /* field 9 is folded into the header */
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'gui_type_base0' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type_base0";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->gui_type_base0);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'gui_type_base1' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type_base1";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->gui_type_base1);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ocean_reclaim_requirement_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ocean_reclaim_requirement_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "land_channel_requirement_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->land_channel_requirement_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_thaw_requirement_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain_thaw_requirement_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_freeze_requirement_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain_freeze_requirement_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lake_max_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->lake_max_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_start_native_area";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->min_start_native_area);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_fragments";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->move_fragments);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "igter_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->igter_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pythagorean_diagonal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->pythagorean_diagonal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infrapoints";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->infrapoints);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type_base0";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->gui_type_base0);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type_base1";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->gui_type_base1);

#endif
  SEND_PACKET_END(PACKET_RULESET_TERRAIN_CONTROL);
}

int send_packet_ruleset_terrain_control(struct connection *pc, const struct packet_ruleset_terrain_control *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_TERRAIN_CONTROL].packet != NULL, -1,
                        "Handler for PACKET_RULESET_TERRAIN_CONTROL not installed");
  return pc->phs.handlers->send[PACKET_RULESET_TERRAIN_CONTROL].packet(pc, packet);
}

void lsend_packet_ruleset_terrain_control(struct conn_list *dest, const struct packet_ruleset_terrain_control *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_terrain_control(pconn, packet);
  } conn_list_iterate_end;
}

static struct packet_rulesets_ready *receive_packet_rulesets_ready_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_rulesets_ready, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_rulesets_ready_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_rulesets_ready_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_RULESETS_READY);

  log_packet_detailed("packet_rulesets_ready_100: sending info about ()");
  SEND_PACKET_END(PACKET_RULESETS_READY);
}

int send_packet_rulesets_ready(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESETS_READY].no_packet != NULL, -1,
                        "Handler for PACKET_RULESETS_READY not installed");
  return pc->phs.handlers->send[PACKET_RULESETS_READY].no_packet(pc);
}

void lsend_packet_rulesets_ready(struct conn_list *dest)
{
  conn_list_iterate(dest, pconn) {
    send_packet_rulesets_ready(pconn);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_nation_sets_100 hash_const

#define cmp_packet_ruleset_nation_sets_100 cmp_const

BV_DEFINE(packet_ruleset_nation_sets_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_nation_sets *receive_packet_ruleset_nation_sets_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_nation_sets_100_fields fields;
  struct packet_ruleset_nation_sets *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_NATION_SETS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_nation_sets, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nsets";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nsets)) {
    RECEIVE_PACKET_FIELD_ERROR(nsets);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "names";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->nsets > MAX_NUM_NATION_SETS) {
      RECEIVE_PACKET_FIELD_ERROR(names, ": truncation array");
    }
    for (i = 0; i < real_packet->nsets; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->names[i], sizeof(real_packet->names[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(names);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_names";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->nsets > MAX_NUM_NATION_SETS) {
      RECEIVE_PACKET_FIELD_ERROR(rule_names, ": truncation array");
    }
    for (i = 0; i < real_packet->nsets; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->rule_names[i], sizeof(real_packet->rule_names[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(rule_names);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "descriptions";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->nsets > MAX_NUM_NATION_SETS) {
      RECEIVE_PACKET_FIELD_ERROR(descriptions, ": truncation array");
    }
    for (i = 0; i < real_packet->nsets; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->descriptions[i], sizeof(real_packet->descriptions[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(descriptions);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_nation_sets_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_nation_sets_100, cmp_packet_ruleset_nation_sets_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'nsets'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nsets";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nsets)) {
      RECEIVE_PACKET_FIELD_ERROR(nsets);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'names'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "names";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->nsets > MAX_NUM_NATION_SETS) {
        RECEIVE_PACKET_FIELD_ERROR(names, ": truncation array");
      }
      for (i = 0; i < real_packet->nsets; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->names[i], sizeof(real_packet->names[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(names);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_names'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_names";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->nsets > MAX_NUM_NATION_SETS) {
        RECEIVE_PACKET_FIELD_ERROR(rule_names, ": truncation array");
      }
      for (i = 0; i < real_packet->nsets; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->rule_names[i], sizeof(real_packet->rule_names[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(rule_names);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'descriptions'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "descriptions";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->nsets > MAX_NUM_NATION_SETS) {
        RECEIVE_PACKET_FIELD_ERROR(descriptions, ": truncation array");
      }
      for (i = 0; i < real_packet->nsets; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->descriptions[i], sizeof(real_packet->descriptions[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(descriptions);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_nation_sets_100(struct connection *pc, const struct packet_ruleset_nation_sets *packet)
{
  const struct packet_ruleset_nation_sets *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_nation_sets_100_fields fields;
  struct packet_ruleset_nation_sets *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_NATION_SETS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_NATION_SETS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_nation_sets_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_nation_sets_100, cmp_packet_ruleset_nation_sets_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->nsets != real_packet->nsets);
  if (differ) {
    BV_SET(fields, 0);
  }


    {
      differ = (old->nsets != real_packet->nsets);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->nsets; i++) {
          if (strcmp(old->names[i], real_packet->names[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 1);
  }


    {
      differ = (old->nsets != real_packet->nsets);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->nsets; i++) {
          if (strcmp(old->rule_names[i], real_packet->rule_names[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 2);
  }


    {
      differ = (old->nsets != real_packet->nsets);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->nsets; i++) {
          if (strcmp(old->descriptions[i], real_packet->descriptions[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'nsets' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nsets";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nsets);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'names' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nsets);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nsets; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_names' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nsets);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nsets; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->rule_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'descriptions' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "descriptions";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nsets);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nsets; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->descriptions[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nsets";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nsets);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nsets);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nsets; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nsets);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nsets; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->rule_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "descriptions";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nsets);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nsets; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->descriptions[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_NATION_SETS);
}

int send_packet_ruleset_nation_sets(struct connection *pc, const struct packet_ruleset_nation_sets *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_NATION_SETS].packet != NULL, -1,
                        "Handler for PACKET_RULESET_NATION_SETS not installed");
  return pc->phs.handlers->send[PACKET_RULESET_NATION_SETS].packet(pc, packet);
}

void lsend_packet_ruleset_nation_sets(struct conn_list *dest, const struct packet_ruleset_nation_sets *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_nation_sets(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_nation_groups_100 hash_const

#define cmp_packet_ruleset_nation_groups_100 cmp_const

BV_DEFINE(packet_ruleset_nation_groups_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_nation_groups *receive_packet_ruleset_nation_groups_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_nation_groups_100_fields fields;
  struct packet_ruleset_nation_groups *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_NATION_GROUPS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_nation_groups, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ngroups";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ngroups)) {
    RECEIVE_PACKET_FIELD_ERROR(ngroups);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "groups";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->ngroups > MAX_NUM_NATION_GROUPS) {
      RECEIVE_PACKET_FIELD_ERROR(groups, ": truncation array");
    }
    for (i = 0; i < real_packet->ngroups; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->groups[i], sizeof(real_packet->groups[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(groups);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hidden";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->ngroups > MAX_NUM_NATION_GROUPS) {
      RECEIVE_PACKET_FIELD_ERROR(hidden, ": truncation array");
    }
    for (i = 0; i < real_packet->ngroups; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(bool8, &din, &field_addr, &real_packet->hidden[i])) {
        RECEIVE_PACKET_FIELD_ERROR(hidden);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_nation_groups_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_nation_groups_100, cmp_packet_ruleset_nation_groups_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'ngroups'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ngroups";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ngroups)) {
      RECEIVE_PACKET_FIELD_ERROR(ngroups);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'groups'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "groups";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->ngroups > MAX_NUM_NATION_GROUPS) {
        RECEIVE_PACKET_FIELD_ERROR(groups, ": truncation array");
      }
      for (i = 0; i < real_packet->ngroups; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->groups[i], sizeof(real_packet->groups[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(groups);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'hidden'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hidden";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->ngroups > MAX_NUM_NATION_GROUPS) {
        RECEIVE_PACKET_FIELD_ERROR(hidden, ": truncation array");
      }
      for (i = 0; i < real_packet->ngroups; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(bool8, &din, &field_addr, &real_packet->hidden[i])) {
          RECEIVE_PACKET_FIELD_ERROR(hidden);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_nation_groups_100(struct connection *pc, const struct packet_ruleset_nation_groups *packet)
{
  const struct packet_ruleset_nation_groups *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_nation_groups_100_fields fields;
  struct packet_ruleset_nation_groups *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_NATION_GROUPS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_NATION_GROUPS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_nation_groups_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_nation_groups_100, cmp_packet_ruleset_nation_groups_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->ngroups != real_packet->ngroups);
  if (differ) {
    BV_SET(fields, 0);
  }


    {
      differ = (old->ngroups != real_packet->ngroups);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->ngroups; i++) {
          if (strcmp(old->groups[i], real_packet->groups[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 1);
  }


    {
      differ = (old->ngroups != real_packet->ngroups);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->ngroups; i++) {
          if (old->hidden[i] != real_packet->hidden[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'ngroups' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ngroups";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ngroups);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'groups' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "groups";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ngroups);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ngroups; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->groups[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'hidden' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hidden";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ngroups);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ngroups; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->hidden[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ngroups";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ngroups);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "groups";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ngroups);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ngroups; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->groups[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hidden";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ngroups);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ngroups; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->hidden[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_NATION_GROUPS);
}

int send_packet_ruleset_nation_groups(struct connection *pc, const struct packet_ruleset_nation_groups *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_NATION_GROUPS].packet != NULL, -1,
                        "Handler for PACKET_RULESET_NATION_GROUPS not installed");
  return pc->phs.handlers->send[PACKET_RULESET_NATION_GROUPS].packet(pc, packet);
}

void lsend_packet_ruleset_nation_groups(struct conn_list *dest, const struct packet_ruleset_nation_groups *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_nation_groups(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_ruleset_nation_100(const void *vkey)
{
  const struct packet_ruleset_nation *key = (const struct packet_ruleset_nation *) vkey;

  return key->id;
}

static bool cmp_packet_ruleset_nation_100(const void *vkey1, const void *vkey2)
{
  const struct packet_ruleset_nation *key1 = (const struct packet_ruleset_nation *) vkey1;
  const struct packet_ruleset_nation *key2 = (const struct packet_ruleset_nation *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_ruleset_nation_100_fields, 24);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_nation *receive_packet_ruleset_nation_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_nation_100_fields fields;
  struct packet_ruleset_nation *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_NATION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_nation, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "translation_domain";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->translation_domain, sizeof(real_packet->translation_domain))) {
    RECEIVE_PACKET_FIELD_ERROR(translation_domain);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "adjective";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->adjective, sizeof(real_packet->adjective))) {
    RECEIVE_PACKET_FIELD_ERROR(adjective);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "noun_plural";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->noun_plural, sizeof(real_packet->noun_plural))) {
    RECEIVE_PACKET_FIELD_ERROR(noun_plural);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_str);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "legend";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->legend, sizeof(real_packet->legend))) {
    RECEIVE_PACKET_FIELD_ERROR(legend);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
    RECEIVE_PACKET_FIELD_ERROR(style);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "leader_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->leader_count)) {
    RECEIVE_PACKET_FIELD_ERROR(leader_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "leader_name";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->leader_count > MAX_NUM_LEADERS) {
      RECEIVE_PACKET_FIELD_ERROR(leader_name, ": truncation array");
    }
    for (i = 0; i < real_packet->leader_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->leader_name[i], sizeof(real_packet->leader_name[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(leader_name);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "leader_is_male";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->leader_count > MAX_NUM_LEADERS) {
      RECEIVE_PACKET_FIELD_ERROR(leader_is_male, ": truncation array");
    }
    for (i = 0; i < real_packet->leader_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(bool8, &din, &field_addr, &real_packet->leader_is_male[i])) {
        RECEIVE_PACKET_FIELD_ERROR(leader_is_male);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_playable";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_playable)) {
    RECEIVE_PACKET_FIELD_ERROR(is_playable);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "barbarian_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(barbarian_type);
    }
    real_packet->barbarian_type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nsets";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nsets)) {
    RECEIVE_PACKET_FIELD_ERROR(nsets);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sets";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->nsets > MAX_NUM_NATION_SETS) {
      RECEIVE_PACKET_FIELD_ERROR(sets, ": truncation array");
    }
    for (i = 0; i < real_packet->nsets; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->sets[i])) {
        RECEIVE_PACKET_FIELD_ERROR(sets);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ngroups";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ngroups)) {
    RECEIVE_PACKET_FIELD_ERROR(ngroups);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "groups";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->ngroups > MAX_NUM_NATION_GROUPS) {
      RECEIVE_PACKET_FIELD_ERROR(groups, ": truncation array");
    }
    for (i = 0; i < real_packet->ngroups; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->groups[i])) {
        RECEIVE_PACKET_FIELD_ERROR(groups);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_government_id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(init_government_id);
    }
    real_packet->init_government_id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_techs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_techs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(init_techs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_techs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->init_techs_count > MAX_NUM_TECH_LIST) {
      RECEIVE_PACKET_FIELD_ERROR(init_techs, ": truncation array");
    }
    for (i = 0; i < real_packet->init_techs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_techs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(init_techs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_units_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_units_count)) {
    RECEIVE_PACKET_FIELD_ERROR(init_units_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_units";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->init_units_count > MAX_NUM_UNIT_LIST) {
      RECEIVE_PACKET_FIELD_ERROR(init_units, ": truncation array");
    }
    for (i = 0; i < real_packet->init_units_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      {
        int readin;
  
        if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
          RECEIVE_PACKET_FIELD_ERROR(init_units);
        }
        real_packet->init_units[i] = readin;
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_buildings_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_buildings_count)) {
    RECEIVE_PACKET_FIELD_ERROR(init_buildings_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_buildings";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->init_buildings_count > MAX_NUM_BUILDING_LIST) {
      RECEIVE_PACKET_FIELD_ERROR(init_buildings, ": truncation array");
    }
    for (i = 0; i < real_packet->init_buildings_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      {
        int readin;
  
        if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
          RECEIVE_PACKET_FIELD_ERROR(init_buildings);
        }
        real_packet->init_buildings[i] = readin;
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_nation_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_nation_100, cmp_packet_ruleset_nation_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    Nation_type_id id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'translation_domain'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "translation_domain";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->translation_domain, sizeof(real_packet->translation_domain))) {
      RECEIVE_PACKET_FIELD_ERROR(translation_domain);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'adjective'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "adjective";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->adjective, sizeof(real_packet->adjective))) {
      RECEIVE_PACKET_FIELD_ERROR(adjective);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'noun_plural'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "noun_plural";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->noun_plural, sizeof(real_packet->noun_plural))) {
      RECEIVE_PACKET_FIELD_ERROR(noun_plural);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'graphic_str'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_str";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_str);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'graphic_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'legend'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "legend";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->legend, sizeof(real_packet->legend))) {
      RECEIVE_PACKET_FIELD_ERROR(legend);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'style'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style)) {
      RECEIVE_PACKET_FIELD_ERROR(style);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'leader_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "leader_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->leader_count)) {
      RECEIVE_PACKET_FIELD_ERROR(leader_count);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'leader_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "leader_name";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->leader_count > MAX_NUM_LEADERS) {
        RECEIVE_PACKET_FIELD_ERROR(leader_name, ": truncation array");
      }
      for (i = 0; i < real_packet->leader_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->leader_name[i], sizeof(real_packet->leader_name[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(leader_name);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'leader_is_male'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "leader_is_male";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->leader_count > MAX_NUM_LEADERS) {
        RECEIVE_PACKET_FIELD_ERROR(leader_is_male, ": truncation array");
      }
      for (i = 0; i < real_packet->leader_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(bool8, &din, &field_addr, &real_packet->leader_is_male[i])) {
          RECEIVE_PACKET_FIELD_ERROR(leader_is_male);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  real_packet->is_playable = BV_ISSET(fields, 11);
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'barbarian_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "barbarian_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(barbarian_type);
      }
      real_packet->barbarian_type = readin;
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'nsets'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nsets";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->nsets)) {
      RECEIVE_PACKET_FIELD_ERROR(nsets);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'sets'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sets";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->nsets > MAX_NUM_NATION_SETS) {
        RECEIVE_PACKET_FIELD_ERROR(sets, ": truncation array");
      }
      for (i = 0; i < real_packet->nsets; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->sets[i])) {
          RECEIVE_PACKET_FIELD_ERROR(sets);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'ngroups'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ngroups";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ngroups)) {
      RECEIVE_PACKET_FIELD_ERROR(ngroups);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'groups'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "groups";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->ngroups > MAX_NUM_NATION_GROUPS) {
        RECEIVE_PACKET_FIELD_ERROR(groups, ": truncation array");
      }
      for (i = 0; i < real_packet->ngroups; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->groups[i])) {
          RECEIVE_PACKET_FIELD_ERROR(groups);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'init_government_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "init_government_id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(init_government_id);
      }
      real_packet->init_government_id = readin;
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'init_techs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "init_techs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_techs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(init_techs_count);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'init_techs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "init_techs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->init_techs_count > MAX_NUM_TECH_LIST) {
        RECEIVE_PACKET_FIELD_ERROR(init_techs, ": truncation array");
      }
      for (i = 0; i < real_packet->init_techs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_techs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(init_techs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'init_units_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "init_units_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_units_count)) {
      RECEIVE_PACKET_FIELD_ERROR(init_units_count);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'init_units'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "init_units";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->init_units_count > MAX_NUM_UNIT_LIST) {
        RECEIVE_PACKET_FIELD_ERROR(init_units, ": truncation array");
      }
      for (i = 0; i < real_packet->init_units_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        {
          int readin;
    
          if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
            RECEIVE_PACKET_FIELD_ERROR(init_units);
          }
          real_packet->init_units[i] = readin;
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'init_buildings_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "init_buildings_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->init_buildings_count)) {
      RECEIVE_PACKET_FIELD_ERROR(init_buildings_count);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'init_buildings'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "init_buildings";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->init_buildings_count > MAX_NUM_BUILDING_LIST) {
        RECEIVE_PACKET_FIELD_ERROR(init_buildings, ": truncation array");
      }
      for (i = 0; i < real_packet->init_buildings_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        {
          int readin;
    
          if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
            RECEIVE_PACKET_FIELD_ERROR(init_buildings);
          }
          real_packet->init_buildings[i] = readin;
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_nation_100(struct connection *pc, const struct packet_ruleset_nation *packet)
{
  const struct packet_ruleset_nation *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_nation_100_fields fields;
  struct packet_ruleset_nation *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_NATION;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_NATION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_nation_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_nation_100, cmp_packet_ruleset_nation_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->translation_domain, real_packet->translation_domain) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->adjective, real_packet->adjective) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->noun_plural, real_packet->noun_plural) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (strcmp(old->graphic_str, real_packet->graphic_str) != 0);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (strcmp(old->graphic_alt, real_packet->graphic_alt) != 0);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (strcmp(old->legend, real_packet->legend) != 0);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->style != real_packet->style);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->leader_count != real_packet->leader_count);
  if (differ) {
    BV_SET(fields, 8);
  }


    {
      differ = (old->leader_count != real_packet->leader_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->leader_count; i++) {
          if (strcmp(old->leader_name[i], real_packet->leader_name[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 9);
  }


    {
      differ = (old->leader_count != real_packet->leader_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->leader_count; i++) {
          if (old->leader_is_male[i] != real_packet->leader_is_male[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 10);
  }

  if (packet->is_playable) {
    BV_SET(fields, 11);
  }

  differ = (old->barbarian_type != real_packet->barbarian_type);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = (old->nsets != real_packet->nsets);
  if (differ) {
    BV_SET(fields, 13);
  }


    {
      differ = (old->nsets != real_packet->nsets);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->nsets; i++) {
          if (old->sets[i] != real_packet->sets[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 14);
  }

  differ = (old->ngroups != real_packet->ngroups);
  if (differ) {
    BV_SET(fields, 15);
  }


    {
      differ = (old->ngroups != real_packet->ngroups);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->ngroups; i++) {
          if (old->groups[i] != real_packet->groups[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 16);
  }

  differ = (old->init_government_id != real_packet->init_government_id);
  if (differ) {
    BV_SET(fields, 17);
  }

  differ = (old->init_techs_count != real_packet->init_techs_count);
  if (differ) {
    BV_SET(fields, 18);
  }


    {
      differ = (old->init_techs_count != real_packet->init_techs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->init_techs_count; i++) {
          if (old->init_techs[i] != real_packet->init_techs[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 19);
  }

  differ = (old->init_units_count != real_packet->init_units_count);
  if (differ) {
    BV_SET(fields, 20);
  }


    {
      differ = (old->init_units_count != real_packet->init_units_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->init_units_count; i++) {
          if (old->init_units[i] != real_packet->init_units[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 21);
  }

  differ = (old->init_buildings_count != real_packet->init_buildings_count);
  if (differ) {
    BV_SET(fields, 22);
  }


    {
      differ = (old->init_buildings_count != real_packet->init_buildings_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->init_buildings_count; i++) {
          if (old->init_buildings[i] != real_packet->init_buildings[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 23);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->id);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'translation_domain' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "translation_domain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->translation_domain);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'adjective' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "adjective";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->adjective);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'noun_plural' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "noun_plural";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->noun_plural);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'graphic_str' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'graphic_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'legend' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "legend";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->legend);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'style' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'leader_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "leader_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->leader_count);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'leader_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "leader_name";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->leader_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->leader_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->leader_name[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'leader_is_male' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "leader_is_male";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->leader_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->leader_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->leader_is_male[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  /* field 11 is folded into the header */
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'barbarian_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "barbarian_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->barbarian_type);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'nsets' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nsets";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nsets);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'sets' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sets";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nsets);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nsets; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->sets[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'ngroups' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ngroups";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ngroups);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'groups' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "groups";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ngroups);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ngroups; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->groups[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'init_government_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_government_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->init_government_id);
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'init_techs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_techs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->init_techs_count);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'init_techs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_techs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->init_techs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->init_techs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->init_techs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'init_units_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_units_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->init_units_count);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'init_units' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_units";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->init_units_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->init_units_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->init_units[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'init_buildings_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_buildings_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->init_buildings_count);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'init_buildings' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_buildings";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->init_buildings_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->init_buildings_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->init_buildings[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "translation_domain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->translation_domain);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "adjective";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->adjective);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "noun_plural";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->noun_plural);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "legend";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->legend);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "leader_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->leader_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "leader_name";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->leader_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->leader_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->leader_name[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "leader_is_male";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->leader_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->leader_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->leader_is_male[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_playable";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_playable);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "barbarian_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->barbarian_type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nsets";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->nsets);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sets";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->nsets);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->nsets; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->sets[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ngroups";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ngroups);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "groups";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ngroups);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ngroups; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->groups[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_government_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->init_government_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_techs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->init_techs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_techs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->init_techs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->init_techs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->init_techs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_units_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->init_units_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_units";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->init_units_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->init_units_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->init_units[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_buildings_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->init_buildings_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "init_buildings";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->init_buildings_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->init_buildings_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->init_buildings[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_NATION);
}

int send_packet_ruleset_nation(struct connection *pc, const struct packet_ruleset_nation *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_NATION].packet != NULL, -1,
                        "Handler for PACKET_RULESET_NATION not installed");
  return pc->phs.handlers->send[PACKET_RULESET_NATION].packet(pc, packet);
}

void lsend_packet_ruleset_nation(struct conn_list *dest, const struct packet_ruleset_nation *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_nation(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_nation_availability_100 hash_const

#define cmp_packet_nation_availability_100 cmp_const

BV_DEFINE(packet_nation_availability_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_nation_availability *receive_packet_nation_availability_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_nation_availability_100_fields fields;
  struct packet_nation_availability *old;
  struct genhash **hash = pc->phs.received + PACKET_NATION_AVAILABILITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_nation_availability, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ncount";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->ncount)) {
    RECEIVE_PACKET_FIELD_ERROR(ncount);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_pickable";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->ncount > MAX_NUM_NATIONS) {
      RECEIVE_PACKET_FIELD_ERROR(is_pickable, ": truncation array");
    }
    for (i = 0; i < real_packet->ncount; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_pickable[i])) {
        RECEIVE_PACKET_FIELD_ERROR(is_pickable);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationset_change";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->nationset_change)) {
    RECEIVE_PACKET_FIELD_ERROR(nationset_change);
  }

#endif
  log_packet_detailed("packet_nation_availability_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_nation_availability_100, cmp_packet_nation_availability_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'ncount'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ncount";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->ncount)) {
      RECEIVE_PACKET_FIELD_ERROR(ncount);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'is_pickable'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "is_pickable";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->ncount > MAX_NUM_NATIONS) {
        RECEIVE_PACKET_FIELD_ERROR(is_pickable, ": truncation array");
      }
      for (i = 0; i < real_packet->ncount; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_pickable[i])) {
          RECEIVE_PACKET_FIELD_ERROR(is_pickable);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  real_packet->nationset_change = BV_ISSET(fields, 2);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_nation_availability_100(struct connection *pc, const struct packet_nation_availability *packet)
{
  const struct packet_nation_availability *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_nation_availability_100_fields fields;
  struct packet_nation_availability *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_NATION_AVAILABILITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_NATION_AVAILABILITY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_nation_availability_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_nation_availability_100, cmp_packet_nation_availability_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->ncount != real_packet->ncount);
  if (differ) {
    BV_SET(fields, 0);
  }


    {
      differ = (old->ncount != real_packet->ncount);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->ncount; i++) {
          if (old->is_pickable[i] != real_packet->is_pickable[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 1);
  }

  if (packet->nationset_change) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'ncount' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ncount";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->ncount);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'is_pickable' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_pickable";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ncount);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ncount; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->is_pickable[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  /* field 2 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ncount";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->ncount);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_pickable";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ncount);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ncount; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->is_pickable[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nationset_change";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->nationset_change);

#endif
  SEND_PACKET_END(PACKET_NATION_AVAILABILITY);
}

int send_packet_nation_availability(struct connection *pc, const struct packet_nation_availability *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_NATION_AVAILABILITY].packet != NULL, -1,
                        "Handler for PACKET_NATION_AVAILABILITY not installed");
  return pc->phs.handlers->send[PACKET_NATION_AVAILABILITY].packet(pc, packet);
}

void lsend_packet_nation_availability(struct conn_list *dest, const struct packet_nation_availability *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_nation_availability(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_style_100 hash_const

#define cmp_packet_ruleset_style_100 cmp_const

BV_DEFINE(packet_ruleset_style_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_style *receive_packet_ruleset_style_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_style_100_fields fields;
  struct packet_ruleset_style *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_STYLE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_style, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }

#endif
  log_packet_detailed("packet_ruleset_style_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_style_100, cmp_packet_ruleset_style_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_style_100(struct connection *pc, const struct packet_ruleset_style *packet)
{
  const struct packet_ruleset_style *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_style_100_fields fields;
  struct packet_ruleset_style *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_STYLE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_STYLE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_style_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_style_100, cmp_packet_ruleset_style_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);

#endif
  SEND_PACKET_END(PACKET_RULESET_STYLE);
}

int send_packet_ruleset_style(struct connection *pc, const struct packet_ruleset_style *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_STYLE].packet != NULL, -1,
                        "Handler for PACKET_RULESET_STYLE not installed");
  return pc->phs.handlers->send[PACKET_RULESET_STYLE].packet(pc, packet);
}

void lsend_packet_ruleset_style(struct conn_list *dest, const struct packet_ruleset_style *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_style(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_city_100 hash_const

#define cmp_packet_ruleset_city_100 cmp_const

BV_DEFINE(packet_ruleset_city_100_fields, 8);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_city *receive_packet_ruleset_city_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_city_100_fields fields;
  struct packet_ruleset_city *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_CITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_city, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style_id)) {
    RECEIVE_PACKET_FIELD_ERROR(style_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizens_graphic";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->citizens_graphic, sizeof(real_packet->citizens_graphic))) {
    RECEIVE_PACKET_FIELD_ERROR(citizens_graphic);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic, sizeof(real_packet->graphic))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
  }

#endif
  log_packet_detailed("packet_ruleset_city_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_city_100, cmp_packet_ruleset_city_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'style_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "style_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->style_id)) {
      RECEIVE_PACKET_FIELD_ERROR(style_id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'citizens_graphic'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "citizens_graphic";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->citizens_graphic, sizeof(real_packet->citizens_graphic))) {
      RECEIVE_PACKET_FIELD_ERROR(citizens_graphic);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'graphic'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic, sizeof(real_packet->graphic))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'graphic_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_city_100(struct connection *pc, const struct packet_ruleset_city *packet)
{
  const struct packet_ruleset_city *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_city_100_fields fields;
  struct packet_ruleset_city *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_CITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_CITY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_city_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_city_100, cmp_packet_ruleset_city_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->style_id != real_packet->style_id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->citizens_graphic, real_packet->citizens_graphic) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 4);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (strcmp(old->graphic, real_packet->graphic) != 0);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (strcmp(old->graphic_alt, real_packet->graphic_alt) != 0);
  if (differ) {
    BV_SET(fields, 7);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'style_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style_id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'citizens_graphic' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizens_graphic";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->citizens_graphic);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'graphic' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'graphic_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "style_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->style_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "citizens_graphic";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->citizens_graphic);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);

#endif
  SEND_PACKET_END(PACKET_RULESET_CITY);
}

int send_packet_ruleset_city(struct connection *pc, const struct packet_ruleset_city *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_CITY].packet != NULL, -1,
                        "Handler for PACKET_RULESET_CITY not installed");
  return pc->phs.handlers->send[PACKET_RULESET_CITY].packet(pc, packet);
}

void lsend_packet_ruleset_city(struct conn_list *dest, const struct packet_ruleset_city *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_city(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_building_100 hash_const

#define cmp_packet_ruleset_building_100 cmp_const

BV_DEFINE(packet_ruleset_building_100_fields, 17);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_building *receive_packet_ruleset_building_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_building_100_fields fields;
  struct packet_ruleset_building *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_BUILDING;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_building, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "genus";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(genus);
    }
    real_packet->genus = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_str);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "obs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->obs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(obs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "obs_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->obs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(obs_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->obs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->obs_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(obs_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->build_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(build_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->upkeep)) {
    RECEIVE_PACKET_FIELD_ERROR(upkeep);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sabotage";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->sabotage)) {
    RECEIVE_PACKET_FIELD_ERROR(sabotage);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "soundtag";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->soundtag, sizeof(real_packet->soundtag))) {
    RECEIVE_PACKET_FIELD_ERROR(soundtag);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "soundtag_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->soundtag_alt, sizeof(real_packet->soundtag_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(soundtag_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }

#endif
  log_packet_detailed("packet_ruleset_building_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_building_100, cmp_packet_ruleset_building_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(id);
      }
      real_packet->id = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'genus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "genus";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(genus);
      }
      real_packet->genus = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'graphic_str'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_str";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_str);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'graphic_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'obs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "obs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->obs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(obs_count);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'obs_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "obs_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->obs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(obs_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->obs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->obs_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(obs_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'build_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "build_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->build_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(build_cost);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'upkeep'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "upkeep";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->upkeep)) {
      RECEIVE_PACKET_FIELD_ERROR(upkeep);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'sabotage'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sabotage";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->sabotage)) {
      RECEIVE_PACKET_FIELD_ERROR(sabotage);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'soundtag'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "soundtag";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->soundtag, sizeof(real_packet->soundtag))) {
      RECEIVE_PACKET_FIELD_ERROR(soundtag);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'soundtag_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "soundtag_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->soundtag_alt, sizeof(real_packet->soundtag_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(soundtag_alt);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_building_100(struct connection *pc, const struct packet_ruleset_building *packet)
{
  const struct packet_ruleset_building *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_building_100_fields fields;
  struct packet_ruleset_building *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_BUILDING;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_BUILDING);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_building_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_building_100, cmp_packet_ruleset_building_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->genus != real_packet->genus);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (strcmp(old->graphic_str, real_packet->graphic_str) != 0);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (strcmp(old->graphic_alt, real_packet->graphic_alt) != 0);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 6);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->obs_count != real_packet->obs_count);
  if (differ) {
    BV_SET(fields, 8);
  }


    {
      differ = (old->obs_count != real_packet->obs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->obs_count; i++) {
          if (!are_requirements_equal(&old->obs_reqs[i], &real_packet->obs_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (old->build_cost != real_packet->build_cost);
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (old->upkeep != real_packet->upkeep);
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (old->sabotage != real_packet->sabotage);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = !BV_ARE_EQUAL(old->flags, real_packet->flags);
  if (differ) {
    BV_SET(fields, 13);
  }

  differ = (strcmp(old->soundtag, real_packet->soundtag) != 0);
  if (differ) {
    BV_SET(fields, 14);
  }

  differ = (strcmp(old->soundtag_alt, real_packet->soundtag_alt) != 0);
  if (differ) {
    BV_SET(fields, 15);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 16);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'genus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "genus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->genus);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'graphic_str' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'graphic_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'obs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "obs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->obs_count);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'obs_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "obs_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->obs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->obs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->obs_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'build_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->build_cost);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'upkeep' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->upkeep);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'sabotage' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sabotage";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->sabotage);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'soundtag' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "soundtag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->soundtag);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'soundtag_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "soundtag_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->soundtag_alt);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "genus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->genus);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "obs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->obs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "obs_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->obs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->obs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->obs_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->build_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "upkeep";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->upkeep);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sabotage";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->sabotage);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "soundtag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->soundtag);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "soundtag_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->soundtag_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);

#endif
  SEND_PACKET_END(PACKET_RULESET_BUILDING);
}

int send_packet_ruleset_building(struct connection *pc, const struct packet_ruleset_building *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_BUILDING].packet != NULL, -1,
                        "Handler for PACKET_RULESET_BUILDING not installed");
  return pc->phs.handlers->send[PACKET_RULESET_BUILDING].packet(pc, packet);
}

void lsend_packet_ruleset_building(struct conn_list *dest, const struct packet_ruleset_building *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_building(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_terrain_100 hash_const

#define cmp_packet_ruleset_terrain_100 cmp_const

BV_DEFINE(packet_ruleset_terrain_100_fields, 35);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_terrain *receive_packet_ruleset_terrain_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_terrain_100_fields fields;
  struct packet_ruleset_terrain *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_TERRAIN;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_terrain, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tclass";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tclass)) {
    RECEIVE_PACKET_FIELD_ERROR(tclass);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "native_to";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->native_to)) {
    RECEIVE_PACKET_FIELD_ERROR(native_to);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_str);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "movement_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->movement_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(movement_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defense_bonus";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->defense_bonus)) {
    RECEIVE_PACKET_FIELD_ERROR(defense_bonus);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "output";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->output[i])) {
        RECEIVE_PACKET_FIELD_ERROR(output);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_resources";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->num_resources)) {
    RECEIVE_PACKET_FIELD_ERROR(num_resources);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resources";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->num_resources > MAX_RESOURCE_TYPES) {
      RECEIVE_PACKET_FIELD_ERROR(resources, ": truncation array");
    }
    for (i = 0; i < real_packet->num_resources; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      {
        int readin;
  
        if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
          RECEIVE_PACKET_FIELD_ERROR(resources);
        }
        real_packet->resources[i] = readin;
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "road_output_incr_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->road_output_incr_pct[i])) {
        RECEIVE_PACKET_FIELD_ERROR(road_output_incr_pct);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->base_time)) {
    RECEIVE_PACKET_FIELD_ERROR(base_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "road_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->road_time)) {
    RECEIVE_PACKET_FIELD_ERROR(road_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cultivate_result";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(cultivate_result);
    }
    real_packet->cultivate_result = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cultivate_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->cultivate_time)) {
    RECEIVE_PACKET_FIELD_ERROR(cultivate_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plant_result";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(plant_result);
    }
    real_packet->plant_result = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plant_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->plant_time)) {
    RECEIVE_PACKET_FIELD_ERROR(plant_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "irrigation_food_incr";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->irrigation_food_incr)) {
    RECEIVE_PACKET_FIELD_ERROR(irrigation_food_incr);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "irrigation_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->irrigation_time)) {
    RECEIVE_PACKET_FIELD_ERROR(irrigation_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mining_shield_incr";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->mining_shield_incr)) {
    RECEIVE_PACKET_FIELD_ERROR(mining_shield_incr);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mining_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->mining_time)) {
    RECEIVE_PACKET_FIELD_ERROR(mining_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "animal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->animal)) {
    RECEIVE_PACKET_FIELD_ERROR(animal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transform_result";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(transform_result);
    }
    real_packet->transform_result = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transform_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->transform_time)) {
    RECEIVE_PACKET_FIELD_ERROR(transform_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "placing_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->placing_time)) {
    RECEIVE_PACKET_FIELD_ERROR(placing_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "clean_pollution_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->clean_pollution_time)) {
    RECEIVE_PACKET_FIELD_ERROR(clean_pollution_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "clean_fallout_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->clean_fallout_time)) {
    RECEIVE_PACKET_FIELD_ERROR(clean_fallout_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pillage_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->pillage_time)) {
    RECEIVE_PACKET_FIELD_ERROR(pillage_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_red";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_red)) {
    RECEIVE_PACKET_FIELD_ERROR(color_red);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_green";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_green)) {
    RECEIVE_PACKET_FIELD_ERROR(color_green);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_blue";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_blue)) {
    RECEIVE_PACKET_FIELD_ERROR(color_blue);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }

#endif
  log_packet_detailed("packet_ruleset_terrain_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_terrain_100, cmp_packet_ruleset_terrain_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(id);
      }
      real_packet->id = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tclass'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tclass";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tclass)) {
      RECEIVE_PACKET_FIELD_ERROR(tclass);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'native_to'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "native_to";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->native_to)) {
      RECEIVE_PACKET_FIELD_ERROR(native_to);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'graphic_str'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_str";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_str);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'graphic_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'movement_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "movement_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->movement_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(movement_cost);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'defense_bonus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "defense_bonus";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->defense_bonus)) {
      RECEIVE_PACKET_FIELD_ERROR(defense_bonus);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'output'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "output";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->output[i])) {
          RECEIVE_PACKET_FIELD_ERROR(output);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'num_resources'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_resources";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->num_resources)) {
      RECEIVE_PACKET_FIELD_ERROR(num_resources);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'resources'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "resources";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->num_resources > MAX_RESOURCE_TYPES) {
        RECEIVE_PACKET_FIELD_ERROR(resources, ": truncation array");
      }
      for (i = 0; i < real_packet->num_resources; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        {
          int readin;
    
          if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
            RECEIVE_PACKET_FIELD_ERROR(resources);
          }
          real_packet->resources[i] = readin;
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'road_output_incr_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "road_output_incr_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->road_output_incr_pct[i])) {
          RECEIVE_PACKET_FIELD_ERROR(road_output_incr_pct);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'base_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "base_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->base_time)) {
      RECEIVE_PACKET_FIELD_ERROR(base_time);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'road_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "road_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->road_time)) {
      RECEIVE_PACKET_FIELD_ERROR(road_time);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'cultivate_result'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cultivate_result";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(cultivate_result);
      }
      real_packet->cultivate_result = readin;
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'cultivate_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cultivate_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->cultivate_time)) {
      RECEIVE_PACKET_FIELD_ERROR(cultivate_time);
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'plant_result'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "plant_result";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(plant_result);
      }
      real_packet->plant_result = readin;
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'plant_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "plant_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->plant_time)) {
      RECEIVE_PACKET_FIELD_ERROR(plant_time);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'irrigation_food_incr'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "irrigation_food_incr";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->irrigation_food_incr)) {
      RECEIVE_PACKET_FIELD_ERROR(irrigation_food_incr);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'irrigation_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "irrigation_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->irrigation_time)) {
      RECEIVE_PACKET_FIELD_ERROR(irrigation_time);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'mining_shield_incr'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "mining_shield_incr";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->mining_shield_incr)) {
      RECEIVE_PACKET_FIELD_ERROR(mining_shield_incr);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'mining_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "mining_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->mining_time)) {
      RECEIVE_PACKET_FIELD_ERROR(mining_time);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'animal'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "animal";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->animal)) {
      RECEIVE_PACKET_FIELD_ERROR(animal);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'transform_result'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "transform_result";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(transform_result);
      }
      real_packet->transform_result = readin;
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'transform_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "transform_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->transform_time)) {
      RECEIVE_PACKET_FIELD_ERROR(transform_time);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'placing_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "placing_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->placing_time)) {
      RECEIVE_PACKET_FIELD_ERROR(placing_time);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'clean_pollution_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "clean_pollution_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->clean_pollution_time)) {
      RECEIVE_PACKET_FIELD_ERROR(clean_pollution_time);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'clean_fallout_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "clean_fallout_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->clean_fallout_time)) {
      RECEIVE_PACKET_FIELD_ERROR(clean_fallout_time);
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'pillage_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "pillage_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->pillage_time)) {
      RECEIVE_PACKET_FIELD_ERROR(pillage_time);
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  got field 'color_red'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "color_red";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_red)) {
      RECEIVE_PACKET_FIELD_ERROR(color_red);
    }
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  got field 'color_green'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "color_green";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_green)) {
      RECEIVE_PACKET_FIELD_ERROR(color_green);
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'color_blue'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "color_blue";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->color_blue)) {
      RECEIVE_PACKET_FIELD_ERROR(color_blue);
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_terrain_100(struct connection *pc, const struct packet_ruleset_terrain *packet)
{
  const struct packet_ruleset_terrain *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_terrain_100_fields fields;
  struct packet_ruleset_terrain *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_TERRAIN;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_TERRAIN);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_terrain_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_terrain_100, cmp_packet_ruleset_terrain_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tclass != real_packet->tclass);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = !BV_ARE_EQUAL(old->flags, real_packet->flags);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = !BV_ARE_EQUAL(old->native_to, real_packet->native_to);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (strcmp(old->graphic_str, real_packet->graphic_str) != 0);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (strcmp(old->graphic_alt, real_packet->graphic_alt) != 0);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->movement_cost != real_packet->movement_cost);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (old->defense_bonus != real_packet->defense_bonus);
  if (differ) {
    BV_SET(fields, 9);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->output[i] != real_packet->output[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (old->num_resources != real_packet->num_resources);
  if (differ) {
    BV_SET(fields, 11);
  }


    {
      differ = (old->num_resources != real_packet->num_resources);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->num_resources; i++) {
          if (old->resources[i] != real_packet->resources[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 12);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->road_output_incr_pct[i] != real_packet->road_output_incr_pct[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 13);
  }

  differ = (old->base_time != real_packet->base_time);
  if (differ) {
    BV_SET(fields, 14);
  }

  differ = (old->road_time != real_packet->road_time);
  if (differ) {
    BV_SET(fields, 15);
  }

  differ = (old->cultivate_result != real_packet->cultivate_result);
  if (differ) {
    BV_SET(fields, 16);
  }

  differ = (old->cultivate_time != real_packet->cultivate_time);
  if (differ) {
    BV_SET(fields, 17);
  }

  differ = (old->plant_result != real_packet->plant_result);
  if (differ) {
    BV_SET(fields, 18);
  }

  differ = (old->plant_time != real_packet->plant_time);
  if (differ) {
    BV_SET(fields, 19);
  }

  differ = (old->irrigation_food_incr != real_packet->irrigation_food_incr);
  if (differ) {
    BV_SET(fields, 20);
  }

  differ = (old->irrigation_time != real_packet->irrigation_time);
  if (differ) {
    BV_SET(fields, 21);
  }

  differ = (old->mining_shield_incr != real_packet->mining_shield_incr);
  if (differ) {
    BV_SET(fields, 22);
  }

  differ = (old->mining_time != real_packet->mining_time);
  if (differ) {
    BV_SET(fields, 23);
  }

  differ = (old->animal != real_packet->animal);
  if (differ) {
    BV_SET(fields, 24);
  }

  differ = (old->transform_result != real_packet->transform_result);
  if (differ) {
    BV_SET(fields, 25);
  }

  differ = (old->transform_time != real_packet->transform_time);
  if (differ) {
    BV_SET(fields, 26);
  }

  differ = (old->placing_time != real_packet->placing_time);
  if (differ) {
    BV_SET(fields, 27);
  }

  differ = (old->clean_pollution_time != real_packet->clean_pollution_time);
  if (differ) {
    BV_SET(fields, 28);
  }

  differ = (old->clean_fallout_time != real_packet->clean_fallout_time);
  if (differ) {
    BV_SET(fields, 29);
  }

  differ = (old->pillage_time != real_packet->pillage_time);
  if (differ) {
    BV_SET(fields, 30);
  }

  differ = (old->color_red != real_packet->color_red);
  if (differ) {
    BV_SET(fields, 31);
  }

  differ = (old->color_green != real_packet->color_green);
  if (differ) {
    BV_SET(fields, 32);
  }

  differ = (old->color_blue != real_packet->color_blue);
  if (differ) {
    BV_SET(fields, 33);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 34);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tclass' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tclass";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tclass);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'native_to' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "native_to";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->native_to);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'graphic_str' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'graphic_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'movement_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "movement_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->movement_cost);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'defense_bonus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defense_bonus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->defense_bonus);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'output' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "output";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->output[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'num_resources' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_resources";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->num_resources);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'resources' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resources";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->num_resources);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->num_resources; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->resources[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'road_output_incr_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "road_output_incr_pct";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->road_output_incr_pct[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'base_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->base_time);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'road_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "road_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->road_time);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'cultivate_result' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cultivate_result";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->cultivate_result);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'cultivate_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cultivate_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->cultivate_time);
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'plant_result' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plant_result";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->plant_result);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'plant_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plant_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->plant_time);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'irrigation_food_incr' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "irrigation_food_incr";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->irrigation_food_incr);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'irrigation_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "irrigation_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->irrigation_time);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'mining_shield_incr' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mining_shield_incr";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->mining_shield_incr);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'mining_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mining_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->mining_time);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'animal' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "animal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->animal);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'transform_result' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transform_result";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->transform_result);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'transform_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transform_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->transform_time);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'placing_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "placing_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->placing_time);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'clean_pollution_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "clean_pollution_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->clean_pollution_time);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'clean_fallout_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "clean_fallout_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->clean_fallout_time);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'pillage_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pillage_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->pillage_time);
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  field 'color_red' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_red";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_red);
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  field 'color_green' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_green";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_green);
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'color_blue' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_blue";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_blue);
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tclass";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tclass);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "native_to";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->native_to);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "movement_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->movement_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defense_bonus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->defense_bonus);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "output";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->output[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_resources";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->num_resources);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resources";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->num_resources);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->num_resources; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->resources[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "road_output_incr_pct";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->road_output_incr_pct[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "base_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->base_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "road_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->road_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cultivate_result";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->cultivate_result);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cultivate_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->cultivate_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plant_result";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->plant_result);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "plant_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->plant_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "irrigation_food_incr";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->irrigation_food_incr);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "irrigation_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->irrigation_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mining_shield_incr";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->mining_shield_incr);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "mining_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->mining_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "animal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->animal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transform_result";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->transform_result);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transform_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->transform_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "placing_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->placing_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "clean_pollution_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->clean_pollution_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "clean_fallout_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->clean_fallout_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pillage_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->pillage_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_red";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_red);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_green";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_green);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "color_blue";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->color_blue);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);

#endif
  SEND_PACKET_END(PACKET_RULESET_TERRAIN);
}

int send_packet_ruleset_terrain(struct connection *pc, const struct packet_ruleset_terrain *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_TERRAIN].packet != NULL, -1,
                        "Handler for PACKET_RULESET_TERRAIN not installed");
  return pc->phs.handlers->send[PACKET_RULESET_TERRAIN].packet(pc, packet);
}

void lsend_packet_ruleset_terrain(struct conn_list *dest, const struct packet_ruleset_terrain *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_terrain(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_terrain_flag_100 hash_const

#define cmp_packet_ruleset_terrain_flag_100 cmp_const

BV_DEFINE(packet_ruleset_terrain_flag_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_terrain_flag *receive_packet_ruleset_terrain_flag_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_terrain_flag_100_fields fields;
  struct packet_ruleset_terrain_flag *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_TERRAIN_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_terrain_flag, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
    RECEIVE_PACKET_FIELD_ERROR(helptxt);
  }

#endif
  log_packet_detailed("packet_ruleset_terrain_flag_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_terrain_flag_100, cmp_packet_ruleset_terrain_flag_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'helptxt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptxt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
      RECEIVE_PACKET_FIELD_ERROR(helptxt);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_terrain_flag_100(struct connection *pc, const struct packet_ruleset_terrain_flag *packet)
{
  const struct packet_ruleset_terrain_flag *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_terrain_flag_100_fields fields;
  struct packet_ruleset_terrain_flag *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_TERRAIN_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_TERRAIN_FLAG);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_terrain_flag_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_terrain_flag_100, cmp_packet_ruleset_terrain_flag_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->helptxt, real_packet->helptxt) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'helptxt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);

#endif
  SEND_PACKET_END(PACKET_RULESET_TERRAIN_FLAG);
}

int send_packet_ruleset_terrain_flag(struct connection *pc, const struct packet_ruleset_terrain_flag *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_TERRAIN_FLAG].packet != NULL, -1,
                        "Handler for PACKET_RULESET_TERRAIN_FLAG not installed");
  return pc->phs.handlers->send[PACKET_RULESET_TERRAIN_FLAG].packet(pc, packet);
}

void lsend_packet_ruleset_terrain_flag(struct conn_list *dest, const struct packet_ruleset_terrain_flag *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_terrain_flag(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_unit_class_100 hash_const

#define cmp_packet_ruleset_unit_class_100 cmp_const

BV_DEFINE(packet_ruleset_unit_class_100_fields, 8);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_unit_class *receive_packet_ruleset_unit_class_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_class_100_fields fields;
  struct packet_ruleset_unit_class *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_UNIT_CLASS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_unit_class, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_speed";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->min_speed)) {
    RECEIVE_PACKET_FIELD_ERROR(min_speed);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp_loss_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp_loss_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(hp_loss_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "non_native_def_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->non_native_def_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(non_native_def_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }

#endif
  log_packet_detailed("packet_ruleset_unit_class_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_class_100, cmp_packet_ruleset_unit_class_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'min_speed'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "min_speed";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->min_speed)) {
      RECEIVE_PACKET_FIELD_ERROR(min_speed);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'hp_loss_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hp_loss_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp_loss_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(hp_loss_pct);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'non_native_def_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "non_native_def_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->non_native_def_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(non_native_def_pct);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_unit_class_100(struct connection *pc, const struct packet_ruleset_unit_class *packet)
{
  const struct packet_ruleset_unit_class *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_unit_class_100_fields fields;
  struct packet_ruleset_unit_class *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_UNIT_CLASS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_UNIT_CLASS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_unit_class_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_unit_class_100, cmp_packet_ruleset_unit_class_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->min_speed != real_packet->min_speed);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->hp_loss_pct != real_packet->hp_loss_pct);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->non_native_def_pct != real_packet->non_native_def_pct);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = !BV_ARE_EQUAL(old->flags, real_packet->flags);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 7);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'min_speed' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_speed";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->min_speed);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'hp_loss_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp_loss_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp_loss_pct);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'non_native_def_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "non_native_def_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->non_native_def_pct);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_speed";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->min_speed);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp_loss_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp_loss_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "non_native_def_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->non_native_def_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);

#endif
  SEND_PACKET_END(PACKET_RULESET_UNIT_CLASS);
}

int send_packet_ruleset_unit_class(struct connection *pc, const struct packet_ruleset_unit_class *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_UNIT_CLASS].packet != NULL, -1,
                        "Handler for PACKET_RULESET_UNIT_CLASS not installed");
  return pc->phs.handlers->send[PACKET_RULESET_UNIT_CLASS].packet(pc, packet);
}

void lsend_packet_ruleset_unit_class(struct conn_list *dest, const struct packet_ruleset_unit_class *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_unit_class(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_extra_100 hash_const

#define cmp_packet_ruleset_extra_100 cmp_const

BV_DEFINE(packet_ruleset_extra_100_fields, 39);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_extra *receive_packet_ruleset_extra_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_extra_100_fields fields;
  struct packet_ruleset_extra *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_EXTRA;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_extra, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->category)) {
    RECEIVE_PACKET_FIELD_ERROR(category);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "causes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->causes)) {
    RECEIVE_PACKET_FIELD_ERROR(causes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmcauses";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->rmcauses)) {
    RECEIVE_PACKET_FIELD_ERROR(rmcauses);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_gfx";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->activity_gfx, sizeof(real_packet->activity_gfx))) {
    RECEIVE_PACKET_FIELD_ERROR(activity_gfx);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_gfx_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->act_gfx_alt, sizeof(real_packet->act_gfx_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(act_gfx_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_gfx_alt2";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->act_gfx_alt2, sizeof(real_packet->act_gfx_alt2))) {
    RECEIVE_PACKET_FIELD_ERROR(act_gfx_alt2);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmact_gfx";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rmact_gfx, sizeof(real_packet->rmact_gfx))) {
    RECEIVE_PACKET_FIELD_ERROR(rmact_gfx);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmact_gfx_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rmact_gfx_alt, sizeof(real_packet->rmact_gfx_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(rmact_gfx_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_str);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
    RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmreqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->rmreqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(rmreqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmreqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->rmreqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(rmreqs, ": truncation array");
    }
    for (i = 0; i < real_packet->rmreqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->rmreqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(rmreqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "appearance_chance";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->appearance_chance)) {
    RECEIVE_PACKET_FIELD_ERROR(appearance_chance);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "appearance_reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->appearance_reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(appearance_reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "appearance_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->appearance_reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(appearance_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->appearance_reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->appearance_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(appearance_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disappearance_chance";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disappearance_chance)) {
    RECEIVE_PACKET_FIELD_ERROR(disappearance_chance);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disappearance_reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->disappearance_reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(disappearance_reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disappearance_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->disappearance_reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(disappearance_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->disappearance_reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->disappearance_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(disappearance_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "visibility_req";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->visibility_req)) {
    RECEIVE_PACKET_FIELD_ERROR(visibility_req);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buildable";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->buildable)) {
    RECEIVE_PACKET_FIELD_ERROR(buildable);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "generated";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->generated)) {
    RECEIVE_PACKET_FIELD_ERROR(generated);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_time)) {
    RECEIVE_PACKET_FIELD_ERROR(build_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_time_factor";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_time_factor)) {
    RECEIVE_PACKET_FIELD_ERROR(build_time_factor);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal_time";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->removal_time)) {
    RECEIVE_PACKET_FIELD_ERROR(removal_time);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal_time_factor";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->removal_time_factor)) {
    RECEIVE_PACKET_FIELD_ERROR(removal_time_factor);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infracost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->infracost)) {
    RECEIVE_PACKET_FIELD_ERROR(infracost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defense_bonus";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->defense_bonus)) {
    RECEIVE_PACKET_FIELD_ERROR(defense_bonus);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "eus";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(eus);
    }
    real_packet->eus = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "native_to";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->native_to)) {
    RECEIVE_PACKET_FIELD_ERROR(native_to);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hidden_by";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->hidden_by)) {
    RECEIVE_PACKET_FIELD_ERROR(hidden_by);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bridged_over";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->bridged_over)) {
    RECEIVE_PACKET_FIELD_ERROR(bridged_over);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conflicts";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->conflicts)) {
    RECEIVE_PACKET_FIELD_ERROR(conflicts);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }

#endif
  log_packet_detailed("packet_ruleset_extra_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_extra_100, cmp_packet_ruleset_extra_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'category'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "category";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->category)) {
      RECEIVE_PACKET_FIELD_ERROR(category);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'causes'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "causes";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->causes)) {
      RECEIVE_PACKET_FIELD_ERROR(causes);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'rmcauses'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rmcauses";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->rmcauses)) {
      RECEIVE_PACKET_FIELD_ERROR(rmcauses);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'activity_gfx'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_gfx";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->activity_gfx, sizeof(real_packet->activity_gfx))) {
      RECEIVE_PACKET_FIELD_ERROR(activity_gfx);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'act_gfx_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "act_gfx_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->act_gfx_alt, sizeof(real_packet->act_gfx_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(act_gfx_alt);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'act_gfx_alt2'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "act_gfx_alt2";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->act_gfx_alt2, sizeof(real_packet->act_gfx_alt2))) {
      RECEIVE_PACKET_FIELD_ERROR(act_gfx_alt2);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'rmact_gfx'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rmact_gfx";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rmact_gfx, sizeof(real_packet->rmact_gfx))) {
      RECEIVE_PACKET_FIELD_ERROR(rmact_gfx);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'rmact_gfx_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rmact_gfx_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rmact_gfx_alt, sizeof(real_packet->rmact_gfx_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(rmact_gfx_alt);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'graphic_str'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_str";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_str, sizeof(real_packet->graphic_str))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_str);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'graphic_alt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "graphic_alt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->graphic_alt, sizeof(real_packet->graphic_alt))) {
      RECEIVE_PACKET_FIELD_ERROR(graphic_alt);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'rmreqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rmreqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->rmreqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(rmreqs_count);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'rmreqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rmreqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->rmreqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(rmreqs, ": truncation array");
      }
      for (i = 0; i < real_packet->rmreqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->rmreqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(rmreqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'appearance_chance'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "appearance_chance";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->appearance_chance)) {
      RECEIVE_PACKET_FIELD_ERROR(appearance_chance);
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'appearance_reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "appearance_reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->appearance_reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(appearance_reqs_count);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'appearance_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "appearance_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->appearance_reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(appearance_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->appearance_reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->appearance_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(appearance_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'disappearance_chance'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "disappearance_chance";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->disappearance_chance)) {
      RECEIVE_PACKET_FIELD_ERROR(disappearance_chance);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'disappearance_reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "disappearance_reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->disappearance_reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(disappearance_reqs_count);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'disappearance_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "disappearance_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->disappearance_reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(disappearance_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->disappearance_reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->disappearance_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(disappearance_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'visibility_req'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "visibility_req";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->visibility_req)) {
      RECEIVE_PACKET_FIELD_ERROR(visibility_req);
    }
  }
  real_packet->buildable = BV_ISSET(fields, 24);
  real_packet->generated = BV_ISSET(fields, 25);
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'build_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "build_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_time)) {
      RECEIVE_PACKET_FIELD_ERROR(build_time);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'build_time_factor'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "build_time_factor";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->build_time_factor)) {
      RECEIVE_PACKET_FIELD_ERROR(build_time_factor);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'removal_time'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "removal_time";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->removal_time)) {
      RECEIVE_PACKET_FIELD_ERROR(removal_time);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'removal_time_factor'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "removal_time_factor";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->removal_time_factor)) {
      RECEIVE_PACKET_FIELD_ERROR(removal_time_factor);
    }
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  got field 'infracost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "infracost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->infracost)) {
      RECEIVE_PACKET_FIELD_ERROR(infracost);
    }
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  got field 'defense_bonus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "defense_bonus";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->defense_bonus)) {
      RECEIVE_PACKET_FIELD_ERROR(defense_bonus);
    }
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  got field 'eus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "eus";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(eus);
      }
      real_packet->eus = readin;
    }
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  got field 'native_to'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "native_to";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->native_to)) {
      RECEIVE_PACKET_FIELD_ERROR(native_to);
    }
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  got field 'hidden_by'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hidden_by";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->hidden_by)) {
      RECEIVE_PACKET_FIELD_ERROR(hidden_by);
    }
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  got field 'bridged_over'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "bridged_over";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->bridged_over)) {
      RECEIVE_PACKET_FIELD_ERROR(bridged_over);
    }
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  got field 'conflicts'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "conflicts";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->conflicts)) {
      RECEIVE_PACKET_FIELD_ERROR(conflicts);
    }
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_extra_100(struct connection *pc, const struct packet_ruleset_extra *packet)
{
  const struct packet_ruleset_extra *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_extra_100_fields fields;
  struct packet_ruleset_extra *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_EXTRA;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_EXTRA);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_extra_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_extra_100, cmp_packet_ruleset_extra_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->category != real_packet->category);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = !BV_ARE_EQUAL(old->causes, real_packet->causes);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = !BV_ARE_EQUAL(old->rmcauses, real_packet->rmcauses);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (strcmp(old->activity_gfx, real_packet->activity_gfx) != 0);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (strcmp(old->act_gfx_alt, real_packet->act_gfx_alt) != 0);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (strcmp(old->act_gfx_alt2, real_packet->act_gfx_alt2) != 0);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (strcmp(old->rmact_gfx, real_packet->rmact_gfx) != 0);
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (strcmp(old->rmact_gfx_alt, real_packet->rmact_gfx_alt) != 0);
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (strcmp(old->graphic_str, real_packet->graphic_str) != 0);
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (strcmp(old->graphic_alt, real_packet->graphic_alt) != 0);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 13);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 14);
  }

  differ = (old->rmreqs_count != real_packet->rmreqs_count);
  if (differ) {
    BV_SET(fields, 15);
  }


    {
      differ = (old->rmreqs_count != real_packet->rmreqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->rmreqs_count; i++) {
          if (!are_requirements_equal(&old->rmreqs[i], &real_packet->rmreqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 16);
  }

  differ = (old->appearance_chance != real_packet->appearance_chance);
  if (differ) {
    BV_SET(fields, 17);
  }

  differ = (old->appearance_reqs_count != real_packet->appearance_reqs_count);
  if (differ) {
    BV_SET(fields, 18);
  }


    {
      differ = (old->appearance_reqs_count != real_packet->appearance_reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->appearance_reqs_count; i++) {
          if (!are_requirements_equal(&old->appearance_reqs[i], &real_packet->appearance_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 19);
  }

  differ = (old->disappearance_chance != real_packet->disappearance_chance);
  if (differ) {
    BV_SET(fields, 20);
  }

  differ = (old->disappearance_reqs_count != real_packet->disappearance_reqs_count);
  if (differ) {
    BV_SET(fields, 21);
  }


    {
      differ = (old->disappearance_reqs_count != real_packet->disappearance_reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->disappearance_reqs_count; i++) {
          if (!are_requirements_equal(&old->disappearance_reqs[i], &real_packet->disappearance_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 22);
  }

  differ = (old->visibility_req != real_packet->visibility_req);
  if (differ) {
    BV_SET(fields, 23);
  }

  if (packet->buildable) {
    BV_SET(fields, 24);
  }

  if (packet->generated) {
    BV_SET(fields, 25);
  }

  differ = (old->build_time != real_packet->build_time);
  if (differ) {
    BV_SET(fields, 26);
  }

  differ = (old->build_time_factor != real_packet->build_time_factor);
  if (differ) {
    BV_SET(fields, 27);
  }

  differ = (old->removal_time != real_packet->removal_time);
  if (differ) {
    BV_SET(fields, 28);
  }

  differ = (old->removal_time_factor != real_packet->removal_time_factor);
  if (differ) {
    BV_SET(fields, 29);
  }

  differ = (old->infracost != real_packet->infracost);
  if (differ) {
    BV_SET(fields, 30);
  }

  differ = (old->defense_bonus != real_packet->defense_bonus);
  if (differ) {
    BV_SET(fields, 31);
  }

  differ = (old->eus != real_packet->eus);
  if (differ) {
    BV_SET(fields, 32);
  }

  differ = !BV_ARE_EQUAL(old->native_to, real_packet->native_to);
  if (differ) {
    BV_SET(fields, 33);
  }

  differ = !BV_ARE_EQUAL(old->flags, real_packet->flags);
  if (differ) {
    BV_SET(fields, 34);
  }

  differ = !BV_ARE_EQUAL(old->hidden_by, real_packet->hidden_by);
  if (differ) {
    BV_SET(fields, 35);
  }

  differ = !BV_ARE_EQUAL(old->bridged_over, real_packet->bridged_over);
  if (differ) {
    BV_SET(fields, 36);
  }

  differ = !BV_ARE_EQUAL(old->conflicts, real_packet->conflicts);
  if (differ) {
    BV_SET(fields, 37);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 38);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'category' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->category);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'causes' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "causes";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->causes);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'rmcauses' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmcauses";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->rmcauses);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'activity_gfx' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_gfx";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->activity_gfx);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'act_gfx_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_gfx_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->act_gfx_alt);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'act_gfx_alt2' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_gfx_alt2";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->act_gfx_alt2);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'rmact_gfx' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmact_gfx";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rmact_gfx);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'rmact_gfx_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmact_gfx_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rmact_gfx_alt);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'graphic_str' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'graphic_alt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'rmreqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmreqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->rmreqs_count);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'rmreqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmreqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->rmreqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->rmreqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->rmreqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'appearance_chance' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "appearance_chance";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->appearance_chance);
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'appearance_reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "appearance_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->appearance_reqs_count);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'appearance_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "appearance_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->appearance_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->appearance_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->appearance_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'disappearance_chance' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disappearance_chance";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disappearance_chance);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'disappearance_reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disappearance_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->disappearance_reqs_count);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'disappearance_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disappearance_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->disappearance_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->disappearance_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->disappearance_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'visibility_req' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "visibility_req";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->visibility_req);
  }
  /* field 24 is folded into the header */
  /* field 25 is folded into the header */
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'build_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_time);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'build_time_factor' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_time_factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_time_factor);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'removal_time' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->removal_time);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'removal_time_factor' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal_time_factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->removal_time_factor);
  }
  if (BV_ISSET(fields, 30)) {
    log_packet_detailed("  field 'infracost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infracost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->infracost);
  }
  if (BV_ISSET(fields, 31)) {
    log_packet_detailed("  field 'defense_bonus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defense_bonus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->defense_bonus);
  }
  if (BV_ISSET(fields, 32)) {
    log_packet_detailed("  field 'eus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "eus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->eus);
  }
  if (BV_ISSET(fields, 33)) {
    log_packet_detailed("  field 'native_to' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "native_to";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->native_to);
  }
  if (BV_ISSET(fields, 34)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
  }
  if (BV_ISSET(fields, 35)) {
    log_packet_detailed("  field 'hidden_by' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hidden_by";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->hidden_by);
  }
  if (BV_ISSET(fields, 36)) {
    log_packet_detailed("  field 'bridged_over' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bridged_over";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->bridged_over);
  }
  if (BV_ISSET(fields, 37)) {
    log_packet_detailed("  field 'conflicts' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conflicts";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->conflicts);
  }
  if (BV_ISSET(fields, 38)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->category);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "causes";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->causes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmcauses";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->rmcauses);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_gfx";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->activity_gfx);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_gfx_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->act_gfx_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_gfx_alt2";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->act_gfx_alt2);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmact_gfx";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rmact_gfx);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmact_gfx_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rmact_gfx_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_str";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_str);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "graphic_alt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->graphic_alt);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmreqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->rmreqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rmreqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->rmreqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->rmreqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->rmreqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "appearance_chance";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->appearance_chance);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "appearance_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->appearance_reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "appearance_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->appearance_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->appearance_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->appearance_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disappearance_chance";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->disappearance_chance);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disappearance_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->disappearance_reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "disappearance_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->disappearance_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->disappearance_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->disappearance_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "visibility_req";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->visibility_req);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "buildable";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->buildable);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "generated";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->generated);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "build_time_factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->build_time_factor);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal_time";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->removal_time);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal_time_factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->removal_time_factor);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "infracost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->infracost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "defense_bonus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->defense_bonus);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "eus";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->eus);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "native_to";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->native_to);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hidden_by";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->hidden_by);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bridged_over";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->bridged_over);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "conflicts";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->conflicts);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);

#endif
  SEND_PACKET_END(PACKET_RULESET_EXTRA);
}

int send_packet_ruleset_extra(struct connection *pc, const struct packet_ruleset_extra *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_EXTRA].packet != NULL, -1,
                        "Handler for PACKET_RULESET_EXTRA not installed");
  return pc->phs.handlers->send[PACKET_RULESET_EXTRA].packet(pc, packet);
}

void lsend_packet_ruleset_extra(struct conn_list *dest, const struct packet_ruleset_extra *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_extra(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_extra_flag_100 hash_const

#define cmp_packet_ruleset_extra_flag_100 cmp_const

BV_DEFINE(packet_ruleset_extra_flag_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_extra_flag *receive_packet_ruleset_extra_flag_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_extra_flag_100_fields fields;
  struct packet_ruleset_extra_flag *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_EXTRA_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_extra_flag, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
    RECEIVE_PACKET_FIELD_ERROR(helptxt);
  }

#endif
  log_packet_detailed("packet_ruleset_extra_flag_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_extra_flag_100, cmp_packet_ruleset_extra_flag_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'helptxt'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptxt";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptxt, sizeof(real_packet->helptxt))) {
      RECEIVE_PACKET_FIELD_ERROR(helptxt);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_extra_flag_100(struct connection *pc, const struct packet_ruleset_extra_flag *packet)
{
  const struct packet_ruleset_extra_flag *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_extra_flag_100_fields fields;
  struct packet_ruleset_extra_flag *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_EXTRA_FLAG;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_EXTRA_FLAG);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_extra_flag_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_extra_flag_100, cmp_packet_ruleset_extra_flag_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->helptxt, real_packet->helptxt) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'helptxt' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptxt";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptxt);

#endif
  SEND_PACKET_END(PACKET_RULESET_EXTRA_FLAG);
}

int send_packet_ruleset_extra_flag(struct connection *pc, const struct packet_ruleset_extra_flag *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_EXTRA_FLAG].packet != NULL, -1,
                        "Handler for PACKET_RULESET_EXTRA_FLAG not installed");
  return pc->phs.handlers->send[PACKET_RULESET_EXTRA_FLAG].packet(pc, packet);
}

void lsend_packet_ruleset_extra_flag(struct conn_list *dest, const struct packet_ruleset_extra_flag *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_extra_flag(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_base_100 hash_const

#define cmp_packet_ruleset_base_100 cmp_const

BV_DEFINE(packet_ruleset_base_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_base *receive_packet_ruleset_base_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_base_100_fields fields;
  struct packet_ruleset_base *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_BASE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_base, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(gui_type);
    }
    real_packet->gui_type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->border_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(border_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_main_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->vision_main_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(vision_main_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_invis_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->vision_invis_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(vision_invis_sq);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_subs_sq";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->vision_subs_sq)) {
    RECEIVE_PACKET_FIELD_ERROR(vision_subs_sq);
  }

#endif
  log_packet_detailed("packet_ruleset_base_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_base_100, cmp_packet_ruleset_base_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'gui_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gui_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(gui_type);
      }
      real_packet->gui_type = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'border_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "border_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->border_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(border_sq);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'vision_main_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "vision_main_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->vision_main_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(vision_main_sq);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'vision_invis_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "vision_invis_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->vision_invis_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(vision_invis_sq);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'vision_subs_sq'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "vision_subs_sq";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->vision_subs_sq)) {
      RECEIVE_PACKET_FIELD_ERROR(vision_subs_sq);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_base_100(struct connection *pc, const struct packet_ruleset_base *packet)
{
  const struct packet_ruleset_base *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_base_100_fields fields;
  struct packet_ruleset_base *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_BASE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_BASE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_base_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_base_100, cmp_packet_ruleset_base_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->gui_type != real_packet->gui_type);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->border_sq != real_packet->border_sq);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->vision_main_sq != real_packet->vision_main_sq);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->vision_invis_sq != real_packet->vision_invis_sq);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->vision_subs_sq != real_packet->vision_subs_sq);
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'gui_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gui_type);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'border_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->border_sq);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'vision_main_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_main_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->vision_main_sq);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'vision_invis_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_invis_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->vision_invis_sq);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'vision_subs_sq' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_subs_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->vision_subs_sq);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gui_type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "border_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->border_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_main_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->vision_main_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_invis_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->vision_invis_sq);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vision_subs_sq";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->vision_subs_sq);

#endif
  SEND_PACKET_END(PACKET_RULESET_BASE);
}

int send_packet_ruleset_base(struct connection *pc, const struct packet_ruleset_base *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_BASE].packet != NULL, -1,
                        "Handler for PACKET_RULESET_BASE not installed");
  return pc->phs.handlers->send[PACKET_RULESET_BASE].packet(pc, packet);
}

void lsend_packet_ruleset_base(struct conn_list *dest, const struct packet_ruleset_base *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_base(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_road_100 hash_const

#define cmp_packet_ruleset_road_100 cmp_const

BV_DEFINE(packet_ruleset_road_100_fields, 12);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_road *receive_packet_ruleset_road_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_road_100_fields fields;
  struct packet_ruleset_road *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_ROAD;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_road, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(gui_type);
    }
    real_packet->gui_type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first_reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->first_reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(first_reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->first_reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(first_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->first_reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->first_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(first_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_cost";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->move_cost)) {
    RECEIVE_PACKET_FIELD_ERROR(move_cost);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_mode";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(move_mode);
    }
    real_packet->move_mode = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_incr_const";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tile_incr_const[i])) {
        RECEIVE_PACKET_FIELD_ERROR(tile_incr_const);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_incr";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tile_incr[i])) {
        RECEIVE_PACKET_FIELD_ERROR(tile_incr);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_bonus";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tile_bonus[i])) {
        RECEIVE_PACKET_FIELD_ERROR(tile_bonus);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "compat";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(compat);
    }
    real_packet->compat = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "integrates";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->integrates)) {
    RECEIVE_PACKET_FIELD_ERROR(integrates);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }

#endif
  log_packet_detailed("packet_ruleset_road_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_road_100, cmp_packet_ruleset_road_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'gui_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gui_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(gui_type);
      }
      real_packet->gui_type = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'first_reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "first_reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->first_reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(first_reqs_count);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'first_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "first_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->first_reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(first_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->first_reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->first_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(first_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'move_cost'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "move_cost";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->move_cost)) {
      RECEIVE_PACKET_FIELD_ERROR(move_cost);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'move_mode'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "move_mode";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(move_mode);
      }
      real_packet->move_mode = readin;
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'tile_incr_const'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile_incr_const";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tile_incr_const[i])) {
          RECEIVE_PACKET_FIELD_ERROR(tile_incr_const);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'tile_incr'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile_incr";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tile_incr[i])) {
          RECEIVE_PACKET_FIELD_ERROR(tile_incr);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'tile_bonus'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile_bonus";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint16, &din, &field_addr, &real_packet->tile_bonus[i])) {
          RECEIVE_PACKET_FIELD_ERROR(tile_bonus);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'compat'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "compat";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(compat);
      }
      real_packet->compat = readin;
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'integrates'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "integrates";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->integrates)) {
      RECEIVE_PACKET_FIELD_ERROR(integrates);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_road_100(struct connection *pc, const struct packet_ruleset_road *packet)
{
  const struct packet_ruleset_road *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_road_100_fields fields;
  struct packet_ruleset_road *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_ROAD;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_ROAD);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_road_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_road_100, cmp_packet_ruleset_road_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->gui_type != real_packet->gui_type);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->first_reqs_count != real_packet->first_reqs_count);
  if (differ) {
    BV_SET(fields, 2);
  }


    {
      differ = (old->first_reqs_count != real_packet->first_reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->first_reqs_count; i++) {
          if (!are_requirements_equal(&old->first_reqs[i], &real_packet->first_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->move_cost != real_packet->move_cost);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->move_mode != real_packet->move_mode);
  if (differ) {
    BV_SET(fields, 5);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->tile_incr_const[i] != real_packet->tile_incr_const[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 6);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->tile_incr[i] != real_packet->tile_incr[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 7);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->tile_bonus[i] != real_packet->tile_bonus[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (old->compat != real_packet->compat);
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = !BV_ARE_EQUAL(old->integrates, real_packet->integrates);
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = !BV_ARE_EQUAL(old->flags, real_packet->flags);
  if (differ) {
    BV_SET(fields, 11);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'gui_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gui_type);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'first_reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->first_reqs_count);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'first_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->first_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->first_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->first_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'move_cost' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->move_cost);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'move_mode' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_mode";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->move_mode);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'tile_incr_const' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_incr_const";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->tile_incr_const[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'tile_incr' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_incr";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->tile_incr[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'tile_bonus' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_bonus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->tile_bonus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'compat' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "compat";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->compat);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'integrates' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "integrates";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->integrates);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gui_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->gui_type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->first_reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "first_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->first_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->first_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->first_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_cost";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->move_cost);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "move_mode";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->move_mode);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_incr_const";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->tile_incr_const[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_incr";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->tile_incr[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile_bonus";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint16, &dout, &field_addr, real_packet->tile_bonus[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "compat";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->compat);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "integrates";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->integrates);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);

#endif
  SEND_PACKET_END(PACKET_RULESET_ROAD);
}

int send_packet_ruleset_road(struct connection *pc, const struct packet_ruleset_road *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_ROAD].packet != NULL, -1,
                        "Handler for PACKET_RULESET_ROAD not installed");
  return pc->phs.handlers->send[PACKET_RULESET_ROAD].packet(pc, packet);
}

void lsend_packet_ruleset_road(struct conn_list *dest, const struct packet_ruleset_road *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_road(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_goods_100 hash_const

#define cmp_packet_ruleset_goods_100 cmp_const

BV_DEFINE(packet_ruleset_goods_100_fields, 10);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_goods *receive_packet_ruleset_goods_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_goods_100_fields fields;
  struct packet_ruleset_goods *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_GOODS;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_goods, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "from_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->from_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(from_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "to_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->to_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(to_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "onetime_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->onetime_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(onetime_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }

#endif
  log_packet_detailed("packet_ruleset_goods_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_goods_100, cmp_packet_ruleset_goods_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'from_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "from_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->from_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(from_pct);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'to_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "to_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->to_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(to_pct);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'onetime_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "onetime_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->onetime_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(onetime_pct);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_goods_100(struct connection *pc, const struct packet_ruleset_goods *packet)
{
  const struct packet_ruleset_goods *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_goods_100_fields fields;
  struct packet_ruleset_goods *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_GOODS;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_GOODS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_goods_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_goods_100, cmp_packet_ruleset_goods_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 3);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->from_pct != real_packet->from_pct);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->to_pct != real_packet->to_pct);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->onetime_pct != real_packet->onetime_pct);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = !BV_ARE_EQUAL(old->flags, real_packet->flags);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 9);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'from_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "from_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->from_pct);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'to_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "to_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->to_pct);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'onetime_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "onetime_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->onetime_pct);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "from_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->from_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "to_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->to_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "onetime_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->onetime_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->flags);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);

#endif
  SEND_PACKET_END(PACKET_RULESET_GOODS);
}

int send_packet_ruleset_goods(struct connection *pc, const struct packet_ruleset_goods *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_GOODS].packet != NULL, -1,
                        "Handler for PACKET_RULESET_GOODS not installed");
  return pc->phs.handlers->send[PACKET_RULESET_GOODS].packet(pc, packet);
}

void lsend_packet_ruleset_goods(struct conn_list *dest, const struct packet_ruleset_goods *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_goods(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_disaster_100 hash_const

#define cmp_packet_ruleset_disaster_100 cmp_const

BV_DEFINE(packet_ruleset_disaster_100_fields, 7);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_disaster *receive_packet_ruleset_disaster_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_disaster_100_fields fields;
  struct packet_ruleset_disaster *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_DISASTER;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_disaster, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "frequency";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->frequency)) {
    RECEIVE_PACKET_FIELD_ERROR(frequency);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "effects";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->effects)) {
    RECEIVE_PACKET_FIELD_ERROR(effects);
  }

#endif
  log_packet_detailed("packet_ruleset_disaster_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_disaster_100, cmp_packet_ruleset_disaster_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'frequency'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "frequency";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->frequency)) {
      RECEIVE_PACKET_FIELD_ERROR(frequency);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'effects'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "effects";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->effects)) {
      RECEIVE_PACKET_FIELD_ERROR(effects);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_disaster_100(struct connection *pc, const struct packet_ruleset_disaster *packet)
{
  const struct packet_ruleset_disaster *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_disaster_100_fields fields;
  struct packet_ruleset_disaster *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_DISASTER;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_DISASTER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_disaster_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_disaster_100, cmp_packet_ruleset_disaster_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 3);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->frequency != real_packet->frequency);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = !BV_ARE_EQUAL(old->effects, real_packet->effects);
  if (differ) {
    BV_SET(fields, 6);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'frequency' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "frequency";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->frequency);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'effects' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "effects";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->effects);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "frequency";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->frequency);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "effects";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->effects);

#endif
  SEND_PACKET_END(PACKET_RULESET_DISASTER);
}

int send_packet_ruleset_disaster(struct connection *pc, const struct packet_ruleset_disaster *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_DISASTER].packet != NULL, -1,
                        "Handler for PACKET_RULESET_DISASTER not installed");
  return pc->phs.handlers->send[PACKET_RULESET_DISASTER].packet(pc, packet);
}

void lsend_packet_ruleset_disaster(struct conn_list *dest, const struct packet_ruleset_disaster *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_disaster(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_achievement_100 hash_const

#define cmp_packet_ruleset_achievement_100 cmp_const

BV_DEFINE(packet_ruleset_achievement_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_achievement *receive_packet_ruleset_achievement_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_achievement_100_fields fields;
  struct packet_ruleset_achievement *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_ACHIEVEMENT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_achievement, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unique";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->unique)) {
    RECEIVE_PACKET_FIELD_ERROR(unique);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }

#endif
  log_packet_detailed("packet_ruleset_achievement_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_achievement_100, cmp_packet_ruleset_achievement_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  real_packet->unique = BV_ISSET(fields, 4);
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->value)) {
      RECEIVE_PACKET_FIELD_ERROR(value);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_achievement_100(struct connection *pc, const struct packet_ruleset_achievement *packet)
{
  const struct packet_ruleset_achievement *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_achievement_100_fields fields;
  struct packet_ruleset_achievement *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_ACHIEVEMENT;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_ACHIEVEMENT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_achievement_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_achievement_100, cmp_packet_ruleset_achievement_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 3);
  }

  if (packet->unique) {
    BV_SET(fields, 4);
  }

  differ = (old->value != real_packet->value);
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  /* field 4 is folded into the header */
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->value);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "unique";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->unique);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->value);

#endif
  SEND_PACKET_END(PACKET_RULESET_ACHIEVEMENT);
}

int send_packet_ruleset_achievement(struct connection *pc, const struct packet_ruleset_achievement *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_ACHIEVEMENT].packet != NULL, -1,
                        "Handler for PACKET_RULESET_ACHIEVEMENT not installed");
  return pc->phs.handlers->send[PACKET_RULESET_ACHIEVEMENT].packet(pc, packet);
}

void lsend_packet_ruleset_achievement(struct conn_list *dest, const struct packet_ruleset_achievement *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_achievement(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_trade_100 hash_const

#define cmp_packet_ruleset_trade_100 cmp_const

BV_DEFINE(packet_ruleset_trade_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_trade *receive_packet_ruleset_trade_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_trade_100_fields fields;
  struct packet_ruleset_trade *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_TRADE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_trade, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_pct";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->trade_pct)) {
    RECEIVE_PACKET_FIELD_ERROR(trade_pct);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cancelling";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(cancelling);
    }
    real_packet->cancelling = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bonus_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(bonus_type);
    }
    real_packet->bonus_type = readin;
  }

#endif
  log_packet_detailed("packet_ruleset_trade_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_trade_100, cmp_packet_ruleset_trade_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'trade_pct'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "trade_pct";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->trade_pct)) {
      RECEIVE_PACKET_FIELD_ERROR(trade_pct);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'cancelling'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cancelling";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(cancelling);
      }
      real_packet->cancelling = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'bonus_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "bonus_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(bonus_type);
      }
      real_packet->bonus_type = readin;
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_trade_100(struct connection *pc, const struct packet_ruleset_trade *packet)
{
  const struct packet_ruleset_trade *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_trade_100_fields fields;
  struct packet_ruleset_trade *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_TRADE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_TRADE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_trade_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_trade_100, cmp_packet_ruleset_trade_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->trade_pct != real_packet->trade_pct);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->cancelling != real_packet->cancelling);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->bonus_type != real_packet->bonus_type);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'trade_pct' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->trade_pct);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'cancelling' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cancelling";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->cancelling);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'bonus_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bonus_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->bonus_type);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "trade_pct";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->trade_pct);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cancelling";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->cancelling);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bonus_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->bonus_type);

#endif
  SEND_PACKET_END(PACKET_RULESET_TRADE);
}

int send_packet_ruleset_trade(struct connection *pc, const struct packet_ruleset_trade *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_TRADE].packet != NULL, -1,
                        "Handler for PACKET_RULESET_TRADE not installed");
  return pc->phs.handlers->send[PACKET_RULESET_TRADE].packet(pc, packet);
}

void lsend_packet_ruleset_trade(struct conn_list *dest, const struct packet_ruleset_trade *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_trade(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_action_100 hash_const

#define cmp_packet_ruleset_action_100 cmp_const

BV_DEFINE(packet_ruleset_action_100_fields, 12);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_action *receive_packet_ruleset_action_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_action_100_fields fields;
  struct packet_ruleset_action *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_ACTION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_action, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ui_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->ui_name, sizeof(real_packet->ui_name))) {
    RECEIVE_PACKET_FIELD_ERROR(ui_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "quiet";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->quiet)) {
    RECEIVE_PACKET_FIELD_ERROR(quiet);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "result";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(result);
    }
    real_packet->result = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_results";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->sub_results)) {
    RECEIVE_PACKET_FIELD_ERROR(sub_results);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_consuming_always";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->actor_consuming_always)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_consuming_always);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(act_kind);
    }
    real_packet->act_kind = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tgt_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(tgt_kind);
    }
    real_packet->tgt_kind = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_tgt_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(sub_tgt_kind);
    }
    real_packet->sub_tgt_kind = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_distance";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->min_distance)) {
    RECEIVE_PACKET_FIELD_ERROR(min_distance);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "max_distance";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->max_distance)) {
    RECEIVE_PACKET_FIELD_ERROR(max_distance);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "blocked_by";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->blocked_by)) {
    RECEIVE_PACKET_FIELD_ERROR(blocked_by);
  }

#endif
  log_packet_detailed("packet_ruleset_action_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_action_100, cmp_packet_ruleset_action_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(id);
      }
      real_packet->id = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'ui_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ui_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->ui_name, sizeof(real_packet->ui_name))) {
      RECEIVE_PACKET_FIELD_ERROR(ui_name);
    }
  }
  real_packet->quiet = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'result'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "result";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(result);
      }
      real_packet->result = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'sub_results'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sub_results";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->sub_results)) {
      RECEIVE_PACKET_FIELD_ERROR(sub_results);
    }
  }
  real_packet->actor_consuming_always = BV_ISSET(fields, 5);
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'act_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "act_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(act_kind);
      }
      real_packet->act_kind = readin;
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'tgt_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tgt_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(tgt_kind);
      }
      real_packet->tgt_kind = readin;
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'sub_tgt_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "sub_tgt_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(sub_tgt_kind);
      }
      real_packet->sub_tgt_kind = readin;
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'min_distance'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "min_distance";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->min_distance)) {
      RECEIVE_PACKET_FIELD_ERROR(min_distance);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'max_distance'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "max_distance";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->max_distance)) {
      RECEIVE_PACKET_FIELD_ERROR(max_distance);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'blocked_by'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "blocked_by";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->blocked_by)) {
      RECEIVE_PACKET_FIELD_ERROR(blocked_by);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_action_100(struct connection *pc, const struct packet_ruleset_action *packet)
{
  const struct packet_ruleset_action *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_action_100_fields fields;
  struct packet_ruleset_action *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_ACTION;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_ACTION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_action_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_action_100, cmp_packet_ruleset_action_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->ui_name, real_packet->ui_name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  if (packet->quiet) {
    BV_SET(fields, 2);
  }

  differ = (old->result != real_packet->result);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = !BV_ARE_EQUAL(old->sub_results, real_packet->sub_results);
  if (differ) {
    BV_SET(fields, 4);
  }

  if (packet->actor_consuming_always) {
    BV_SET(fields, 5);
  }

  differ = (old->act_kind != real_packet->act_kind);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->tgt_kind != real_packet->tgt_kind);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->sub_tgt_kind != real_packet->sub_tgt_kind);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (old->min_distance != real_packet->min_distance);
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (old->max_distance != real_packet->max_distance);
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = !BV_ARE_EQUAL(old->blocked_by, real_packet->blocked_by);
  if (differ) {
    BV_SET(fields, 11);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'ui_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ui_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->ui_name);
  }
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'result' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "result";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->result);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'sub_results' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_results";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->sub_results);
  }
  /* field 5 is folded into the header */
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'act_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->act_kind);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'tgt_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tgt_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tgt_kind);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'sub_tgt_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_tgt_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->sub_tgt_kind);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'min_distance' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_distance";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->min_distance);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'max_distance' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "max_distance";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->max_distance);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'blocked_by' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "blocked_by";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->blocked_by);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ui_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->ui_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "quiet";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->quiet);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "result";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->result);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_results";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->sub_results);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_consuming_always";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->actor_consuming_always);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "act_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->act_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tgt_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tgt_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "sub_tgt_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->sub_tgt_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_distance";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->min_distance);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "max_distance";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->max_distance);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "blocked_by";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->blocked_by);

#endif
  SEND_PACKET_END(PACKET_RULESET_ACTION);
}

int send_packet_ruleset_action(struct connection *pc, const struct packet_ruleset_action *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_ACTION].packet != NULL, -1,
                        "Handler for PACKET_RULESET_ACTION not installed");
  return pc->phs.handlers->send[PACKET_RULESET_ACTION].packet(pc, packet);
}

void lsend_packet_ruleset_action(struct conn_list *dest, const struct packet_ruleset_action *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_action(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_action_enabler_100 hash_const

#define cmp_packet_ruleset_action_enabler_100 cmp_const

BV_DEFINE(packet_ruleset_action_enabler_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_action_enabler *receive_packet_ruleset_action_enabler_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_action_enabler_100_fields fields;
  struct packet_ruleset_action_enabler *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_ACTION_ENABLER;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_action_enabler, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "enabled_action";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(enabled_action);
    }
    real_packet->enabled_action = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->actor_reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(actor_reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->actor_reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(actor_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->actor_reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->actor_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(actor_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->target_reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(target_reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->target_reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(target_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->target_reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->target_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(target_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_action_enabler_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_action_enabler_100, cmp_packet_ruleset_action_enabler_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'enabled_action'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "enabled_action";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(enabled_action);
      }
      real_packet->enabled_action = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'actor_reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->actor_reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(actor_reqs_count);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'actor_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "actor_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->actor_reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(actor_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->actor_reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->actor_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(actor_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'target_reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->target_reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(target_reqs_count);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'target_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->target_reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(target_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->target_reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->target_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(target_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_action_enabler_100(struct connection *pc, const struct packet_ruleset_action_enabler *packet)
{
  const struct packet_ruleset_action_enabler *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_action_enabler_100_fields fields;
  struct packet_ruleset_action_enabler *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_ACTION_ENABLER;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_ACTION_ENABLER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_action_enabler_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_action_enabler_100, cmp_packet_ruleset_action_enabler_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->enabled_action != real_packet->enabled_action);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->actor_reqs_count != real_packet->actor_reqs_count);
  if (differ) {
    BV_SET(fields, 1);
  }


    {
      differ = (old->actor_reqs_count != real_packet->actor_reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->actor_reqs_count; i++) {
          if (!are_requirements_equal(&old->actor_reqs[i], &real_packet->actor_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->target_reqs_count != real_packet->target_reqs_count);
  if (differ) {
    BV_SET(fields, 3);
  }


    {
      differ = (old->target_reqs_count != real_packet->target_reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->target_reqs_count; i++) {
          if (!are_requirements_equal(&old->target_reqs[i], &real_packet->target_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'enabled_action' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "enabled_action";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->enabled_action);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'actor_reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->actor_reqs_count);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'actor_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->actor_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->actor_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->actor_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'target_reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->target_reqs_count);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'target_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->target_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->target_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->target_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "enabled_action";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->enabled_action);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->actor_reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "actor_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->actor_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->actor_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->actor_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->target_reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->target_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->target_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->target_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_ACTION_ENABLER);
}

int send_packet_ruleset_action_enabler(struct connection *pc, const struct packet_ruleset_action_enabler *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_ACTION_ENABLER].packet != NULL, -1,
                        "Handler for PACKET_RULESET_ACTION_ENABLER not installed");
  return pc->phs.handlers->send[PACKET_RULESET_ACTION_ENABLER].packet(pc, packet);
}

void lsend_packet_ruleset_action_enabler(struct conn_list *dest, const struct packet_ruleset_action_enabler *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_action_enabler(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_action_auto_100 hash_const

#define cmp_packet_ruleset_action_auto_100 cmp_const

BV_DEFINE(packet_ruleset_action_auto_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_action_auto *receive_packet_ruleset_action_auto_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_action_auto_100_fields fields;
  struct packet_ruleset_action_auto *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_ACTION_AUTO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_action_auto, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cause";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(cause);
    }
    real_packet->cause = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alternatives_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->alternatives_count)) {
    RECEIVE_PACKET_FIELD_ERROR(alternatives_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alternatives";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->alternatives_count > MAX_NUM_ACTIONS) {
      RECEIVE_PACKET_FIELD_ERROR(alternatives, ": truncation array");
    }
    for (i = 0; i < real_packet->alternatives_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      {
        int readin;
  
        if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
          RECEIVE_PACKET_FIELD_ERROR(alternatives);
        }
        real_packet->alternatives[i] = readin;
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_action_auto_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_action_auto_100, cmp_packet_ruleset_action_auto_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'cause'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "cause";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(cause);
      }
      real_packet->cause = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'alternatives_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "alternatives_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->alternatives_count)) {
      RECEIVE_PACKET_FIELD_ERROR(alternatives_count);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'alternatives'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "alternatives";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->alternatives_count > MAX_NUM_ACTIONS) {
        RECEIVE_PACKET_FIELD_ERROR(alternatives, ": truncation array");
      }
      for (i = 0; i < real_packet->alternatives_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        {
          int readin;
    
          if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
            RECEIVE_PACKET_FIELD_ERROR(alternatives);
          }
          real_packet->alternatives[i] = readin;
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_action_auto_100(struct connection *pc, const struct packet_ruleset_action_auto *packet)
{
  const struct packet_ruleset_action_auto *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_action_auto_100_fields fields;
  struct packet_ruleset_action_auto *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_ACTION_AUTO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_ACTION_AUTO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_action_auto_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_action_auto_100, cmp_packet_ruleset_action_auto_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->cause != real_packet->cause);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 2);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->alternatives_count != real_packet->alternatives_count);
  if (differ) {
    BV_SET(fields, 4);
  }


    {
      differ = (old->alternatives_count != real_packet->alternatives_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->alternatives_count; i++) {
          if (old->alternatives[i] != real_packet->alternatives[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'cause' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cause";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->cause);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'alternatives_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alternatives_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->alternatives_count);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'alternatives' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alternatives";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->alternatives_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->alternatives_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->alternatives[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "cause";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->cause);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alternatives_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->alternatives_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alternatives";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->alternatives_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->alternatives_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->alternatives[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_ACTION_AUTO);
}

int send_packet_ruleset_action_auto(struct connection *pc, const struct packet_ruleset_action_auto *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_ACTION_AUTO].packet != NULL, -1,
                        "Handler for PACKET_RULESET_ACTION_AUTO not installed");
  return pc->phs.handlers->send[PACKET_RULESET_ACTION_AUTO].packet(pc, packet);
}

void lsend_packet_ruleset_action_auto(struct conn_list *dest, const struct packet_ruleset_action_auto *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_action_auto(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_music_100 hash_const

#define cmp_packet_ruleset_music_100 cmp_const

BV_DEFINE(packet_ruleset_music_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_music *receive_packet_ruleset_music_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_music_100_fields fields;
  struct packet_ruleset_music *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_MUSIC;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_music, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "music_peaceful";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->music_peaceful, sizeof(real_packet->music_peaceful))) {
    RECEIVE_PACKET_FIELD_ERROR(music_peaceful);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "music_combat";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->music_combat, sizeof(real_packet->music_combat))) {
    RECEIVE_PACKET_FIELD_ERROR(music_combat);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_music_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_music_100, cmp_packet_ruleset_music_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'music_peaceful'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "music_peaceful";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->music_peaceful, sizeof(real_packet->music_peaceful))) {
      RECEIVE_PACKET_FIELD_ERROR(music_peaceful);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'music_combat'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "music_combat";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->music_combat, sizeof(real_packet->music_combat))) {
      RECEIVE_PACKET_FIELD_ERROR(music_combat);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_music_100(struct connection *pc, const struct packet_ruleset_music *packet)
{
  const struct packet_ruleset_music *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_music_100_fields fields;
  struct packet_ruleset_music *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_MUSIC;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_MUSIC);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_music_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_music_100, cmp_packet_ruleset_music_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->music_peaceful, real_packet->music_peaceful) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->music_combat, real_packet->music_combat) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 3);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'music_peaceful' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "music_peaceful";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->music_peaceful);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'music_combat' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "music_combat";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->music_combat);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "music_peaceful";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->music_peaceful);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "music_combat";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->music_combat);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_MUSIC);
}

int send_packet_ruleset_music(struct connection *pc, const struct packet_ruleset_music *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_MUSIC].packet != NULL, -1,
                        "Handler for PACKET_RULESET_MUSIC not installed");
  return pc->phs.handlers->send[PACKET_RULESET_MUSIC].packet(pc, packet);
}

void lsend_packet_ruleset_music(struct conn_list *dest, const struct packet_ruleset_music *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_music(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_multiplier_100 hash_const

#define cmp_packet_ruleset_multiplier_100 cmp_const

BV_DEFINE(packet_ruleset_multiplier_100_fields, 13);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_multiplier *receive_packet_ruleset_multiplier_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_multiplier_100_fields fields;
  struct packet_ruleset_multiplier *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_MULTIPLIER;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_multiplier, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "start";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->start)) {
    RECEIVE_PACKET_FIELD_ERROR(start);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stop";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->stop)) {
    RECEIVE_PACKET_FIELD_ERROR(stop);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "step";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->step)) {
    RECEIVE_PACKET_FIELD_ERROR(step);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "def";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->def)) {
    RECEIVE_PACKET_FIELD_ERROR(def);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "offset";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->offset)) {
    RECEIVE_PACKET_FIELD_ERROR(offset);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "factor";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->factor)) {
    RECEIVE_PACKET_FIELD_ERROR(factor);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "minimum_turns";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->minimum_turns)) {
    RECEIVE_PACKET_FIELD_ERROR(minimum_turns);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
    RECEIVE_PACKET_FIELD_ERROR(rule_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
    RECEIVE_PACKET_FIELD_ERROR(helptext);
  }

#endif
  log_packet_detailed("packet_ruleset_multiplier_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_multiplier_100, cmp_packet_ruleset_multiplier_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(id);
      }
      real_packet->id = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'start'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "start";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->start)) {
      RECEIVE_PACKET_FIELD_ERROR(start);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'stop'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "stop";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->stop)) {
      RECEIVE_PACKET_FIELD_ERROR(stop);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'step'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "step";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->step)) {
      RECEIVE_PACKET_FIELD_ERROR(step);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'def'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "def";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->def)) {
      RECEIVE_PACKET_FIELD_ERROR(def);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'offset'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "offset";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->offset)) {
      RECEIVE_PACKET_FIELD_ERROR(offset);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'factor'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "factor";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->factor)) {
      RECEIVE_PACKET_FIELD_ERROR(factor);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'minimum_turns'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "minimum_turns";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->minimum_turns)) {
      RECEIVE_PACKET_FIELD_ERROR(minimum_turns);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'rule_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rule_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->rule_name, sizeof(real_packet->rule_name))) {
      RECEIVE_PACKET_FIELD_ERROR(rule_name);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'helptext'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "helptext";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->helptext, sizeof(real_packet->helptext))) {
      RECEIVE_PACKET_FIELD_ERROR(helptext);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_multiplier_100(struct connection *pc, const struct packet_ruleset_multiplier *packet)
{
  const struct packet_ruleset_multiplier *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_multiplier_100_fields fields;
  struct packet_ruleset_multiplier *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_MULTIPLIER;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_MULTIPLIER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_multiplier_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_multiplier_100, cmp_packet_ruleset_multiplier_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->start != real_packet->start);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->stop != real_packet->stop);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->step != real_packet->step);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->def != real_packet->def);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->offset != real_packet->offset);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->factor != real_packet->factor);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->minimum_turns != real_packet->minimum_turns);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (strcmp(old->rule_name, real_packet->rule_name) != 0);
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 10);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (strcmp(old->helptext, real_packet->helptext) != 0);
  if (differ) {
    BV_SET(fields, 12);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'start' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "start";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->start);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'stop' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stop";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->stop);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'step' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "step";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->step);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'def' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "def";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->def);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'offset' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "offset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->offset);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'factor' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->factor);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'minimum_turns' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "minimum_turns";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->minimum_turns);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'rule_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'helptext' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "start";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->start);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stop";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->stop);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "step";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->step);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "def";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->def);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "offset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->offset);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "factor";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->factor);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "minimum_turns";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->minimum_turns);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rule_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->rule_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "helptext";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->helptext);

#endif
  SEND_PACKET_END(PACKET_RULESET_MULTIPLIER);
}

int send_packet_ruleset_multiplier(struct connection *pc, const struct packet_ruleset_multiplier *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_MULTIPLIER].packet != NULL, -1,
                        "Handler for PACKET_RULESET_MULTIPLIER not installed");
  return pc->phs.handlers->send[PACKET_RULESET_MULTIPLIER].packet(pc, packet);
}

void lsend_packet_ruleset_multiplier(struct conn_list *dest, const struct packet_ruleset_multiplier *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_multiplier(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_ruleset_multiplier(struct connection *pc, Multiplier_type_id id, int start, int stop, int step, int def, int offset, int factor, int minimum_turns, const char *name, const char *rule_name, int reqs_count, const struct requirement *reqs, const char *helptext)
{
  struct packet_ruleset_multiplier packet, *real_packet = &packet;

  real_packet->id = id;
  real_packet->start = start;
  real_packet->stop = stop;
  real_packet->step = step;
  real_packet->def = def;
  real_packet->offset = offset;
  real_packet->factor = factor;
  real_packet->minimum_turns = minimum_turns;
  sz_strlcpy(real_packet->name, name);
  sz_strlcpy(real_packet->rule_name, rule_name);
  real_packet->reqs_count = reqs_count;
  {
    int i;

    for (i = 0; i < real_packet->reqs_count; i++) {
      real_packet->reqs[i] = reqs[i];
    }
  }
  sz_strlcpy(real_packet->helptext, helptext);
  
  return send_packet_ruleset_multiplier(pc, real_packet);
}

void dlsend_packet_ruleset_multiplier(struct conn_list *dest, Multiplier_type_id id, int start, int stop, int step, int def, int offset, int factor, int minimum_turns, const char *name, const char *rule_name, int reqs_count, const struct requirement *reqs, const char *helptext)
{
  struct packet_ruleset_multiplier packet, *real_packet = &packet;

  real_packet->id = id;
  real_packet->start = start;
  real_packet->stop = stop;
  real_packet->step = step;
  real_packet->def = def;
  real_packet->offset = offset;
  real_packet->factor = factor;
  real_packet->minimum_turns = minimum_turns;
  sz_strlcpy(real_packet->name, name);
  sz_strlcpy(real_packet->rule_name, rule_name);
  real_packet->reqs_count = reqs_count;
  {
    int i;

    for (i = 0; i < real_packet->reqs_count; i++) {
      real_packet->reqs[i] = reqs[i];
    }
  }
  sz_strlcpy(real_packet->helptext, helptext);
  
  lsend_packet_ruleset_multiplier(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_clause_100 hash_const

#define cmp_packet_ruleset_clause_100 cmp_const

BV_DEFINE(packet_ruleset_clause_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_clause *receive_packet_ruleset_clause_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_clause_100_fields fields;
  struct packet_ruleset_clause *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_CLAUSE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_clause, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "enabled";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->enabled)) {
    RECEIVE_PACKET_FIELD_ERROR(enabled);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver_reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->giver_reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(giver_reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->giver_reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(giver_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->giver_reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->giver_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(giver_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "receiver_reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->receiver_reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(receiver_reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "receiver_reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->receiver_reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(receiver_reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->receiver_reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->receiver_reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(receiver_reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_clause_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_clause_100, cmp_packet_ruleset_clause_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  real_packet->enabled = BV_ISSET(fields, 1);
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'giver_reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "giver_reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->giver_reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(giver_reqs_count);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'giver_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "giver_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->giver_reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(giver_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->giver_reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->giver_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(giver_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'receiver_reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "receiver_reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->receiver_reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(receiver_reqs_count);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'receiver_reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "receiver_reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->receiver_reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(receiver_reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->receiver_reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->receiver_reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(receiver_reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_clause_100(struct connection *pc, const struct packet_ruleset_clause *packet)
{
  const struct packet_ruleset_clause *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_clause_100_fields fields;
  struct packet_ruleset_clause *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_CLAUSE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_CLAUSE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_clause_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_clause_100, cmp_packet_ruleset_clause_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 0);
  }

  if (packet->enabled) {
    BV_SET(fields, 1);
  }

  differ = (old->giver_reqs_count != real_packet->giver_reqs_count);
  if (differ) {
    BV_SET(fields, 2);
  }


    {
      differ = (old->giver_reqs_count != real_packet->giver_reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->giver_reqs_count; i++) {
          if (!are_requirements_equal(&old->giver_reqs[i], &real_packet->giver_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->receiver_reqs_count != real_packet->receiver_reqs_count);
  if (differ) {
    BV_SET(fields, 4);
  }


    {
      differ = (old->receiver_reqs_count != real_packet->receiver_reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->receiver_reqs_count; i++) {
          if (!are_requirements_equal(&old->receiver_reqs[i], &real_packet->receiver_reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  /* field 1 is folded into the header */
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'giver_reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->giver_reqs_count);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'giver_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->giver_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->giver_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->giver_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'receiver_reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "receiver_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->receiver_reqs_count);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'receiver_reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "receiver_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->receiver_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->receiver_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->receiver_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "enabled";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->enabled);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->giver_reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "giver_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->giver_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->giver_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->giver_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "receiver_reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->receiver_reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "receiver_reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->receiver_reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->receiver_reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->receiver_reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_CLAUSE);
}

int send_packet_ruleset_clause(struct connection *pc, const struct packet_ruleset_clause *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_CLAUSE].packet != NULL, -1,
                        "Handler for PACKET_RULESET_CLAUSE not installed");
  return pc->phs.handlers->send[PACKET_RULESET_CLAUSE].packet(pc, packet);
}

void lsend_packet_ruleset_clause(struct conn_list *dest, const struct packet_ruleset_clause *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_clause(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_control_100 hash_const

#define cmp_packet_ruleset_control_100 cmp_const

BV_DEFINE(packet_ruleset_control_100_fields, 30);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_control *receive_packet_ruleset_control_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_control_100_fields fields;
  struct packet_ruleset_control *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_CONTROL;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_control, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_classes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_unit_classes)) {
    RECEIVE_PACKET_FIELD_ERROR(num_unit_classes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_unit_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_unit_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_impr_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_impr_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_impr_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_classes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_tech_classes)) {
    RECEIVE_PACKET_FIELD_ERROR(num_tech_classes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_tech_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_tech_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_extra_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_extra_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_extra_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_base_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_base_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_base_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_road_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_road_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_road_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_resource_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_resource_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_resource_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_goods_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_goods_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_goods_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_disaster_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_disaster_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_disaster_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_achievement_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_achievement_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_achievement_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_multipliers";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_multipliers)) {
    RECEIVE_PACKET_FIELD_ERROR(num_multipliers);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_styles";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_styles)) {
    RECEIVE_PACKET_FIELD_ERROR(num_styles);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_music_styles";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_music_styles)) {
    RECEIVE_PACKET_FIELD_ERROR(num_music_styles);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->government_count)) {
    RECEIVE_PACKET_FIELD_ERROR(government_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nation_count)) {
    RECEIVE_PACKET_FIELD_ERROR(nation_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "styles_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->styles_count)) {
    RECEIVE_PACKET_FIELD_ERROR(styles_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->terrain_count)) {
    RECEIVE_PACKET_FIELD_ERROR(terrain_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_specialist_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_specialist_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_specialist_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_groups";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_nation_groups)) {
    RECEIVE_PACKET_FIELD_ERROR(num_nation_groups);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_sets";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_nation_sets)) {
    RECEIVE_PACKET_FIELD_ERROR(num_nation_sets);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_tileset";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_tileset, sizeof(real_packet->preferred_tileset))) {
    RECEIVE_PACKET_FIELD_ERROR(preferred_tileset);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_soundset";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_soundset, sizeof(real_packet->preferred_soundset))) {
    RECEIVE_PACKET_FIELD_ERROR(preferred_soundset);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_musicset";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_musicset, sizeof(real_packet->preferred_musicset))) {
    RECEIVE_PACKET_FIELD_ERROR(preferred_musicset);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "popup_tech_help";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->popup_tech_help)) {
    RECEIVE_PACKET_FIELD_ERROR(popup_tech_help);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->version, sizeof(real_packet->version))) {
    RECEIVE_PACKET_FIELD_ERROR(version);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alt_dir";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->alt_dir, sizeof(real_packet->alt_dir))) {
    RECEIVE_PACKET_FIELD_ERROR(alt_dir);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "desc_length32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->desc_length32)) {
    RECEIVE_PACKET_FIELD_ERROR(desc_length32);
  }

#endif
  log_packet_detailed("packet_ruleset_control_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_control_100, cmp_packet_ruleset_control_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'num_unit_classes'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_unit_classes";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_unit_classes)) {
      RECEIVE_PACKET_FIELD_ERROR(num_unit_classes);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'num_unit_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_unit_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_unit_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_unit_types);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'num_impr_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_impr_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_impr_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_impr_types);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'num_tech_classes'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_tech_classes";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_tech_classes)) {
      RECEIVE_PACKET_FIELD_ERROR(num_tech_classes);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'num_tech_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_tech_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_tech_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_tech_types);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'num_extra_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_extra_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_extra_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_extra_types);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'num_base_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_base_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_base_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_base_types);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'num_road_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_road_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_road_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_road_types);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'num_resource_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_resource_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_resource_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_resource_types);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'num_goods_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_goods_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_goods_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_goods_types);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'num_disaster_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_disaster_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_disaster_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_disaster_types);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'num_achievement_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_achievement_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_achievement_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_achievement_types);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'num_multipliers'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_multipliers";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_multipliers)) {
      RECEIVE_PACKET_FIELD_ERROR(num_multipliers);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'num_styles'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_styles";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_styles)) {
      RECEIVE_PACKET_FIELD_ERROR(num_styles);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'num_music_styles'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_music_styles";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_music_styles)) {
      RECEIVE_PACKET_FIELD_ERROR(num_music_styles);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'government_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "government_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->government_count)) {
      RECEIVE_PACKET_FIELD_ERROR(government_count);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'nation_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nation_count)) {
      RECEIVE_PACKET_FIELD_ERROR(nation_count);
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'styles_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "styles_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->styles_count)) {
      RECEIVE_PACKET_FIELD_ERROR(styles_count);
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'terrain_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "terrain_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->terrain_count)) {
      RECEIVE_PACKET_FIELD_ERROR(terrain_count);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'num_specialist_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_specialist_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_specialist_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_specialist_types);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'num_nation_groups'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_nation_groups";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_nation_groups)) {
      RECEIVE_PACKET_FIELD_ERROR(num_nation_groups);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'num_nation_sets'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_nation_sets";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_nation_sets)) {
      RECEIVE_PACKET_FIELD_ERROR(num_nation_sets);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'preferred_tileset'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "preferred_tileset";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_tileset, sizeof(real_packet->preferred_tileset))) {
      RECEIVE_PACKET_FIELD_ERROR(preferred_tileset);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'preferred_soundset'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "preferred_soundset";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_soundset, sizeof(real_packet->preferred_soundset))) {
      RECEIVE_PACKET_FIELD_ERROR(preferred_soundset);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'preferred_musicset'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "preferred_musicset";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_musicset, sizeof(real_packet->preferred_musicset))) {
      RECEIVE_PACKET_FIELD_ERROR(preferred_musicset);
    }
  }
  real_packet->popup_tech_help = BV_ISSET(fields, 25);
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'version'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "version";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->version, sizeof(real_packet->version))) {
      RECEIVE_PACKET_FIELD_ERROR(version);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'alt_dir'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "alt_dir";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->alt_dir, sizeof(real_packet->alt_dir))) {
      RECEIVE_PACKET_FIELD_ERROR(alt_dir);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'desc_length32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "desc_length32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->desc_length32)) {
      RECEIVE_PACKET_FIELD_ERROR(desc_length32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_control_100(struct connection *pc, const struct packet_ruleset_control *packet)
{
  const struct packet_ruleset_control *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_control_100_fields fields;
  struct packet_ruleset_control *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_CONTROL;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_CONTROL);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_control_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_control_100, cmp_packet_ruleset_control_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->num_unit_classes != real_packet->num_unit_classes);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->num_unit_types != real_packet->num_unit_types);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->num_impr_types != real_packet->num_impr_types);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->num_tech_classes != real_packet->num_tech_classes);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->num_tech_types != real_packet->num_tech_types);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->num_extra_types != real_packet->num_extra_types);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->num_base_types != real_packet->num_base_types);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->num_road_types != real_packet->num_road_types);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->num_resource_types != real_packet->num_resource_types);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (old->num_goods_types != real_packet->num_goods_types);
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (old->num_disaster_types != real_packet->num_disaster_types);
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (old->num_achievement_types != real_packet->num_achievement_types);
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (old->num_multipliers != real_packet->num_multipliers);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = (old->num_styles != real_packet->num_styles);
  if (differ) {
    BV_SET(fields, 13);
  }

  differ = (old->num_music_styles != real_packet->num_music_styles);
  if (differ) {
    BV_SET(fields, 14);
  }

  differ = (old->government_count != real_packet->government_count);
  if (differ) {
    BV_SET(fields, 15);
  }

  differ = (old->nation_count != real_packet->nation_count);
  if (differ) {
    BV_SET(fields, 16);
  }

  differ = (old->styles_count != real_packet->styles_count);
  if (differ) {
    BV_SET(fields, 17);
  }

  differ = (old->terrain_count != real_packet->terrain_count);
  if (differ) {
    BV_SET(fields, 18);
  }

  differ = (old->num_specialist_types != real_packet->num_specialist_types);
  if (differ) {
    BV_SET(fields, 19);
  }

  differ = (old->num_nation_groups != real_packet->num_nation_groups);
  if (differ) {
    BV_SET(fields, 20);
  }

  differ = (old->num_nation_sets != real_packet->num_nation_sets);
  if (differ) {
    BV_SET(fields, 21);
  }

  differ = (strcmp(old->preferred_tileset, real_packet->preferred_tileset) != 0);
  if (differ) {
    BV_SET(fields, 22);
  }

  differ = (strcmp(old->preferred_soundset, real_packet->preferred_soundset) != 0);
  if (differ) {
    BV_SET(fields, 23);
  }

  differ = (strcmp(old->preferred_musicset, real_packet->preferred_musicset) != 0);
  if (differ) {
    BV_SET(fields, 24);
  }

  if (packet->popup_tech_help) {
    BV_SET(fields, 25);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 26);
  }

  differ = (strcmp(old->version, real_packet->version) != 0);
  if (differ) {
    BV_SET(fields, 27);
  }

  differ = (strcmp(old->alt_dir, real_packet->alt_dir) != 0);
  if (differ) {
    BV_SET(fields, 28);
  }

  differ = (old->desc_length32 != real_packet->desc_length32);
  if (differ) {
    BV_SET(fields, 29);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'num_unit_classes' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_classes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_unit_classes);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'num_unit_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_unit_types);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'num_impr_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_impr_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_impr_types);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'num_tech_classes' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_classes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_tech_classes);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'num_tech_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_tech_types);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'num_extra_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_extra_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_extra_types);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'num_base_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_base_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_base_types);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'num_road_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_road_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_road_types);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'num_resource_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_resource_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_resource_types);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'num_goods_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_goods_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_goods_types);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'num_disaster_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_disaster_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_disaster_types);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'num_achievement_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_achievement_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_achievement_types);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'num_multipliers' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_multipliers";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_multipliers);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'num_styles' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_styles";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_styles);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'num_music_styles' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_music_styles";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_music_styles);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'government_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->government_count);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'nation_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->nation_count);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'styles_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "styles_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->styles_count);
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'terrain_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->terrain_count);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'num_specialist_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_specialist_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_specialist_types);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'num_nation_groups' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_groups";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_nation_groups);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'num_nation_sets' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_sets";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_nation_sets);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'preferred_tileset' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_tileset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_tileset);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'preferred_soundset' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_soundset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_soundset);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'preferred_musicset' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_musicset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_musicset);
  }
  /* field 25 is folded into the header */
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'version' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->version);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'alt_dir' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alt_dir";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->alt_dir);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'desc_length32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "desc_length32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->desc_length32);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_classes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_unit_classes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_unit_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_impr_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_impr_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_classes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_tech_classes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_tech_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_extra_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_extra_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_base_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_base_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_road_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_road_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_resource_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_resource_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_goods_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_goods_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_disaster_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_disaster_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_achievement_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_achievement_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_multipliers";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_multipliers);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_styles";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_styles);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_music_styles";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_music_styles);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->government_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->nation_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "styles_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->styles_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->terrain_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_specialist_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_specialist_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_groups";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_nation_groups);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_sets";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_nation_sets);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_tileset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_tileset);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_soundset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_soundset);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_musicset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_musicset);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "popup_tech_help";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->popup_tech_help);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->version);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alt_dir";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->alt_dir);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "desc_length32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->desc_length32);

#endif
  SEND_PACKET_END(PACKET_RULESET_CONTROL);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_control_101 hash_const

#define cmp_packet_ruleset_control_101 cmp_const

BV_DEFINE(packet_ruleset_control_101_fields, 30);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_control *receive_packet_ruleset_control_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_control_101_fields fields;
  struct packet_ruleset_control *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_CONTROL;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_control, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_classes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_unit_classes)) {
    RECEIVE_PACKET_FIELD_ERROR(num_unit_classes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_unit_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_unit_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_impr_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_impr_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_impr_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_classes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_tech_classes)) {
    RECEIVE_PACKET_FIELD_ERROR(num_tech_classes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_tech_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_tech_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_extra_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_extra_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_extra_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_base_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_base_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_base_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_road_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_road_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_road_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_resource_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_resource_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_resource_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_goods_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_goods_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_goods_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_disaster_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_disaster_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_disaster_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_achievement_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_achievement_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_achievement_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_multipliers";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_multipliers)) {
    RECEIVE_PACKET_FIELD_ERROR(num_multipliers);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_styles";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_styles)) {
    RECEIVE_PACKET_FIELD_ERROR(num_styles);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_music_styles";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_music_styles)) {
    RECEIVE_PACKET_FIELD_ERROR(num_music_styles);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->government_count)) {
    RECEIVE_PACKET_FIELD_ERROR(government_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nation_count)) {
    RECEIVE_PACKET_FIELD_ERROR(nation_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "styles_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->styles_count)) {
    RECEIVE_PACKET_FIELD_ERROR(styles_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->terrain_count)) {
    RECEIVE_PACKET_FIELD_ERROR(terrain_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_specialist_types";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_specialist_types)) {
    RECEIVE_PACKET_FIELD_ERROR(num_specialist_types);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_groups";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_nation_groups)) {
    RECEIVE_PACKET_FIELD_ERROR(num_nation_groups);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_sets";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_nation_sets)) {
    RECEIVE_PACKET_FIELD_ERROR(num_nation_sets);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_tileset";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_tileset, sizeof(real_packet->preferred_tileset))) {
    RECEIVE_PACKET_FIELD_ERROR(preferred_tileset);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_soundset";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_soundset, sizeof(real_packet->preferred_soundset))) {
    RECEIVE_PACKET_FIELD_ERROR(preferred_soundset);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_musicset";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_musicset, sizeof(real_packet->preferred_musicset))) {
    RECEIVE_PACKET_FIELD_ERROR(preferred_musicset);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "popup_tech_help";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->popup_tech_help)) {
    RECEIVE_PACKET_FIELD_ERROR(popup_tech_help);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->version, sizeof(real_packet->version))) {
    RECEIVE_PACKET_FIELD_ERROR(version);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alt_dir";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->alt_dir, sizeof(real_packet->alt_dir))) {
    RECEIVE_PACKET_FIELD_ERROR(alt_dir);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "desc_length16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->desc_length16)) {
    RECEIVE_PACKET_FIELD_ERROR(desc_length16);
  }

#endif
  log_packet_detailed("packet_ruleset_control_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_control_101, cmp_packet_ruleset_control_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'num_unit_classes'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_unit_classes";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_unit_classes)) {
      RECEIVE_PACKET_FIELD_ERROR(num_unit_classes);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'num_unit_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_unit_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_unit_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_unit_types);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'num_impr_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_impr_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_impr_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_impr_types);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'num_tech_classes'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_tech_classes";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_tech_classes)) {
      RECEIVE_PACKET_FIELD_ERROR(num_tech_classes);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'num_tech_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_tech_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_tech_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_tech_types);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'num_extra_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_extra_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_extra_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_extra_types);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'num_base_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_base_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_base_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_base_types);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'num_road_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_road_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_road_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_road_types);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'num_resource_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_resource_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_resource_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_resource_types);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'num_goods_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_goods_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_goods_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_goods_types);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'num_disaster_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_disaster_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_disaster_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_disaster_types);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'num_achievement_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_achievement_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_achievement_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_achievement_types);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'num_multipliers'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_multipliers";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_multipliers)) {
      RECEIVE_PACKET_FIELD_ERROR(num_multipliers);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'num_styles'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_styles";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_styles)) {
      RECEIVE_PACKET_FIELD_ERROR(num_styles);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'num_music_styles'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_music_styles";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_music_styles)) {
      RECEIVE_PACKET_FIELD_ERROR(num_music_styles);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'government_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "government_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->government_count)) {
      RECEIVE_PACKET_FIELD_ERROR(government_count);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'nation_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->nation_count)) {
      RECEIVE_PACKET_FIELD_ERROR(nation_count);
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'styles_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "styles_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->styles_count)) {
      RECEIVE_PACKET_FIELD_ERROR(styles_count);
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'terrain_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "terrain_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->terrain_count)) {
      RECEIVE_PACKET_FIELD_ERROR(terrain_count);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'num_specialist_types'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_specialist_types";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_specialist_types)) {
      RECEIVE_PACKET_FIELD_ERROR(num_specialist_types);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'num_nation_groups'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_nation_groups";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_nation_groups)) {
      RECEIVE_PACKET_FIELD_ERROR(num_nation_groups);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'num_nation_sets'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_nation_sets";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->num_nation_sets)) {
      RECEIVE_PACKET_FIELD_ERROR(num_nation_sets);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'preferred_tileset'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "preferred_tileset";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_tileset, sizeof(real_packet->preferred_tileset))) {
      RECEIVE_PACKET_FIELD_ERROR(preferred_tileset);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'preferred_soundset'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "preferred_soundset";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_soundset, sizeof(real_packet->preferred_soundset))) {
      RECEIVE_PACKET_FIELD_ERROR(preferred_soundset);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'preferred_musicset'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "preferred_musicset";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->preferred_musicset, sizeof(real_packet->preferred_musicset))) {
      RECEIVE_PACKET_FIELD_ERROR(preferred_musicset);
    }
  }
  real_packet->popup_tech_help = BV_ISSET(fields, 25);
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'version'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "version";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->version, sizeof(real_packet->version))) {
      RECEIVE_PACKET_FIELD_ERROR(version);
    }
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  got field 'alt_dir'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "alt_dir";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->alt_dir, sizeof(real_packet->alt_dir))) {
      RECEIVE_PACKET_FIELD_ERROR(alt_dir);
    }
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  got field 'desc_length16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "desc_length16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->desc_length16)) {
      RECEIVE_PACKET_FIELD_ERROR(desc_length16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_control_101(struct connection *pc, const struct packet_ruleset_control *packet)
{
  const struct packet_ruleset_control *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_control_101_fields fields;
  struct packet_ruleset_control *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_CONTROL;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_CONTROL);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_control_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_control_101, cmp_packet_ruleset_control_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->num_unit_classes != real_packet->num_unit_classes);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->num_unit_types != real_packet->num_unit_types);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->num_impr_types != real_packet->num_impr_types);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->num_tech_classes != real_packet->num_tech_classes);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->num_tech_types != real_packet->num_tech_types);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->num_extra_types != real_packet->num_extra_types);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->num_base_types != real_packet->num_base_types);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->num_road_types != real_packet->num_road_types);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->num_resource_types != real_packet->num_resource_types);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (old->num_goods_types != real_packet->num_goods_types);
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (old->num_disaster_types != real_packet->num_disaster_types);
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (old->num_achievement_types != real_packet->num_achievement_types);
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (old->num_multipliers != real_packet->num_multipliers);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = (old->num_styles != real_packet->num_styles);
  if (differ) {
    BV_SET(fields, 13);
  }

  differ = (old->num_music_styles != real_packet->num_music_styles);
  if (differ) {
    BV_SET(fields, 14);
  }

  differ = (old->government_count != real_packet->government_count);
  if (differ) {
    BV_SET(fields, 15);
  }

  differ = (old->nation_count != real_packet->nation_count);
  if (differ) {
    BV_SET(fields, 16);
  }

  differ = (old->styles_count != real_packet->styles_count);
  if (differ) {
    BV_SET(fields, 17);
  }

  differ = (old->terrain_count != real_packet->terrain_count);
  if (differ) {
    BV_SET(fields, 18);
  }

  differ = (old->num_specialist_types != real_packet->num_specialist_types);
  if (differ) {
    BV_SET(fields, 19);
  }

  differ = (old->num_nation_groups != real_packet->num_nation_groups);
  if (differ) {
    BV_SET(fields, 20);
  }

  differ = (old->num_nation_sets != real_packet->num_nation_sets);
  if (differ) {
    BV_SET(fields, 21);
  }

  differ = (strcmp(old->preferred_tileset, real_packet->preferred_tileset) != 0);
  if (differ) {
    BV_SET(fields, 22);
  }

  differ = (strcmp(old->preferred_soundset, real_packet->preferred_soundset) != 0);
  if (differ) {
    BV_SET(fields, 23);
  }

  differ = (strcmp(old->preferred_musicset, real_packet->preferred_musicset) != 0);
  if (differ) {
    BV_SET(fields, 24);
  }

  if (packet->popup_tech_help) {
    BV_SET(fields, 25);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 26);
  }

  differ = (strcmp(old->version, real_packet->version) != 0);
  if (differ) {
    BV_SET(fields, 27);
  }

  differ = (strcmp(old->alt_dir, real_packet->alt_dir) != 0);
  if (differ) {
    BV_SET(fields, 28);
  }

  differ = (old->desc_length16 != real_packet->desc_length16);
  if (differ) {
    BV_SET(fields, 29);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'num_unit_classes' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_classes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_unit_classes);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'num_unit_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_unit_types);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'num_impr_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_impr_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_impr_types);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'num_tech_classes' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_classes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_tech_classes);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'num_tech_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_tech_types);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'num_extra_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_extra_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_extra_types);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'num_base_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_base_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_base_types);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'num_road_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_road_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_road_types);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'num_resource_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_resource_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_resource_types);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'num_goods_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_goods_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_goods_types);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'num_disaster_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_disaster_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_disaster_types);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'num_achievement_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_achievement_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_achievement_types);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'num_multipliers' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_multipliers";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_multipliers);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'num_styles' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_styles";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_styles);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'num_music_styles' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_music_styles";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_music_styles);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'government_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->government_count);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'nation_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->nation_count);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'styles_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "styles_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->styles_count);
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'terrain_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->terrain_count);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'num_specialist_types' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_specialist_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_specialist_types);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'num_nation_groups' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_groups";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_nation_groups);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'num_nation_sets' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_sets";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_nation_sets);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'preferred_tileset' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_tileset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_tileset);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'preferred_soundset' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_soundset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_soundset);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'preferred_musicset' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_musicset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_musicset);
  }
  /* field 25 is folded into the header */
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'version' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->version);
  }
  if (BV_ISSET(fields, 28)) {
    log_packet_detailed("  field 'alt_dir' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alt_dir";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->alt_dir);
  }
  if (BV_ISSET(fields, 29)) {
    log_packet_detailed("  field 'desc_length16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "desc_length16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->desc_length16);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_classes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_unit_classes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_unit_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_unit_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_impr_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_impr_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_classes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_tech_classes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_tech_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_tech_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_extra_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_extra_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_base_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_base_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_road_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_road_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_resource_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_resource_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_goods_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_goods_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_disaster_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_disaster_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_achievement_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_achievement_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_multipliers";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_multipliers);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_styles";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_styles);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_music_styles";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_music_styles);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->government_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->nation_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "styles_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->styles_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->terrain_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_specialist_types";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_specialist_types);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_groups";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_nation_groups);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_nation_sets";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->num_nation_sets);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_tileset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_tileset);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_soundset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_soundset);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "preferred_musicset";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->preferred_musicset);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "popup_tech_help";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->popup_tech_help);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "version";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->version);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "alt_dir";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->alt_dir);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "desc_length16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->desc_length16);

#endif
  SEND_PACKET_END(PACKET_RULESET_CONTROL);
}

int send_packet_ruleset_control(struct connection *pc, const struct packet_ruleset_control *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_CONTROL].packet != NULL, -1,
                        "Handler for PACKET_RULESET_CONTROL not installed");
  return pc->phs.handlers->send[PACKET_RULESET_CONTROL].packet(pc, packet);
}

void lsend_packet_ruleset_control(struct conn_list *dest, const struct packet_ruleset_control *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_control(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_summary_100 hash_const

#define cmp_packet_ruleset_summary_100 cmp_const

BV_DEFINE(packet_ruleset_summary_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_summary *receive_packet_ruleset_summary_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_summary_100_fields fields;
  struct packet_ruleset_summary *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_SUMMARY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_summary, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "text";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->text, sizeof(real_packet->text))) {
    RECEIVE_PACKET_FIELD_ERROR(text);
  }

#endif
  log_packet_detailed("packet_ruleset_summary_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_summary_100, cmp_packet_ruleset_summary_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'text'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "text";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->text, sizeof(real_packet->text))) {
      RECEIVE_PACKET_FIELD_ERROR(text);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_summary_100(struct connection *pc, const struct packet_ruleset_summary *packet)
{
  const struct packet_ruleset_summary *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_summary_100_fields fields;
  struct packet_ruleset_summary *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_SUMMARY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_SUMMARY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_summary_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_summary_100, cmp_packet_ruleset_summary_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->text, real_packet->text) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'text' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "text";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->text);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "text";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->text);

#endif
  SEND_PACKET_END(PACKET_RULESET_SUMMARY);
}

int send_packet_ruleset_summary(struct connection *pc, const struct packet_ruleset_summary *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_SUMMARY].packet != NULL, -1,
                        "Handler for PACKET_RULESET_SUMMARY not installed");
  return pc->phs.handlers->send[PACKET_RULESET_SUMMARY].packet(pc, packet);
}

void lsend_packet_ruleset_summary(struct conn_list *dest, const struct packet_ruleset_summary *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_summary(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_description_part_100 hash_const

#define cmp_packet_ruleset_description_part_100 cmp_const

BV_DEFINE(packet_ruleset_description_part_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_description_part *receive_packet_ruleset_description_part_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_description_part_100_fields fields;
  struct packet_ruleset_description_part *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_DESCRIPTION_PART;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_description_part, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "text";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->text, sizeof(real_packet->text))) {
    RECEIVE_PACKET_FIELD_ERROR(text);
  }

#endif
  log_packet_detailed("packet_ruleset_description_part_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_description_part_100, cmp_packet_ruleset_description_part_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'text'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "text";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->text, sizeof(real_packet->text))) {
      RECEIVE_PACKET_FIELD_ERROR(text);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_description_part_100(struct connection *pc, const struct packet_ruleset_description_part *packet)
{
  const struct packet_ruleset_description_part *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_description_part_100_fields fields;
  struct packet_ruleset_description_part *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_DESCRIPTION_PART;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_DESCRIPTION_PART);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_description_part_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_description_part_100, cmp_packet_ruleset_description_part_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->text, real_packet->text) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'text' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "text";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->text);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "text";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->text);

#endif
  SEND_PACKET_END(PACKET_RULESET_DESCRIPTION_PART);
}

int send_packet_ruleset_description_part(struct connection *pc, const struct packet_ruleset_description_part *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_DESCRIPTION_PART].packet != NULL, -1,
                        "Handler for PACKET_RULESET_DESCRIPTION_PART not installed");
  return pc->phs.handlers->send[PACKET_RULESET_DESCRIPTION_PART].packet(pc, packet);
}

void lsend_packet_ruleset_description_part(struct conn_list *dest, const struct packet_ruleset_description_part *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_description_part(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_single_want_hack_req_100 hash_const

#define cmp_packet_single_want_hack_req_100 cmp_const

BV_DEFINE(packet_single_want_hack_req_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_single_want_hack_req *receive_packet_single_want_hack_req_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_single_want_hack_req_100_fields fields;
  struct packet_single_want_hack_req *old;
  struct genhash **hash = pc->phs.received + PACKET_SINGLE_WANT_HACK_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_single_want_hack_req, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "token";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->token, sizeof(real_packet->token))) {
    RECEIVE_PACKET_FIELD_ERROR(token);
  }

#endif
  log_packet_detailed("packet_single_want_hack_req_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_single_want_hack_req_100, cmp_packet_single_want_hack_req_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'token'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "token";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->token, sizeof(real_packet->token))) {
      RECEIVE_PACKET_FIELD_ERROR(token);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_single_want_hack_req_100(struct connection *pc, const struct packet_single_want_hack_req *packet)
{
  const struct packet_single_want_hack_req *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_single_want_hack_req_100_fields fields;
  struct packet_single_want_hack_req *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SINGLE_WANT_HACK_REQ;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SINGLE_WANT_HACK_REQ);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_single_want_hack_req_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_single_want_hack_req_100, cmp_packet_single_want_hack_req_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->token, real_packet->token) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'token' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "token";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->token);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "token";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->token);

#endif
  SEND_PACKET_END(PACKET_SINGLE_WANT_HACK_REQ);
}

int send_packet_single_want_hack_req(struct connection *pc, const struct packet_single_want_hack_req *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SINGLE_WANT_HACK_REQ].packet != NULL, -1,
                        "Handler for PACKET_SINGLE_WANT_HACK_REQ not installed");
  return pc->phs.handlers->send[PACKET_SINGLE_WANT_HACK_REQ].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_single_want_hack_reply_100 hash_const

#define cmp_packet_single_want_hack_reply_100 cmp_const

BV_DEFINE(packet_single_want_hack_reply_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_single_want_hack_reply *receive_packet_single_want_hack_reply_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_single_want_hack_reply_100_fields fields;
  struct packet_single_want_hack_reply *old;
  struct genhash **hash = pc->phs.received + PACKET_SINGLE_WANT_HACK_REPLY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_single_want_hack_reply, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "you_have_hack";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->you_have_hack)) {
    RECEIVE_PACKET_FIELD_ERROR(you_have_hack);
  }

#endif
  log_packet_detailed("packet_single_want_hack_reply_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_single_want_hack_reply_100, cmp_packet_single_want_hack_reply_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  real_packet->you_have_hack = BV_ISSET(fields, 0);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_single_want_hack_reply_100(struct connection *pc, const struct packet_single_want_hack_reply *packet)
{
  const struct packet_single_want_hack_reply *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_single_want_hack_reply_100_fields fields;
  struct packet_single_want_hack_reply *old;
  struct genhash **hash = pc->phs.sent + PACKET_SINGLE_WANT_HACK_REPLY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SINGLE_WANT_HACK_REPLY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_single_want_hack_reply_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_single_want_hack_reply_100, cmp_packet_single_want_hack_reply_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  if (packet->you_have_hack) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  /* field 0 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "you_have_hack";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->you_have_hack);

#endif
  SEND_PACKET_END(PACKET_SINGLE_WANT_HACK_REPLY);
}

int send_packet_single_want_hack_reply(struct connection *pc, const struct packet_single_want_hack_reply *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SINGLE_WANT_HACK_REPLY].packet != NULL, -1,
                        "Handler for PACKET_SINGLE_WANT_HACK_REPLY not installed");
  return pc->phs.handlers->send[PACKET_SINGLE_WANT_HACK_REPLY].packet(pc, packet);
}

int dsend_packet_single_want_hack_reply(struct connection *pc, bool you_have_hack)
{
  struct packet_single_want_hack_reply packet, *real_packet = &packet;

  real_packet->you_have_hack = you_have_hack;
  
  return send_packet_single_want_hack_reply(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_choices_100 hash_const

#define cmp_packet_ruleset_choices_100 cmp_const

BV_DEFINE(packet_ruleset_choices_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_choices *receive_packet_ruleset_choices_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_choices_100_fields fields;
  struct packet_ruleset_choices *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_CHOICES;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_choices, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ruleset_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ruleset_count)) {
    RECEIVE_PACKET_FIELD_ERROR(ruleset_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rulesets";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->ruleset_count > MAX_NUM_RULESETS) {
      RECEIVE_PACKET_FIELD_ERROR(rulesets, ": truncation array");
    }
    for (i = 0; i < real_packet->ruleset_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->rulesets[i], sizeof(real_packet->rulesets[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(rulesets);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_choices_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_choices_100, cmp_packet_ruleset_choices_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'ruleset_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ruleset_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ruleset_count)) {
      RECEIVE_PACKET_FIELD_ERROR(ruleset_count);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'rulesets'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rulesets";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->ruleset_count > MAX_NUM_RULESETS) {
        RECEIVE_PACKET_FIELD_ERROR(rulesets, ": truncation array");
      }
      for (i = 0; i < real_packet->ruleset_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->rulesets[i], sizeof(real_packet->rulesets[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(rulesets);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_choices_100(struct connection *pc, const struct packet_ruleset_choices *packet)
{
  const struct packet_ruleset_choices *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_choices_100_fields fields;
  struct packet_ruleset_choices *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_CHOICES;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_CHOICES);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_choices_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_choices_100, cmp_packet_ruleset_choices_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->ruleset_count != real_packet->ruleset_count);
  if (differ) {
    BV_SET(fields, 0);
  }


    {
      differ = (old->ruleset_count != real_packet->ruleset_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->ruleset_count; i++) {
          if (strcmp(old->rulesets[i], real_packet->rulesets[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'ruleset_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ruleset_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ruleset_count);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'rulesets' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rulesets";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ruleset_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ruleset_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->rulesets[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ruleset_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->ruleset_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rulesets";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->ruleset_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->ruleset_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->rulesets[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_CHOICES);
}

int send_packet_ruleset_choices(struct connection *pc, const struct packet_ruleset_choices *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_CHOICES].packet != NULL, -1,
                        "Handler for PACKET_RULESET_CHOICES not installed");
  return pc->phs.handlers->send[PACKET_RULESET_CHOICES].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_game_load_100 hash_const

#define cmp_packet_game_load_100 cmp_const

BV_DEFINE(packet_game_load_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_game_load *receive_packet_game_load_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_game_load_100_fields fields;
  struct packet_game_load *old;
  struct genhash **hash = pc->phs.received + PACKET_GAME_LOAD;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_game_load, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "load_successful";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->load_successful)) {
    RECEIVE_PACKET_FIELD_ERROR(load_successful);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "load_filename";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->load_filename, sizeof(real_packet->load_filename))) {
    RECEIVE_PACKET_FIELD_ERROR(load_filename);
  }

#endif
  log_packet_detailed("packet_game_load_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_game_load_100, cmp_packet_game_load_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  real_packet->load_successful = BV_ISSET(fields, 0);
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'load_filename'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "load_filename";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->load_filename, sizeof(real_packet->load_filename))) {
      RECEIVE_PACKET_FIELD_ERROR(load_filename);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_game_load_100(struct connection *pc, const struct packet_game_load *packet)
{
  const struct packet_game_load *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_game_load_100_fields fields;
  struct packet_game_load *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_GAME_LOAD;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_GAME_LOAD);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_game_load_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_game_load_100, cmp_packet_game_load_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  if (packet->load_successful) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->load_filename, real_packet->load_filename) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  /* field 0 is folded into the header */
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'load_filename' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "load_filename";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->load_filename);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "load_successful";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->load_successful);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "load_filename";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->load_filename);

#endif
  SEND_PACKET_END(PACKET_GAME_LOAD);
}

int send_packet_game_load(struct connection *pc, const struct packet_game_load *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_GAME_LOAD].packet != NULL, -1,
                        "Handler for PACKET_GAME_LOAD not installed");
  return pc->phs.handlers->send[PACKET_GAME_LOAD].packet(pc, packet);
}

void lsend_packet_game_load(struct conn_list *dest, const struct packet_game_load *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_game_load(pconn, packet);
  } conn_list_iterate_end;
}

int dsend_packet_game_load(struct connection *pc, bool load_successful, const char *load_filename)
{
  struct packet_game_load packet, *real_packet = &packet;

  real_packet->load_successful = load_successful;
  sz_strlcpy(real_packet->load_filename, load_filename);
  
  return send_packet_game_load(pc, real_packet);
}

void dlsend_packet_game_load(struct conn_list *dest, bool load_successful, const char *load_filename)
{
  struct packet_game_load packet, *real_packet = &packet;

  real_packet->load_successful = load_successful;
  sz_strlcpy(real_packet->load_filename, load_filename);
  
  lsend_packet_game_load(dest, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_server_setting_control_100 hash_const

#define cmp_packet_server_setting_control_100 cmp_const

BV_DEFINE(packet_server_setting_control_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_server_setting_control *receive_packet_server_setting_control_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_control_100_fields fields;
  struct packet_server_setting_control *old;
  struct genhash **hash = pc->phs.received + PACKET_SERVER_SETTING_CONTROL;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_server_setting_control, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "settings_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->settings_num)) {
    RECEIVE_PACKET_FIELD_ERROR(settings_num);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "categories_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->categories_num)) {
    RECEIVE_PACKET_FIELD_ERROR(categories_num);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_names";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->categories_num > 256) {
      RECEIVE_PACKET_FIELD_ERROR(category_names, ": truncation array");
    }
    for (i = 0; i < real_packet->categories_num; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->category_names[i], sizeof(real_packet->category_names[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(category_names);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_server_setting_control_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_control_100, cmp_packet_server_setting_control_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'settings_num'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "settings_num";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->settings_num)) {
      RECEIVE_PACKET_FIELD_ERROR(settings_num);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'categories_num'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "categories_num";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->categories_num)) {
      RECEIVE_PACKET_FIELD_ERROR(categories_num);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'category_names'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "category_names";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->categories_num > 256) {
        RECEIVE_PACKET_FIELD_ERROR(category_names, ": truncation array");
      }
      for (i = 0; i < real_packet->categories_num; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->category_names[i], sizeof(real_packet->category_names[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(category_names);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_setting_control_100(struct connection *pc, const struct packet_server_setting_control *packet)
{
  const struct packet_server_setting_control *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_control_100_fields fields;
  struct packet_server_setting_control *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SERVER_SETTING_CONTROL;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SERVER_SETTING_CONTROL);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_setting_control_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_control_100, cmp_packet_server_setting_control_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->settings_num != real_packet->settings_num);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->categories_num != real_packet->categories_num);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }


    {
      differ = (old->categories_num != real_packet->categories_num);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->categories_num; i++) {
          if (strcmp(old->category_names[i], real_packet->category_names[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'settings_num' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "settings_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->settings_num);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'categories_num' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "categories_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->categories_num);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'category_names' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->categories_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->categories_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->category_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "settings_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->settings_num);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "categories_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->categories_num);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->categories_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->categories_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->category_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_SERVER_SETTING_CONTROL);
}

int send_packet_server_setting_control(struct connection *pc, const struct packet_server_setting_control *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_SETTING_CONTROL].packet != NULL, -1,
                        "Handler for PACKET_SERVER_SETTING_CONTROL not installed");
  return pc->phs.handlers->send[PACKET_SERVER_SETTING_CONTROL].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_server_setting_const_100(const void *vkey)
{
  const struct packet_server_setting_const *key = (const struct packet_server_setting_const *) vkey;

  return key->id;
}

static bool cmp_packet_server_setting_const_100(const void *vkey1, const void *vkey2)
{
  const struct packet_server_setting_const *key1 = (const struct packet_server_setting_const *) vkey1;
  const struct packet_server_setting_const *key2 = (const struct packet_server_setting_const *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_server_setting_const_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_server_setting_const *receive_packet_server_setting_const_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_const_100_fields fields;
  struct packet_server_setting_const *old;
  struct genhash **hash = pc->phs.received + PACKET_SERVER_SETTING_CONST;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_server_setting_const, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "short_help";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->short_help, sizeof(real_packet->short_help))) {
    RECEIVE_PACKET_FIELD_ERROR(short_help);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extra_help";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->extra_help, sizeof(real_packet->extra_help))) {
    RECEIVE_PACKET_FIELD_ERROR(extra_help);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->category)) {
    RECEIVE_PACKET_FIELD_ERROR(category);
  }

#endif
  log_packet_detailed("packet_server_setting_const_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_const_100, cmp_packet_server_setting_const_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'short_help'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "short_help";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->short_help, sizeof(real_packet->short_help))) {
      RECEIVE_PACKET_FIELD_ERROR(short_help);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'extra_help'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "extra_help";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->extra_help, sizeof(real_packet->extra_help))) {
      RECEIVE_PACKET_FIELD_ERROR(extra_help);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'category'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "category";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->category)) {
      RECEIVE_PACKET_FIELD_ERROR(category);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_setting_const_100(struct connection *pc, const struct packet_server_setting_const *packet)
{
  const struct packet_server_setting_const *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_const_100_fields fields;
  struct packet_server_setting_const *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SERVER_SETTING_CONST;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SERVER_SETTING_CONST);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_setting_const_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_const_100, cmp_packet_server_setting_const_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->short_help, real_packet->short_help) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->extra_help, real_packet->extra_help) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->category != real_packet->category);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'short_help' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "short_help";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->short_help);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'extra_help' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extra_help";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->extra_help);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'category' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->category);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "short_help";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->short_help);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extra_help";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->extra_help);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "category";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->category);

#endif
  SEND_PACKET_END(PACKET_SERVER_SETTING_CONST);
}

int send_packet_server_setting_const(struct connection *pc, const struct packet_server_setting_const *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_SETTING_CONST].packet != NULL, -1,
                        "Handler for PACKET_SERVER_SETTING_CONST not installed");
  return pc->phs.handlers->send[PACKET_SERVER_SETTING_CONST].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_server_setting_bool_100(const void *vkey)
{
  const struct packet_server_setting_bool *key = (const struct packet_server_setting_bool *) vkey;

  return key->id;
}

static bool cmp_packet_server_setting_bool_100(const void *vkey1, const void *vkey2)
{
  const struct packet_server_setting_bool *key1 = (const struct packet_server_setting_bool *) vkey1;
  const struct packet_server_setting_bool *key2 = (const struct packet_server_setting_bool *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_server_setting_bool_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_server_setting_bool *receive_packet_server_setting_bool_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_bool_100_fields fields;
  struct packet_server_setting_bool *old;
  struct genhash **hash = pc->phs.received + PACKET_SERVER_SETTING_BOOL;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_server_setting_bool, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_visible)) {
    RECEIVE_PACKET_FIELD_ERROR(is_visible);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_changeable)) {
    RECEIVE_PACKET_FIELD_ERROR(is_changeable);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->initial_setting)) {
    RECEIVE_PACKET_FIELD_ERROR(initial_setting);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(setdef);
    }
    real_packet->setdef = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->val)) {
    RECEIVE_PACKET_FIELD_ERROR(val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->default_val)) {
    RECEIVE_PACKET_FIELD_ERROR(default_val);
  }

#endif
  log_packet_detailed("packet_server_setting_bool_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_bool_100, cmp_packet_server_setting_bool_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  real_packet->is_visible = BV_ISSET(fields, 0);
  real_packet->is_changeable = BV_ISSET(fields, 1);
  real_packet->initial_setting = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'setdef'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "setdef";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(setdef);
      }
      real_packet->setdef = readin;
    }
  }
  real_packet->val = BV_ISSET(fields, 4);
  real_packet->default_val = BV_ISSET(fields, 5);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_setting_bool_100(struct connection *pc, const struct packet_server_setting_bool *packet)
{
  const struct packet_server_setting_bool *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_bool_100_fields fields;
  struct packet_server_setting_bool *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SERVER_SETTING_BOOL;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SERVER_SETTING_BOOL);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_setting_bool_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_bool_100, cmp_packet_server_setting_bool_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->is_visible != real_packet->is_visible);
  if (differ) {
    different++;
  }
  if (packet->is_visible) {
    BV_SET(fields, 0);
  }

  differ = (old->is_changeable != real_packet->is_changeable);
  if (differ) {
    different++;
  }
  if (packet->is_changeable) {
    BV_SET(fields, 1);
  }

  differ = (old->initial_setting != real_packet->initial_setting);
  if (differ) {
    different++;
  }
  if (packet->initial_setting) {
    BV_SET(fields, 2);
  }

  differ = (old->setdef != real_packet->setdef);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->val != real_packet->val);
  if (differ) {
    different++;
  }
  if (packet->val) {
    BV_SET(fields, 4);
  }

  differ = (old->default_val != real_packet->default_val);
  if (differ) {
    different++;
  }
  if (packet->default_val) {
    BV_SET(fields, 5);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);

  /* field 0 is folded into the header */
  /* field 1 is folded into the header */
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'setdef' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
  }
  /* field 4 is folded into the header */
  /* field 5 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_visible);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_changeable);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->initial_setting);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->default_val);

#endif
  SEND_PACKET_END(PACKET_SERVER_SETTING_BOOL);
}

int send_packet_server_setting_bool(struct connection *pc, const struct packet_server_setting_bool *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_SETTING_BOOL].packet != NULL, -1,
                        "Handler for PACKET_SERVER_SETTING_BOOL not installed");
  return pc->phs.handlers->send[PACKET_SERVER_SETTING_BOOL].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_server_setting_int_100(const void *vkey)
{
  const struct packet_server_setting_int *key = (const struct packet_server_setting_int *) vkey;

  return key->id;
}

static bool cmp_packet_server_setting_int_100(const void *vkey1, const void *vkey2)
{
  const struct packet_server_setting_int *key1 = (const struct packet_server_setting_int *) vkey1;
  const struct packet_server_setting_int *key2 = (const struct packet_server_setting_int *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_server_setting_int_100_fields, 8);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_server_setting_int *receive_packet_server_setting_int_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_int_100_fields fields;
  struct packet_server_setting_int *old;
  struct genhash **hash = pc->phs.received + PACKET_SERVER_SETTING_INT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_server_setting_int, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_visible)) {
    RECEIVE_PACKET_FIELD_ERROR(is_visible);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_changeable)) {
    RECEIVE_PACKET_FIELD_ERROR(is_changeable);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->initial_setting)) {
    RECEIVE_PACKET_FIELD_ERROR(initial_setting);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(setdef);
    }
    real_packet->setdef = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->val)) {
    RECEIVE_PACKET_FIELD_ERROR(val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->default_val)) {
    RECEIVE_PACKET_FIELD_ERROR(default_val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->min_val)) {
    RECEIVE_PACKET_FIELD_ERROR(min_val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "max_val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->max_val)) {
    RECEIVE_PACKET_FIELD_ERROR(max_val);
  }

#endif
  log_packet_detailed("packet_server_setting_int_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_int_100, cmp_packet_server_setting_int_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  real_packet->is_visible = BV_ISSET(fields, 0);
  real_packet->is_changeable = BV_ISSET(fields, 1);
  real_packet->initial_setting = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'setdef'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "setdef";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(setdef);
      }
      real_packet->setdef = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->val)) {
      RECEIVE_PACKET_FIELD_ERROR(val);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'default_val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "default_val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->default_val)) {
      RECEIVE_PACKET_FIELD_ERROR(default_val);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'min_val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "min_val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->min_val)) {
      RECEIVE_PACKET_FIELD_ERROR(min_val);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'max_val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "max_val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->max_val)) {
      RECEIVE_PACKET_FIELD_ERROR(max_val);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_setting_int_100(struct connection *pc, const struct packet_server_setting_int *packet)
{
  const struct packet_server_setting_int *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_int_100_fields fields;
  struct packet_server_setting_int *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SERVER_SETTING_INT;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SERVER_SETTING_INT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_setting_int_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_int_100, cmp_packet_server_setting_int_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->is_visible != real_packet->is_visible);
  if (differ) {
    different++;
  }
  if (packet->is_visible) {
    BV_SET(fields, 0);
  }

  differ = (old->is_changeable != real_packet->is_changeable);
  if (differ) {
    different++;
  }
  if (packet->is_changeable) {
    BV_SET(fields, 1);
  }

  differ = (old->initial_setting != real_packet->initial_setting);
  if (differ) {
    different++;
  }
  if (packet->initial_setting) {
    BV_SET(fields, 2);
  }

  differ = (old->setdef != real_packet->setdef);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->val != real_packet->val);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->default_val != real_packet->default_val);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->min_val != real_packet->min_val);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }

  differ = (old->max_val != real_packet->max_val);
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);

  /* field 0 is folded into the header */
  /* field 1 is folded into the header */
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'setdef' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->val);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'default_val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->default_val);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'min_val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->min_val);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'max_val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "max_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->max_val);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_visible);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_changeable);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->initial_setting);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->default_val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "min_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->min_val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "max_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->max_val);

#endif
  SEND_PACKET_END(PACKET_SERVER_SETTING_INT);
}

int send_packet_server_setting_int(struct connection *pc, const struct packet_server_setting_int *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_SETTING_INT].packet != NULL, -1,
                        "Handler for PACKET_SERVER_SETTING_INT not installed");
  return pc->phs.handlers->send[PACKET_SERVER_SETTING_INT].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_server_setting_str_100(const void *vkey)
{
  const struct packet_server_setting_str *key = (const struct packet_server_setting_str *) vkey;

  return key->id;
}

static bool cmp_packet_server_setting_str_100(const void *vkey1, const void *vkey2)
{
  const struct packet_server_setting_str *key1 = (const struct packet_server_setting_str *) vkey1;
  const struct packet_server_setting_str *key2 = (const struct packet_server_setting_str *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_server_setting_str_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_server_setting_str *receive_packet_server_setting_str_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_str_100_fields fields;
  struct packet_server_setting_str *old;
  struct genhash **hash = pc->phs.received + PACKET_SERVER_SETTING_STR;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_server_setting_str, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_visible)) {
    RECEIVE_PACKET_FIELD_ERROR(is_visible);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_changeable)) {
    RECEIVE_PACKET_FIELD_ERROR(is_changeable);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->initial_setting)) {
    RECEIVE_PACKET_FIELD_ERROR(initial_setting);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(setdef);
    }
    real_packet->setdef = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->val, sizeof(real_packet->val))) {
    RECEIVE_PACKET_FIELD_ERROR(val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->default_val, sizeof(real_packet->default_val))) {
    RECEIVE_PACKET_FIELD_ERROR(default_val);
  }

#endif
  log_packet_detailed("packet_server_setting_str_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_str_100, cmp_packet_server_setting_str_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  real_packet->is_visible = BV_ISSET(fields, 0);
  real_packet->is_changeable = BV_ISSET(fields, 1);
  real_packet->initial_setting = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'setdef'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "setdef";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(setdef);
      }
      real_packet->setdef = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->val, sizeof(real_packet->val))) {
      RECEIVE_PACKET_FIELD_ERROR(val);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'default_val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "default_val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->default_val, sizeof(real_packet->default_val))) {
      RECEIVE_PACKET_FIELD_ERROR(default_val);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_setting_str_100(struct connection *pc, const struct packet_server_setting_str *packet)
{
  const struct packet_server_setting_str *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_str_100_fields fields;
  struct packet_server_setting_str *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SERVER_SETTING_STR;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SERVER_SETTING_STR);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_setting_str_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_str_100, cmp_packet_server_setting_str_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->is_visible != real_packet->is_visible);
  if (differ) {
    different++;
  }
  if (packet->is_visible) {
    BV_SET(fields, 0);
  }

  differ = (old->is_changeable != real_packet->is_changeable);
  if (differ) {
    different++;
  }
  if (packet->is_changeable) {
    BV_SET(fields, 1);
  }

  differ = (old->initial_setting != real_packet->initial_setting);
  if (differ) {
    different++;
  }
  if (packet->initial_setting) {
    BV_SET(fields, 2);
  }

  differ = (old->setdef != real_packet->setdef);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (strcmp(old->val, real_packet->val) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (strcmp(old->default_val, real_packet->default_val) != 0);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);

  /* field 0 is folded into the header */
  /* field 1 is folded into the header */
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'setdef' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->val);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'default_val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->default_val);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_visible);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_changeable);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->initial_setting);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->default_val);

#endif
  SEND_PACKET_END(PACKET_SERVER_SETTING_STR);
}

int send_packet_server_setting_str(struct connection *pc, const struct packet_server_setting_str *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_SETTING_STR].packet != NULL, -1,
                        "Handler for PACKET_SERVER_SETTING_STR not installed");
  return pc->phs.handlers->send[PACKET_SERVER_SETTING_STR].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_server_setting_enum_100(const void *vkey)
{
  const struct packet_server_setting_enum *key = (const struct packet_server_setting_enum *) vkey;

  return key->id;
}

static bool cmp_packet_server_setting_enum_100(const void *vkey1, const void *vkey2)
{
  const struct packet_server_setting_enum *key1 = (const struct packet_server_setting_enum *) vkey1;
  const struct packet_server_setting_enum *key2 = (const struct packet_server_setting_enum *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_server_setting_enum_100_fields, 9);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_server_setting_enum *receive_packet_server_setting_enum_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_enum_100_fields fields;
  struct packet_server_setting_enum *old;
  struct genhash **hash = pc->phs.received + PACKET_SERVER_SETTING_ENUM;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_server_setting_enum, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_visible)) {
    RECEIVE_PACKET_FIELD_ERROR(is_visible);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_changeable)) {
    RECEIVE_PACKET_FIELD_ERROR(is_changeable);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->initial_setting)) {
    RECEIVE_PACKET_FIELD_ERROR(initial_setting);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(setdef);
    }
    real_packet->setdef = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->val)) {
    RECEIVE_PACKET_FIELD_ERROR(val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->default_val)) {
    RECEIVE_PACKET_FIELD_ERROR(default_val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "values_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->values_num)) {
    RECEIVE_PACKET_FIELD_ERROR(values_num);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "support_names";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->values_num > 64) {
      RECEIVE_PACKET_FIELD_ERROR(support_names, ": truncation array");
    }
    for (i = 0; i < real_packet->values_num; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->support_names[i], sizeof(real_packet->support_names[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(support_names);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pretty_names";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->values_num > 64) {
      RECEIVE_PACKET_FIELD_ERROR(pretty_names, ": truncation array");
    }
    for (i = 0; i < real_packet->values_num; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->pretty_names[i], sizeof(real_packet->pretty_names[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(pretty_names);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_server_setting_enum_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_enum_100, cmp_packet_server_setting_enum_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  real_packet->is_visible = BV_ISSET(fields, 0);
  real_packet->is_changeable = BV_ISSET(fields, 1);
  real_packet->initial_setting = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'setdef'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "setdef";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(setdef);
      }
      real_packet->setdef = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->val)) {
      RECEIVE_PACKET_FIELD_ERROR(val);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'default_val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "default_val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->default_val)) {
      RECEIVE_PACKET_FIELD_ERROR(default_val);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'values_num'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "values_num";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->values_num)) {
      RECEIVE_PACKET_FIELD_ERROR(values_num);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'support_names'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "support_names";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->values_num > 64) {
        RECEIVE_PACKET_FIELD_ERROR(support_names, ": truncation array");
      }
      for (i = 0; i < real_packet->values_num; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->support_names[i], sizeof(real_packet->support_names[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(support_names);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'pretty_names'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "pretty_names";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->values_num > 64) {
        RECEIVE_PACKET_FIELD_ERROR(pretty_names, ": truncation array");
      }
      for (i = 0; i < real_packet->values_num; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->pretty_names[i], sizeof(real_packet->pretty_names[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(pretty_names);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_setting_enum_100(struct connection *pc, const struct packet_server_setting_enum *packet)
{
  const struct packet_server_setting_enum *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_enum_100_fields fields;
  struct packet_server_setting_enum *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SERVER_SETTING_ENUM;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SERVER_SETTING_ENUM);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_setting_enum_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_enum_100, cmp_packet_server_setting_enum_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->is_visible != real_packet->is_visible);
  if (differ) {
    different++;
  }
  if (packet->is_visible) {
    BV_SET(fields, 0);
  }

  differ = (old->is_changeable != real_packet->is_changeable);
  if (differ) {
    different++;
  }
  if (packet->is_changeable) {
    BV_SET(fields, 1);
  }

  differ = (old->initial_setting != real_packet->initial_setting);
  if (differ) {
    different++;
  }
  if (packet->initial_setting) {
    BV_SET(fields, 2);
  }

  differ = (old->setdef != real_packet->setdef);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->val != real_packet->val);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->default_val != real_packet->default_val);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->values_num != real_packet->values_num);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }


    {
      differ = (old->values_num != real_packet->values_num);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->values_num; i++) {
          if (strcmp(old->support_names[i], real_packet->support_names[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


    {
      differ = (old->values_num != real_packet->values_num);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->values_num; i++) {
          if (strcmp(old->pretty_names[i], real_packet->pretty_names[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);

  /* field 0 is folded into the header */
  /* field 1 is folded into the header */
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'setdef' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->val);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'default_val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->default_val);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'values_num' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "values_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->values_num);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'support_names' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "support_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->values_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->values_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->support_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'pretty_names' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pretty_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->values_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->values_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->pretty_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_visible);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_changeable);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->initial_setting);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->default_val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "values_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->values_num);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "support_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->values_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->values_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->support_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pretty_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->values_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->values_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->pretty_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_SERVER_SETTING_ENUM);
}

int send_packet_server_setting_enum(struct connection *pc, const struct packet_server_setting_enum *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_SETTING_ENUM].packet != NULL, -1,
                        "Handler for PACKET_SERVER_SETTING_ENUM not installed");
  return pc->phs.handlers->send[PACKET_SERVER_SETTING_ENUM].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_server_setting_bitwise_100(const void *vkey)
{
  const struct packet_server_setting_bitwise *key = (const struct packet_server_setting_bitwise *) vkey;

  return key->id;
}

static bool cmp_packet_server_setting_bitwise_100(const void *vkey1, const void *vkey2)
{
  const struct packet_server_setting_bitwise *key1 = (const struct packet_server_setting_bitwise *) vkey1;
  const struct packet_server_setting_bitwise *key2 = (const struct packet_server_setting_bitwise *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_server_setting_bitwise_100_fields, 9);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_server_setting_bitwise *receive_packet_server_setting_bitwise_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_bitwise_100_fields fields;
  struct packet_server_setting_bitwise *old;
  struct genhash **hash = pc->phs.received + PACKET_SERVER_SETTING_BITWISE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_server_setting_bitwise, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_visible)) {
    RECEIVE_PACKET_FIELD_ERROR(is_visible);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_changeable)) {
    RECEIVE_PACKET_FIELD_ERROR(is_changeable);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->initial_setting)) {
    RECEIVE_PACKET_FIELD_ERROR(initial_setting);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(setdef);
    }
    real_packet->setdef = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->val)) {
    RECEIVE_PACKET_FIELD_ERROR(val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->default_val)) {
    RECEIVE_PACKET_FIELD_ERROR(default_val);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bits_num";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->bits_num)) {
    RECEIVE_PACKET_FIELD_ERROR(bits_num);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "support_names";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->bits_num > 64) {
      RECEIVE_PACKET_FIELD_ERROR(support_names, ": truncation array");
    }
    for (i = 0; i < real_packet->bits_num; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->support_names[i], sizeof(real_packet->support_names[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(support_names);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pretty_names";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->bits_num > 64) {
      RECEIVE_PACKET_FIELD_ERROR(pretty_names, ": truncation array");
    }
    for (i = 0; i < real_packet->bits_num; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(string, &din, &field_addr, real_packet->pretty_names[i], sizeof(real_packet->pretty_names[i]))) {
        RECEIVE_PACKET_FIELD_ERROR(pretty_names);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_server_setting_bitwise_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_bitwise_100, cmp_packet_server_setting_bitwise_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  real_packet->is_visible = BV_ISSET(fields, 0);
  real_packet->is_changeable = BV_ISSET(fields, 1);
  real_packet->initial_setting = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'setdef'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "setdef";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(setdef);
      }
      real_packet->setdef = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->val)) {
      RECEIVE_PACKET_FIELD_ERROR(val);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'default_val'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "default_val";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->default_val)) {
      RECEIVE_PACKET_FIELD_ERROR(default_val);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'bits_num'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "bits_num";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->bits_num)) {
      RECEIVE_PACKET_FIELD_ERROR(bits_num);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'support_names'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "support_names";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->bits_num > 64) {
        RECEIVE_PACKET_FIELD_ERROR(support_names, ": truncation array");
      }
      for (i = 0; i < real_packet->bits_num; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->support_names[i], sizeof(real_packet->support_names[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(support_names);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'pretty_names'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "pretty_names";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->bits_num > 64) {
        RECEIVE_PACKET_FIELD_ERROR(pretty_names, ": truncation array");
      }
      for (i = 0; i < real_packet->bits_num; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(string, &din, &field_addr, real_packet->pretty_names[i], sizeof(real_packet->pretty_names[i]))) {
          RECEIVE_PACKET_FIELD_ERROR(pretty_names);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_server_setting_bitwise_100(struct connection *pc, const struct packet_server_setting_bitwise *packet)
{
  const struct packet_server_setting_bitwise *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_server_setting_bitwise_100_fields fields;
  struct packet_server_setting_bitwise *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SERVER_SETTING_BITWISE;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SERVER_SETTING_BITWISE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_server_setting_bitwise_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_server_setting_bitwise_100, cmp_packet_server_setting_bitwise_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->is_visible != real_packet->is_visible);
  if (differ) {
    different++;
  }
  if (packet->is_visible) {
    BV_SET(fields, 0);
  }

  differ = (old->is_changeable != real_packet->is_changeable);
  if (differ) {
    different++;
  }
  if (packet->is_changeable) {
    BV_SET(fields, 1);
  }

  differ = (old->initial_setting != real_packet->initial_setting);
  if (differ) {
    different++;
  }
  if (packet->initial_setting) {
    BV_SET(fields, 2);
  }

  differ = (old->setdef != real_packet->setdef);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }

  differ = (old->val != real_packet->val);
  if (differ) {
    different++;
    BV_SET(fields, 4);
  }

  differ = (old->default_val != real_packet->default_val);
  if (differ) {
    different++;
    BV_SET(fields, 5);
  }

  differ = (old->bits_num != real_packet->bits_num);
  if (differ) {
    different++;
    BV_SET(fields, 6);
  }


    {
      differ = (old->bits_num != real_packet->bits_num);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->bits_num; i++) {
          if (strcmp(old->support_names[i], real_packet->support_names[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 7);
  }


    {
      differ = (old->bits_num != real_packet->bits_num);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->bits_num; i++) {
          if (strcmp(old->pretty_names[i], real_packet->pretty_names[i]) != 0) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    different++;
    BV_SET(fields, 8);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);

  /* field 0 is folded into the header */
  /* field 1 is folded into the header */
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'setdef' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->val);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'default_val' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->default_val);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'bits_num' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bits_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->bits_num);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'support_names' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "support_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->bits_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->bits_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->support_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'pretty_names' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pretty_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->bits_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->bits_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->pretty_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_visible";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_visible);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_changeable";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_changeable);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "initial_setting";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->initial_setting);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "setdef";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->setdef);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "default_val";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->default_val);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bits_num";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->bits_num);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "support_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->bits_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->bits_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->support_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "pretty_names";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->bits_num);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->bits_num; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(string, &dout, &field_addr, real_packet->pretty_names[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_SERVER_SETTING_BITWISE);
}

int send_packet_server_setting_bitwise(struct connection *pc, const struct packet_server_setting_bitwise *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SERVER_SETTING_BITWISE].packet != NULL, -1,
                        "Handler for PACKET_SERVER_SETTING_BITWISE not installed");
  return pc->phs.handlers->send[PACKET_SERVER_SETTING_BITWISE].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_set_topology_100 hash_const

#define cmp_packet_set_topology_100 cmp_const

BV_DEFINE(packet_set_topology_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_set_topology *receive_packet_set_topology_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_set_topology_100_fields fields;
  struct packet_set_topology *old;
  struct genhash **hash = pc->phs.received + PACKET_SET_TOPOLOGY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_set_topology, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "topology_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->topology_id)) {
    RECEIVE_PACKET_FIELD_ERROR(topology_id);
  }

#endif
  log_packet_detailed("packet_set_topology_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_set_topology_100, cmp_packet_set_topology_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'topology_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "topology_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->topology_id)) {
      RECEIVE_PACKET_FIELD_ERROR(topology_id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_set_topology_100(struct connection *pc, const struct packet_set_topology *packet)
{
  const struct packet_set_topology *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_set_topology_100_fields fields;
  struct packet_set_topology *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SET_TOPOLOGY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SET_TOPOLOGY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_set_topology_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_set_topology_100, cmp_packet_set_topology_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->topology_id != real_packet->topology_id);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'topology_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "topology_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->topology_id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "topology_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->topology_id);

#endif
  SEND_PACKET_END(PACKET_SET_TOPOLOGY);
}

int send_packet_set_topology(struct connection *pc, const struct packet_set_topology *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SET_TOPOLOGY].packet != NULL, -1,
                        "Handler for PACKET_SET_TOPOLOGY not installed");
  return pc->phs.handlers->send[PACKET_SET_TOPOLOGY].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_effect_100 hash_const

#define cmp_packet_ruleset_effect_100 cmp_const

BV_DEFINE(packet_ruleset_effect_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_effect *receive_packet_ruleset_effect_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_effect_100_fields fields;
  struct packet_ruleset_effect *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_EFFECT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_effect, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "effect_type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(effect_type);
    }
    real_packet->effect_type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "effect_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->effect_value)) {
    RECEIVE_PACKET_FIELD_ERROR(effect_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "has_multiplier";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->has_multiplier)) {
    RECEIVE_PACKET_FIELD_ERROR(has_multiplier);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(multiplier);
    }
    real_packet->multiplier = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
    RECEIVE_PACKET_FIELD_ERROR(reqs_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->reqs_count > MAX_NUM_REQS) {
      RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
    }
    for (i = 0; i < real_packet->reqs_count; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
        RECEIVE_PACKET_FIELD_ERROR(reqs);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_effect_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_effect_100, cmp_packet_ruleset_effect_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'effect_type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "effect_type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(effect_type);
      }
      real_packet->effect_type = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'effect_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "effect_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->effect_value)) {
      RECEIVE_PACKET_FIELD_ERROR(effect_value);
    }
  }
  real_packet->has_multiplier = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'multiplier'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "multiplier";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(multiplier);
      }
      real_packet->multiplier = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'reqs_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->reqs_count)) {
      RECEIVE_PACKET_FIELD_ERROR(reqs_count);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'reqs'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "reqs";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->reqs_count > MAX_NUM_REQS) {
        RECEIVE_PACKET_FIELD_ERROR(reqs, ": truncation array");
      }
      for (i = 0; i < real_packet->reqs_count; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(requirement, &din, &field_addr, &real_packet->reqs[i])) {
          RECEIVE_PACKET_FIELD_ERROR(reqs);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_effect_100(struct connection *pc, const struct packet_ruleset_effect *packet)
{
  const struct packet_ruleset_effect *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_effect_100_fields fields;
  struct packet_ruleset_effect *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_EFFECT;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_EFFECT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_effect_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_effect_100, cmp_packet_ruleset_effect_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->effect_type != real_packet->effect_type);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->effect_value != real_packet->effect_value);
  if (differ) {
    BV_SET(fields, 1);
  }

  if (packet->has_multiplier) {
    BV_SET(fields, 2);
  }

  differ = (old->multiplier != real_packet->multiplier);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->reqs_count != real_packet->reqs_count);
  if (differ) {
    BV_SET(fields, 4);
  }


    {
      differ = (old->reqs_count != real_packet->reqs_count);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->reqs_count; i++) {
          if (!are_requirements_equal(&old->reqs[i], &real_packet->reqs[i])) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'effect_type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "effect_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->effect_type);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'effect_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "effect_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->effect_value);
  }
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'multiplier' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->multiplier);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'reqs_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'reqs' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "effect_type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->effect_type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "effect_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->effect_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "has_multiplier";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->has_multiplier);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "multiplier";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->multiplier);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->reqs_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "reqs";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->reqs_count);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->reqs_count; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(requirement, &dout, &field_addr, &real_packet->reqs[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_EFFECT);
}

int send_packet_ruleset_effect(struct connection *pc, const struct packet_ruleset_effect *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_EFFECT].packet != NULL, -1,
                        "Handler for PACKET_RULESET_EFFECT not installed");
  return pc->phs.handlers->send[PACKET_RULESET_EFFECT].packet(pc, packet);
}

void lsend_packet_ruleset_effect(struct conn_list *dest, const struct packet_ruleset_effect *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_effect(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_ruleset_resource_100 hash_const

#define cmp_packet_ruleset_resource_100 cmp_const

BV_DEFINE(packet_ruleset_resource_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_ruleset_resource *receive_packet_ruleset_resource_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_resource_100_fields fields;
  struct packet_ruleset_resource *old;
  struct genhash **hash = pc->phs.received + PACKET_RULESET_RESOURCE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_ruleset_resource, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "output";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < O_LAST; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->output[i])) {
        RECEIVE_PACKET_FIELD_ERROR(output);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }

#endif
  log_packet_detailed("packet_ruleset_resource_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_resource_100, cmp_packet_ruleset_resource_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'output'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "output";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < O_LAST; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->output[i])) {
          RECEIVE_PACKET_FIELD_ERROR(output);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_ruleset_resource_100(struct connection *pc, const struct packet_ruleset_resource *packet)
{
  const struct packet_ruleset_resource *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_ruleset_resource_100_fields fields;
  struct packet_ruleset_resource *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_RULESET_RESOURCE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_RULESET_RESOURCE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_ruleset_resource_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_ruleset_resource_100, cmp_packet_ruleset_resource_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < O_LAST; i++) {
          if (old->output[i] != real_packet->output[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'output' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "output";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->output[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "output";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, O_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < O_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->output[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }

#endif
  SEND_PACKET_END(PACKET_RULESET_RESOURCE);
}

int send_packet_ruleset_resource(struct connection *pc, const struct packet_ruleset_resource *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_RULESET_RESOURCE].packet != NULL, -1,
                        "Handler for PACKET_RULESET_RESOURCE not installed");
  return pc->phs.handlers->send[PACKET_RULESET_RESOURCE].packet(pc, packet);
}

void lsend_packet_ruleset_resource(struct conn_list *dest, const struct packet_ruleset_resource *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_ruleset_resource(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_scenario_info_100 hash_const

#define cmp_packet_scenario_info_100 cmp_const

BV_DEFINE(packet_scenario_info_100_fields, 14);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_scenario_info *receive_packet_scenario_info_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_scenario_info_100_fields fields;
  struct packet_scenario_info *old;
  struct genhash **hash = pc->phs.received + PACKET_SCENARIO_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_scenario_info, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_scenario";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_scenario)) {
    RECEIVE_PACKET_FIELD_ERROR(is_scenario);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "authors";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->authors, sizeof(real_packet->authors))) {
    RECEIVE_PACKET_FIELD_ERROR(authors);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "players";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->players)) {
    RECEIVE_PACKET_FIELD_ERROR(players);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "startpos_nations";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->startpos_nations)) {
    RECEIVE_PACKET_FIELD_ERROR(startpos_nations);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "save_random";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->save_random)) {
    RECEIVE_PACKET_FIELD_ERROR(save_random);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prevent_new_cities";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->prevent_new_cities)) {
    RECEIVE_PACKET_FIELD_ERROR(prevent_new_cities);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lake_flooding";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->lake_flooding)) {
    RECEIVE_PACKET_FIELD_ERROR(lake_flooding);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "handmade";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->handmade)) {
    RECEIVE_PACKET_FIELD_ERROR(handmade);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "allow_ai_type_fallback";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->allow_ai_type_fallback)) {
    RECEIVE_PACKET_FIELD_ERROR(allow_ai_type_fallback);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ruleset_locked";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->ruleset_locked)) {
    RECEIVE_PACKET_FIELD_ERROR(ruleset_locked);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "datafile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->datafile, sizeof(real_packet->datafile))) {
    RECEIVE_PACKET_FIELD_ERROR(datafile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "have_resources";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->have_resources)) {
    RECEIVE_PACKET_FIELD_ERROR(have_resources);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "req_caps";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->req_caps, sizeof(real_packet->req_caps))) {
    RECEIVE_PACKET_FIELD_ERROR(req_caps);
  }

#endif
  log_packet_detailed("packet_scenario_info_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_scenario_info_100, cmp_packet_scenario_info_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  real_packet->is_scenario = BV_ISSET(fields, 0);
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'authors'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "authors";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->authors, sizeof(real_packet->authors))) {
      RECEIVE_PACKET_FIELD_ERROR(authors);
    }
  }
  real_packet->players = BV_ISSET(fields, 3);
  real_packet->startpos_nations = BV_ISSET(fields, 4);
  real_packet->save_random = BV_ISSET(fields, 5);
  real_packet->prevent_new_cities = BV_ISSET(fields, 6);
  real_packet->lake_flooding = BV_ISSET(fields, 7);
  real_packet->handmade = BV_ISSET(fields, 8);
  real_packet->allow_ai_type_fallback = BV_ISSET(fields, 9);
  real_packet->ruleset_locked = BV_ISSET(fields, 10);
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'datafile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "datafile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->datafile, sizeof(real_packet->datafile))) {
      RECEIVE_PACKET_FIELD_ERROR(datafile);
    }
  }
  real_packet->have_resources = BV_ISSET(fields, 12);
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'req_caps'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "req_caps";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->req_caps, sizeof(real_packet->req_caps))) {
      RECEIVE_PACKET_FIELD_ERROR(req_caps);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_scenario_info_100(struct connection *pc, const struct packet_scenario_info *packet)
{
  const struct packet_scenario_info *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_scenario_info_100_fields fields;
  struct packet_scenario_info *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SCENARIO_INFO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SCENARIO_INFO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_scenario_info_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_scenario_info_100, cmp_packet_scenario_info_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  if (packet->is_scenario) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->authors, real_packet->authors) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  if (packet->players) {
    BV_SET(fields, 3);
  }

  if (packet->startpos_nations) {
    BV_SET(fields, 4);
  }

  if (packet->save_random) {
    BV_SET(fields, 5);
  }

  if (packet->prevent_new_cities) {
    BV_SET(fields, 6);
  }

  if (packet->lake_flooding) {
    BV_SET(fields, 7);
  }

  if (packet->handmade) {
    BV_SET(fields, 8);
  }

  if (packet->allow_ai_type_fallback) {
    BV_SET(fields, 9);
  }

  if (packet->ruleset_locked) {
    BV_SET(fields, 10);
  }

  differ = (strcmp(old->datafile, real_packet->datafile) != 0);
  if (differ) {
    BV_SET(fields, 11);
  }

  if (packet->have_resources) {
    BV_SET(fields, 12);
  }

  differ = (strcmp(old->req_caps, real_packet->req_caps) != 0);
  if (differ) {
    BV_SET(fields, 13);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  /* field 0 is folded into the header */
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'authors' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "authors";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->authors);
  }
  /* field 3 is folded into the header */
  /* field 4 is folded into the header */
  /* field 5 is folded into the header */
  /* field 6 is folded into the header */
  /* field 7 is folded into the header */
  /* field 8 is folded into the header */
  /* field 9 is folded into the header */
  /* field 10 is folded into the header */
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'datafile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "datafile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->datafile);
  }
  /* field 12 is folded into the header */
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'req_caps' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "req_caps";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->req_caps);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_scenario";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_scenario);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "authors";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->authors);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "players";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->players);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "startpos_nations";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->startpos_nations);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "save_random";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->save_random);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prevent_new_cities";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->prevent_new_cities);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lake_flooding";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->lake_flooding);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "handmade";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->handmade);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "allow_ai_type_fallback";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->allow_ai_type_fallback);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ruleset_locked";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->ruleset_locked);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "datafile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->datafile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "have_resources";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->have_resources);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "req_caps";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->req_caps);

#endif
  SEND_PACKET_END(PACKET_SCENARIO_INFO);
}

int send_packet_scenario_info(struct connection *pc, const struct packet_scenario_info *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SCENARIO_INFO].packet != NULL, -1,
                        "Handler for PACKET_SCENARIO_INFO not installed");
  return pc->phs.handlers->send[PACKET_SCENARIO_INFO].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_scenario_description_100 hash_const

#define cmp_packet_scenario_description_100 cmp_const

BV_DEFINE(packet_scenario_description_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_scenario_description *receive_packet_scenario_description_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_scenario_description_100_fields fields;
  struct packet_scenario_description *old;
  struct genhash **hash = pc->phs.received + PACKET_SCENARIO_DESCRIPTION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_scenario_description, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "description";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->description, sizeof(real_packet->description))) {
    RECEIVE_PACKET_FIELD_ERROR(description);
  }

#endif
  log_packet_detailed("packet_scenario_description_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_scenario_description_100, cmp_packet_scenario_description_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'description'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "description";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->description, sizeof(real_packet->description))) {
      RECEIVE_PACKET_FIELD_ERROR(description);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_scenario_description_100(struct connection *pc, const struct packet_scenario_description *packet)
{
  const struct packet_scenario_description *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_scenario_description_100_fields fields;
  struct packet_scenario_description *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SCENARIO_DESCRIPTION;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SCENARIO_DESCRIPTION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_scenario_description_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_scenario_description_100, cmp_packet_scenario_description_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->description, real_packet->description) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'description' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "description";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->description);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "description";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->description);

#endif
  SEND_PACKET_END(PACKET_SCENARIO_DESCRIPTION);
}

int send_packet_scenario_description(struct connection *pc, const struct packet_scenario_description *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SCENARIO_DESCRIPTION].packet != NULL, -1,
                        "Handler for PACKET_SCENARIO_DESCRIPTION not installed");
  return pc->phs.handlers->send[PACKET_SCENARIO_DESCRIPTION].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_save_scenario_100 hash_const

#define cmp_packet_save_scenario_100 cmp_const

BV_DEFINE(packet_save_scenario_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_save_scenario *receive_packet_save_scenario_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_save_scenario_100_fields fields;
  struct packet_save_scenario *old;
  struct genhash **hash = pc->phs.received + PACKET_SAVE_SCENARIO;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_save_scenario, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }

#endif
  log_packet_detailed("packet_save_scenario_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_save_scenario_100, cmp_packet_save_scenario_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_save_scenario_100(struct connection *pc, const struct packet_save_scenario *packet)
{
  const struct packet_save_scenario *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_save_scenario_100_fields fields;
  struct packet_save_scenario *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_SAVE_SCENARIO;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_SAVE_SCENARIO);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_save_scenario_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_save_scenario_100, cmp_packet_save_scenario_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);

#endif
  SEND_PACKET_END(PACKET_SAVE_SCENARIO);
}

int send_packet_save_scenario(struct connection *pc, const struct packet_save_scenario *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_SAVE_SCENARIO].packet != NULL, -1,
                        "Handler for PACKET_SAVE_SCENARIO not installed");
  return pc->phs.handlers->send[PACKET_SAVE_SCENARIO].packet(pc, packet);
}

int dsend_packet_save_scenario(struct connection *pc, const char *name)
{
  struct packet_save_scenario packet, *real_packet = &packet;

  sz_strlcpy(real_packet->name, name);
  
  return send_packet_save_scenario(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_vote_new_100 hash_const

#define cmp_packet_vote_new_100 cmp_const

BV_DEFINE(packet_vote_new_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_vote_new *receive_packet_vote_new_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_vote_new_100_fields fields;
  struct packet_vote_new *old;
  struct genhash **hash = pc->phs.received + PACKET_VOTE_NEW;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_vote_new, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->vote_no)) {
    RECEIVE_PACKET_FIELD_ERROR(vote_no);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "user";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->user, sizeof(real_packet->user))) {
    RECEIVE_PACKET_FIELD_ERROR(user);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "desc";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->desc, sizeof(real_packet->desc))) {
    RECEIVE_PACKET_FIELD_ERROR(desc);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "percent_required";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->percent_required)) {
    RECEIVE_PACKET_FIELD_ERROR(percent_required);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->flags)) {
    RECEIVE_PACKET_FIELD_ERROR(flags);
  }

#endif
  log_packet_detailed("packet_vote_new_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_vote_new_100, cmp_packet_vote_new_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'vote_no'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "vote_no";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->vote_no)) {
      RECEIVE_PACKET_FIELD_ERROR(vote_no);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'user'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "user";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->user, sizeof(real_packet->user))) {
      RECEIVE_PACKET_FIELD_ERROR(user);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'desc'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "desc";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->desc, sizeof(real_packet->desc))) {
      RECEIVE_PACKET_FIELD_ERROR(desc);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'percent_required'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "percent_required";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->percent_required)) {
      RECEIVE_PACKET_FIELD_ERROR(percent_required);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'flags'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "flags";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->flags)) {
      RECEIVE_PACKET_FIELD_ERROR(flags);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_vote_new_100(struct connection *pc, const struct packet_vote_new *packet)
{
  const struct packet_vote_new *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_vote_new_100_fields fields;
  struct packet_vote_new *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_VOTE_NEW;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_VOTE_NEW);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_vote_new_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_vote_new_100, cmp_packet_vote_new_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->vote_no != real_packet->vote_no);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->user, real_packet->user) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->desc, real_packet->desc) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->percent_required != real_packet->percent_required);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->flags != real_packet->flags);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'vote_no' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->vote_no);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'user' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "user";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->user);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'desc' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "desc";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->desc);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'percent_required' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "percent_required";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->percent_required);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'flags' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->flags);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->vote_no);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "user";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->user);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "desc";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->desc);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "percent_required";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->percent_required);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "flags";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->flags);

#endif
  SEND_PACKET_END(PACKET_VOTE_NEW);
}

int send_packet_vote_new(struct connection *pc, const struct packet_vote_new *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_VOTE_NEW].packet != NULL, -1,
                        "Handler for PACKET_VOTE_NEW not installed");
  return pc->phs.handlers->send[PACKET_VOTE_NEW].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_vote_update_100(const void *vkey)
{
  const struct packet_vote_update *key = (const struct packet_vote_update *) vkey;

  return key->vote_no;
}

static bool cmp_packet_vote_update_100(const void *vkey1, const void *vkey2)
{
  const struct packet_vote_update *key1 = (const struct packet_vote_update *) vkey1;
  const struct packet_vote_update *key2 = (const struct packet_vote_update *) vkey2;

  return key1->vote_no == key2->vote_no;
}
BV_DEFINE(packet_vote_update_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_vote_update *receive_packet_vote_update_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_vote_update_100_fields fields;
  struct packet_vote_update *old;
  struct genhash **hash = pc->phs.received + PACKET_VOTE_UPDATE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_vote_update, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->vote_no)) {
    RECEIVE_PACKET_FIELD_ERROR(vote_no);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->vote_no)) {
    RECEIVE_PACKET_FIELD_ERROR(vote_no);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "yes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->yes)) {
    RECEIVE_PACKET_FIELD_ERROR(yes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "no";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->no)) {
    RECEIVE_PACKET_FIELD_ERROR(no);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "abstain";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->abstain)) {
    RECEIVE_PACKET_FIELD_ERROR(abstain);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_voters";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->num_voters)) {
    RECEIVE_PACKET_FIELD_ERROR(num_voters);
  }

#endif
  log_packet_detailed("packet_vote_update_100: got info about (%d)",
    real_packet->vote_no);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_vote_update_100, cmp_packet_vote_update_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int vote_no = real_packet->vote_no;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->vote_no = vote_no;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'yes'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "yes";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->yes)) {
      RECEIVE_PACKET_FIELD_ERROR(yes);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'no'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "no";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->no)) {
      RECEIVE_PACKET_FIELD_ERROR(no);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'abstain'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "abstain";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->abstain)) {
      RECEIVE_PACKET_FIELD_ERROR(abstain);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'num_voters'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "num_voters";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->num_voters)) {
      RECEIVE_PACKET_FIELD_ERROR(num_voters);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_vote_update_100(struct connection *pc, const struct packet_vote_update *packet)
{
  const struct packet_vote_update *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_vote_update_100_fields fields;
  struct packet_vote_update *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_VOTE_UPDATE;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_VOTE_UPDATE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_vote_update_100: sending info about (%d)",
    real_packet->vote_no);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_vote_update_100, cmp_packet_vote_update_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->yes != real_packet->yes);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->no != real_packet->no);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->abstain != real_packet->abstain);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }

  differ = (old->num_voters != real_packet->num_voters);
  if (differ) {
    different++;
    BV_SET(fields, 3);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->vote_no);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'yes' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "yes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->yes);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'no' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->no);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'abstain' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "abstain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->abstain);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'num_voters' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_voters";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->num_voters);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->vote_no);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "yes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->yes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->no);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "abstain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->abstain);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "num_voters";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->num_voters);

#endif
  SEND_PACKET_END(PACKET_VOTE_UPDATE);
}

int send_packet_vote_update(struct connection *pc, const struct packet_vote_update *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_VOTE_UPDATE].packet != NULL, -1,
                        "Handler for PACKET_VOTE_UPDATE not installed");
  return pc->phs.handlers->send[PACKET_VOTE_UPDATE].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_vote_remove_100 hash_const

#define cmp_packet_vote_remove_100 cmp_const

BV_DEFINE(packet_vote_remove_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_vote_remove *receive_packet_vote_remove_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_vote_remove_100_fields fields;
  struct packet_vote_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_VOTE_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_vote_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->vote_no)) {
    RECEIVE_PACKET_FIELD_ERROR(vote_no);
  }

#endif
  log_packet_detailed("packet_vote_remove_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_vote_remove_100, cmp_packet_vote_remove_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'vote_no'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "vote_no";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->vote_no)) {
      RECEIVE_PACKET_FIELD_ERROR(vote_no);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_vote_remove_100(struct connection *pc, const struct packet_vote_remove *packet)
{
  const struct packet_vote_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_vote_remove_100_fields fields;
  struct packet_vote_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_VOTE_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_VOTE_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_vote_remove_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_vote_remove_100, cmp_packet_vote_remove_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->vote_no != real_packet->vote_no);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'vote_no' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->vote_no);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->vote_no);

#endif
  SEND_PACKET_END(PACKET_VOTE_REMOVE);
}

int send_packet_vote_remove(struct connection *pc, const struct packet_vote_remove *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_VOTE_REMOVE].packet != NULL, -1,
                        "Handler for PACKET_VOTE_REMOVE not installed");
  return pc->phs.handlers->send[PACKET_VOTE_REMOVE].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_vote_resolve_100 hash_const

#define cmp_packet_vote_resolve_100 cmp_const

BV_DEFINE(packet_vote_resolve_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_vote_resolve *receive_packet_vote_resolve_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_vote_resolve_100_fields fields;
  struct packet_vote_resolve *old;
  struct genhash **hash = pc->phs.received + PACKET_VOTE_RESOLVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_vote_resolve, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->vote_no)) {
    RECEIVE_PACKET_FIELD_ERROR(vote_no);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "passed";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->passed)) {
    RECEIVE_PACKET_FIELD_ERROR(passed);
  }

#endif
  log_packet_detailed("packet_vote_resolve_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_vote_resolve_100, cmp_packet_vote_resolve_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'vote_no'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "vote_no";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->vote_no)) {
      RECEIVE_PACKET_FIELD_ERROR(vote_no);
    }
  }
  real_packet->passed = BV_ISSET(fields, 1);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_vote_resolve_100(struct connection *pc, const struct packet_vote_resolve *packet)
{
  const struct packet_vote_resolve *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_vote_resolve_100_fields fields;
  struct packet_vote_resolve *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_VOTE_RESOLVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_VOTE_RESOLVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_vote_resolve_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_vote_resolve_100, cmp_packet_vote_resolve_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->vote_no != real_packet->vote_no);
  if (differ) {
    BV_SET(fields, 0);
  }

  if (packet->passed) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'vote_no' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->vote_no);
  }
  /* field 1 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->vote_no);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "passed";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->passed);

#endif
  SEND_PACKET_END(PACKET_VOTE_RESOLVE);
}

int send_packet_vote_resolve(struct connection *pc, const struct packet_vote_resolve *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_VOTE_RESOLVE].packet != NULL, -1,
                        "Handler for PACKET_VOTE_RESOLVE not installed");
  return pc->phs.handlers->send[PACKET_VOTE_RESOLVE].packet(pc, packet);
}

static struct packet_vote_submit *receive_packet_vote_submit_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_vote_submit, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */
#if 1 /* To match endif */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->vote_no)) {
    RECEIVE_PACKET_FIELD_ERROR(vote_no);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->value)) {
    RECEIVE_PACKET_FIELD_ERROR(value);
  }

#endif
  log_packet_detailed("packet_vote_submit_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_vote_submit_100(struct connection *pc, const struct packet_vote_submit *packet)
{
  const struct packet_vote_submit *real_packet = packet;
  SEND_PACKET_START(PACKET_VOTE_SUBMIT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_vote_submit_100: sending info about ()");
#if 1 /* To match endif */
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "vote_no";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->vote_no);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->value);

#endif
  SEND_PACKET_END(PACKET_VOTE_SUBMIT);
}

int send_packet_vote_submit(struct connection *pc, const struct packet_vote_submit *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_VOTE_SUBMIT].packet != NULL, -1,
                        "Handler for PACKET_VOTE_SUBMIT not installed");
  return pc->phs.handlers->send[PACKET_VOTE_SUBMIT].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_mode_100 hash_const

#define cmp_packet_edit_mode_100 cmp_const

BV_DEFINE(packet_edit_mode_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_mode *receive_packet_edit_mode_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_mode_100_fields fields;
  struct packet_edit_mode *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_MODE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_mode, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "state";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->state)) {
    RECEIVE_PACKET_FIELD_ERROR(state);
  }

#endif
  log_packet_detailed("packet_edit_mode_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_mode_100, cmp_packet_edit_mode_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  real_packet->state = BV_ISSET(fields, 0);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_mode_100(struct connection *pc, const struct packet_edit_mode *packet)
{
  const struct packet_edit_mode *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_mode_100_fields fields;
  struct packet_edit_mode *old;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_MODE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_MODE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_mode_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_mode_100, cmp_packet_edit_mode_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  if (packet->state) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  /* field 0 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "state";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->state);

#endif
  SEND_PACKET_END(PACKET_EDIT_MODE);
}

int send_packet_edit_mode(struct connection *pc, const struct packet_edit_mode *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_MODE].packet != NULL, -1,
                        "Handler for PACKET_EDIT_MODE not installed");
  return pc->phs.handlers->send[PACKET_EDIT_MODE].packet(pc, packet);
}

int dsend_packet_edit_mode(struct connection *pc, bool state)
{
  struct packet_edit_mode packet, *real_packet = &packet;

  real_packet->state = state;
  
  return send_packet_edit_mode(pc, real_packet);
}

static struct packet_edit_recalculate_borders *receive_packet_edit_recalculate_borders_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_edit_recalculate_borders, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_edit_recalculate_borders_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_recalculate_borders_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_EDIT_RECALCULATE_BORDERS);

  log_packet_detailed("packet_edit_recalculate_borders_100: sending info about ()");
  SEND_PACKET_END(PACKET_EDIT_RECALCULATE_BORDERS);
}

int send_packet_edit_recalculate_borders(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_RECALCULATE_BORDERS].no_packet != NULL, -1,
                        "Handler for PACKET_EDIT_RECALCULATE_BORDERS not installed");
  return pc->phs.handlers->send[PACKET_EDIT_RECALCULATE_BORDERS].no_packet(pc);
}

static struct packet_edit_check_tiles *receive_packet_edit_check_tiles_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_edit_check_tiles, real_packet);
#if 1 /* To match endif */
  real_packet->__dummy = 0xff;
#endif
  log_packet_detailed("packet_edit_check_tiles_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_check_tiles_100(struct connection *pc)
{
  SEND_PACKET_START(PACKET_EDIT_CHECK_TILES);

  log_packet_detailed("packet_edit_check_tiles_100: sending info about ()");
  SEND_PACKET_END(PACKET_EDIT_CHECK_TILES);
}

int send_packet_edit_check_tiles(struct connection *pc)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_CHECK_TILES].no_packet != NULL, -1,
                        "Handler for PACKET_EDIT_CHECK_TILES not installed");
  return pc->phs.handlers->send[PACKET_EDIT_CHECK_TILES].no_packet(pc);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_toggle_fogofwar_100 hash_const

#define cmp_packet_edit_toggle_fogofwar_100 cmp_const

BV_DEFINE(packet_edit_toggle_fogofwar_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_toggle_fogofwar *receive_packet_edit_toggle_fogofwar_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_toggle_fogofwar_100_fields fields;
  struct packet_edit_toggle_fogofwar *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_TOGGLE_FOGOFWAR;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_toggle_fogofwar, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player)) {
    RECEIVE_PACKET_FIELD_ERROR(player);
  }

#endif
  log_packet_detailed("packet_edit_toggle_fogofwar_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_toggle_fogofwar_100, cmp_packet_edit_toggle_fogofwar_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'player'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "player";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player)) {
      RECEIVE_PACKET_FIELD_ERROR(player);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_toggle_fogofwar_100(struct connection *pc, const struct packet_edit_toggle_fogofwar *packet)
{
  const struct packet_edit_toggle_fogofwar *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_toggle_fogofwar_100_fields fields;
  struct packet_edit_toggle_fogofwar *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_TOGGLE_FOGOFWAR;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_TOGGLE_FOGOFWAR);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_toggle_fogofwar_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_toggle_fogofwar_100, cmp_packet_edit_toggle_fogofwar_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->player != real_packet->player);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'player' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player);

#endif
  SEND_PACKET_END(PACKET_EDIT_TOGGLE_FOGOFWAR);
}

int send_packet_edit_toggle_fogofwar(struct connection *pc, const struct packet_edit_toggle_fogofwar *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_TOGGLE_FOGOFWAR].packet != NULL, -1,
                        "Handler for PACKET_EDIT_TOGGLE_FOGOFWAR not installed");
  return pc->phs.handlers->send[PACKET_EDIT_TOGGLE_FOGOFWAR].packet(pc, packet);
}

int dsend_packet_edit_toggle_fogofwar(struct connection *pc, int player)
{
  struct packet_edit_toggle_fogofwar packet, *real_packet = &packet;

  real_packet->player = player;
  
  return send_packet_edit_toggle_fogofwar(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_edit_tile_terrain_100(const void *vkey)
{
  const struct packet_edit_tile_terrain *key = (const struct packet_edit_tile_terrain *) vkey;

  return key->tile;
}

static bool cmp_packet_edit_tile_terrain_100(const void *vkey1, const void *vkey2)
{
  const struct packet_edit_tile_terrain *key1 = (const struct packet_edit_tile_terrain *) vkey1;
  const struct packet_edit_tile_terrain *key2 = (const struct packet_edit_tile_terrain *) vkey2;

  return key1->tile == key2->tile;
}
BV_DEFINE(packet_edit_tile_terrain_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_tile_terrain *receive_packet_edit_tile_terrain_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_tile_terrain_100_fields fields;
  struct packet_edit_tile_terrain *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_TILE_TERRAIN;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_tile_terrain, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(terrain);
    }
    real_packet->terrain = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }

#endif
  log_packet_detailed("packet_edit_tile_terrain_100: got info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_tile_terrain_100, cmp_packet_edit_tile_terrain_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int tile = real_packet->tile;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->tile = tile;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'terrain'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "terrain";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(terrain);
      }
      real_packet->terrain = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_tile_terrain_100(struct connection *pc, const struct packet_edit_tile_terrain *packet)
{
  const struct packet_edit_tile_terrain *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_tile_terrain_100_fields fields;
  struct packet_edit_tile_terrain *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_TILE_TERRAIN;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_TILE_TERRAIN);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_tile_terrain_100: sending info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_tile_terrain_100, cmp_packet_edit_tile_terrain_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->terrain != real_packet->terrain);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'terrain' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);

#endif
  SEND_PACKET_END(PACKET_EDIT_TILE_TERRAIN);
}

int send_packet_edit_tile_terrain(struct connection *pc, const struct packet_edit_tile_terrain *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_TILE_TERRAIN].packet != NULL, -1,
                        "Handler for PACKET_EDIT_TILE_TERRAIN not installed");
  return pc->phs.handlers->send[PACKET_EDIT_TILE_TERRAIN].packet(pc, packet);
}

int dsend_packet_edit_tile_terrain(struct connection *pc, int tile, Terrain_type_id terrain, int size)
{
  struct packet_edit_tile_terrain packet, *real_packet = &packet;

  real_packet->tile = tile;
  real_packet->terrain = terrain;
  real_packet->size = size;
  
  return send_packet_edit_tile_terrain(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_edit_tile_extra_100(const void *vkey)
{
  const struct packet_edit_tile_extra *key = (const struct packet_edit_tile_extra *) vkey;

  return key->tile;
}

static bool cmp_packet_edit_tile_extra_100(const void *vkey1, const void *vkey2)
{
  const struct packet_edit_tile_extra *key1 = (const struct packet_edit_tile_extra *) vkey1;
  const struct packet_edit_tile_extra *key2 = (const struct packet_edit_tile_extra *) vkey2;

  return key1->tile == key2->tile;
}
BV_DEFINE(packet_edit_tile_extra_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_tile_extra *receive_packet_edit_tile_extra_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_tile_extra_100_fields fields;
  struct packet_edit_tile_extra *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_TILE_EXTRA;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_tile_extra, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extra_type_id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint8, &din, &field_addr, &real_packet->extra_type_id)) {
    RECEIVE_PACKET_FIELD_ERROR(extra_type_id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->removal)) {
    RECEIVE_PACKET_FIELD_ERROR(removal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "eowner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->eowner)) {
    RECEIVE_PACKET_FIELD_ERROR(eowner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }

#endif
  log_packet_detailed("packet_edit_tile_extra_100: got info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_tile_extra_100, cmp_packet_edit_tile_extra_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int tile = real_packet->tile;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->tile = tile;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'extra_type_id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "extra_type_id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint8, &din, &field_addr, &real_packet->extra_type_id)) {
      RECEIVE_PACKET_FIELD_ERROR(extra_type_id);
    }
  }
  real_packet->removal = BV_ISSET(fields, 1);
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'eowner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "eowner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->eowner)) {
      RECEIVE_PACKET_FIELD_ERROR(eowner);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_tile_extra_100(struct connection *pc, const struct packet_edit_tile_extra *packet)
{
  const struct packet_edit_tile_extra *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_tile_extra_100_fields fields;
  struct packet_edit_tile_extra *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_TILE_EXTRA;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_TILE_EXTRA);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_tile_extra_100: sending info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_tile_extra_100, cmp_packet_edit_tile_extra_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->extra_type_id != real_packet->extra_type_id);
  if (differ) {
    BV_SET(fields, 0);
  }

  if (packet->removal) {
    BV_SET(fields, 1);
  }

  differ = (old->eowner != real_packet->eowner);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'extra_type_id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extra_type_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->extra_type_id);
  }
  /* field 1 is folded into the header */
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'eowner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "eowner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->eowner);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extra_type_id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->extra_type_id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->removal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "eowner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->eowner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);

#endif
  SEND_PACKET_END(PACKET_EDIT_TILE_EXTRA);
}

int send_packet_edit_tile_extra(struct connection *pc, const struct packet_edit_tile_extra *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_TILE_EXTRA].packet != NULL, -1,
                        "Handler for PACKET_EDIT_TILE_EXTRA not installed");
  return pc->phs.handlers->send[PACKET_EDIT_TILE_EXTRA].packet(pc, packet);
}

int dsend_packet_edit_tile_extra(struct connection *pc, int tile, int extra_type_id, bool removal, int eowner, int size)
{
  struct packet_edit_tile_extra packet, *real_packet = &packet;

  real_packet->tile = tile;
  real_packet->extra_type_id = extra_type_id;
  real_packet->removal = removal;
  real_packet->eowner = eowner;
  real_packet->size = size;
  
  return send_packet_edit_tile_extra(pc, real_packet);
}

static struct packet_edit_startpos *receive_packet_edit_startpos_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_edit_startpos, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */
#if 1 /* To match endif */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->removal)) {
    RECEIVE_PACKET_FIELD_ERROR(removal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tag)) {
    RECEIVE_PACKET_FIELD_ERROR(tag);
  }

#endif
  log_packet_detailed("packet_edit_startpos_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_startpos_100(struct connection *pc, const struct packet_edit_startpos *packet)
{
  const struct packet_edit_startpos *real_packet = packet;
  SEND_PACKET_START(PACKET_EDIT_STARTPOS);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_startpos_100: sending info about ()");
#if 1 /* To match endif */
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "removal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->removal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tag);

#endif
  SEND_PACKET_END(PACKET_EDIT_STARTPOS);
}

int send_packet_edit_startpos(struct connection *pc, const struct packet_edit_startpos *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_STARTPOS].packet != NULL, -1,
                        "Handler for PACKET_EDIT_STARTPOS not installed");
  return pc->phs.handlers->send[PACKET_EDIT_STARTPOS].packet(pc, packet);
}

int dsend_packet_edit_startpos(struct connection *pc, int id, bool removal, int tag)
{
  struct packet_edit_startpos packet, *real_packet = &packet;

  real_packet->id = id;
  real_packet->removal = removal;
  real_packet->tag = tag;
  
  return send_packet_edit_startpos(pc, real_packet);
}

static struct packet_edit_startpos_full *receive_packet_edit_startpos_full_100(struct connection *pc)
{
  RECEIVE_PACKET_START(packet_edit_startpos_full, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */
#if 1 /* To match endif */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "exclude";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->exclude)) {
    RECEIVE_PACKET_FIELD_ERROR(exclude);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nations";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->nations)) {
    RECEIVE_PACKET_FIELD_ERROR(nations);
  }

#endif
  log_packet_detailed("packet_edit_startpos_full_100: got info about ()");
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_startpos_full_100(struct connection *pc, const struct packet_edit_startpos_full *packet)
{
  const struct packet_edit_startpos_full *real_packet = packet;
  SEND_PACKET_START(PACKET_EDIT_STARTPOS_FULL);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_startpos_full_100: sending info about ()");
#if 1 /* To match endif */
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "exclude";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->exclude);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nations";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->nations);

#endif
  SEND_PACKET_END(PACKET_EDIT_STARTPOS_FULL);
}

int send_packet_edit_startpos_full(struct connection *pc, const struct packet_edit_startpos_full *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_STARTPOS_FULL].packet != NULL, -1,
                        "Handler for PACKET_EDIT_STARTPOS_FULL not installed");
  return pc->phs.handlers->send[PACKET_EDIT_STARTPOS_FULL].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_edit_tile_100(const void *vkey)
{
  const struct packet_edit_tile *key = (const struct packet_edit_tile *) vkey;

  return key->tile;
}

static bool cmp_packet_edit_tile_100(const void *vkey1, const void *vkey2)
{
  const struct packet_edit_tile *key1 = (const struct packet_edit_tile *) vkey1;
  const struct packet_edit_tile *key2 = (const struct packet_edit_tile *) vkey2;

  return key1->tile == key2->tile;
}
BV_DEFINE(packet_edit_tile_100_fields, 6);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_tile *receive_packet_edit_tile_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_tile_100_fields fields;
  struct packet_edit_tile *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_TILE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_tile, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->extras)) {
    RECEIVE_PACKET_FIELD_ERROR(extras);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resource";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(resource);
    }
    real_packet->resource = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(terrain);
    }
    real_packet->terrain = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "startpos_nation";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(startpos_nation);
    }
    real_packet->startpos_nation = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "eowner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->eowner)) {
    RECEIVE_PACKET_FIELD_ERROR(eowner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "label";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->label, sizeof(real_packet->label))) {
    RECEIVE_PACKET_FIELD_ERROR(label);
  }

#endif
  log_packet_detailed("packet_edit_tile_100: got info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_tile_100, cmp_packet_edit_tile_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int tile = real_packet->tile;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->tile = tile;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'extras'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "extras";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->extras)) {
      RECEIVE_PACKET_FIELD_ERROR(extras);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'resource'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "resource";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(resource);
      }
      real_packet->resource = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'terrain'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "terrain";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(terrain);
      }
      real_packet->terrain = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'startpos_nation'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "startpos_nation";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(startpos_nation);
      }
      real_packet->startpos_nation = readin;
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'eowner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "eowner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->eowner)) {
      RECEIVE_PACKET_FIELD_ERROR(eowner);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'label'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "label";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->label, sizeof(real_packet->label))) {
      RECEIVE_PACKET_FIELD_ERROR(label);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_tile_100(struct connection *pc, const struct packet_edit_tile *packet)
{
  const struct packet_edit_tile *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_tile_100_fields fields;
  struct packet_edit_tile *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_TILE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_TILE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_tile_100: sending info about (%d)",
    real_packet->tile);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_tile_100, cmp_packet_edit_tile_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = !BV_ARE_EQUAL(old->extras, real_packet->extras);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->resource != real_packet->resource);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->terrain != real_packet->terrain);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->startpos_nation != real_packet->startpos_nation);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->eowner != real_packet->eowner);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (strcmp(old->label, real_packet->label) != 0);
  if (differ) {
    BV_SET(fields, 5);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'extras' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->extras);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'resource' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resource";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->resource);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'terrain' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'startpos_nation' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "startpos_nation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->startpos_nation);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'eowner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "eowner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->eowner);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'label' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->label);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "extras";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->extras);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "resource";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->resource);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "terrain";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->terrain);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "startpos_nation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->startpos_nation);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "eowner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->eowner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "label";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->label);

#endif
  SEND_PACKET_END(PACKET_EDIT_TILE);
}

int send_packet_edit_tile(struct connection *pc, const struct packet_edit_tile *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_TILE].packet != NULL, -1,
                        "Handler for PACKET_EDIT_TILE not installed");
  return pc->phs.handlers->send[PACKET_EDIT_TILE].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_unit_create_100 hash_const

#define cmp_packet_edit_unit_create_100 cmp_const

BV_DEFINE(packet_edit_unit_create_100_fields, 5);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_unit_create *receive_packet_edit_unit_create_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_create_100_fields fields;
  struct packet_edit_unit_create *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_UNIT_CREATE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_unit_create, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->count)) {
    RECEIVE_PACKET_FIELD_ERROR(count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tag)) {
    RECEIVE_PACKET_FIELD_ERROR(tag);
  }

#endif
  log_packet_detailed("packet_edit_unit_create_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_create_100, cmp_packet_edit_unit_create_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->count)) {
      RECEIVE_PACKET_FIELD_ERROR(count);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'tag'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tag";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tag)) {
      RECEIVE_PACKET_FIELD_ERROR(tag);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_unit_create_100(struct connection *pc, const struct packet_edit_unit_create *packet)
{
  const struct packet_edit_unit_create *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_create_100_fields fields;
  struct packet_edit_unit_create *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_UNIT_CREATE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_UNIT_CREATE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_unit_create_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_create_100, cmp_packet_edit_unit_create_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->owner != real_packet->owner);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->count != real_packet->count);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->tag != real_packet->tag);
  if (differ) {
    BV_SET(fields, 4);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->count);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'tag' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tag);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tag);

#endif
  SEND_PACKET_END(PACKET_EDIT_UNIT_CREATE);
}

int send_packet_edit_unit_create(struct connection *pc, const struct packet_edit_unit_create *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_UNIT_CREATE].packet != NULL, -1,
                        "Handler for PACKET_EDIT_UNIT_CREATE not installed");
  return pc->phs.handlers->send[PACKET_EDIT_UNIT_CREATE].packet(pc, packet);
}

int dsend_packet_edit_unit_create(struct connection *pc, int owner, int tile, Unit_type_id type, int count, int tag)
{
  struct packet_edit_unit_create packet, *real_packet = &packet;

  real_packet->owner = owner;
  real_packet->tile = tile;
  real_packet->type = type;
  real_packet->count = count;
  real_packet->tag = tag;
  
  return send_packet_edit_unit_create(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_unit_remove_100 hash_const

#define cmp_packet_edit_unit_remove_100 cmp_const

BV_DEFINE(packet_edit_unit_remove_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_unit_remove *receive_packet_edit_unit_remove_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_remove_100_fields fields;
  struct packet_edit_unit_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_UNIT_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_unit_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(type);
    }
    real_packet->type = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->count)) {
    RECEIVE_PACKET_FIELD_ERROR(count);
  }

#endif
  log_packet_detailed("packet_edit_unit_remove_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_remove_100, cmp_packet_edit_unit_remove_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'type'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "type";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(type);
      }
      real_packet->type = readin;
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->count)) {
      RECEIVE_PACKET_FIELD_ERROR(count);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_unit_remove_100(struct connection *pc, const struct packet_edit_unit_remove *packet)
{
  const struct packet_edit_unit_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_remove_100_fields fields;
  struct packet_edit_unit_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_UNIT_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_UNIT_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_unit_remove_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_remove_100, cmp_packet_edit_unit_remove_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->owner != real_packet->owner);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->type != real_packet->type);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->count != real_packet->count);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'type' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->count);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "type";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->type);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->count);

#endif
  SEND_PACKET_END(PACKET_EDIT_UNIT_REMOVE);
}

int send_packet_edit_unit_remove(struct connection *pc, const struct packet_edit_unit_remove *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_UNIT_REMOVE].packet != NULL, -1,
                        "Handler for PACKET_EDIT_UNIT_REMOVE not installed");
  return pc->phs.handlers->send[PACKET_EDIT_UNIT_REMOVE].packet(pc, packet);
}

int dsend_packet_edit_unit_remove(struct connection *pc, int owner, int tile, Unit_type_id type, int count)
{
  struct packet_edit_unit_remove packet, *real_packet = &packet;

  real_packet->owner = owner;
  real_packet->tile = tile;
  real_packet->type = type;
  real_packet->count = count;
  
  return send_packet_edit_unit_remove(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_unit_remove_by_id_100 hash_const

#define cmp_packet_edit_unit_remove_by_id_100 cmp_const

BV_DEFINE(packet_edit_unit_remove_by_id_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_unit_remove_by_id *receive_packet_edit_unit_remove_by_id_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_remove_by_id_100_fields fields;
  struct packet_edit_unit_remove_by_id *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_UNIT_REMOVE_BY_ID;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_unit_remove_by_id, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }

#endif
  log_packet_detailed("packet_edit_unit_remove_by_id_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_remove_by_id_100, cmp_packet_edit_unit_remove_by_id_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_unit_remove_by_id_100(struct connection *pc, const struct packet_edit_unit_remove_by_id *packet)
{
  const struct packet_edit_unit_remove_by_id *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_remove_by_id_100_fields fields;
  struct packet_edit_unit_remove_by_id *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_UNIT_REMOVE_BY_ID;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_UNIT_REMOVE_BY_ID);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_unit_remove_by_id_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_remove_by_id_100, cmp_packet_edit_unit_remove_by_id_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);

#endif
  SEND_PACKET_END(PACKET_EDIT_UNIT_REMOVE_BY_ID);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_unit_remove_by_id_101 hash_const

#define cmp_packet_edit_unit_remove_by_id_101 cmp_const

BV_DEFINE(packet_edit_unit_remove_by_id_101_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_unit_remove_by_id *receive_packet_edit_unit_remove_by_id_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_remove_by_id_101_fields fields;
  struct packet_edit_unit_remove_by_id *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_UNIT_REMOVE_BY_ID;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_unit_remove_by_id, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#endif
  log_packet_detailed("packet_edit_unit_remove_by_id_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_remove_by_id_101, cmp_packet_edit_unit_remove_by_id_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
      RECEIVE_PACKET_FIELD_ERROR(id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_unit_remove_by_id_101(struct connection *pc, const struct packet_edit_unit_remove_by_id *packet)
{
  const struct packet_edit_unit_remove_by_id *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_remove_by_id_101_fields fields;
  struct packet_edit_unit_remove_by_id *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_UNIT_REMOVE_BY_ID;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_UNIT_REMOVE_BY_ID);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_unit_remove_by_id_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_remove_by_id_101, cmp_packet_edit_unit_remove_by_id_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id16 != real_packet->id16);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

#endif
  SEND_PACKET_END(PACKET_EDIT_UNIT_REMOVE_BY_ID);
}

int send_packet_edit_unit_remove_by_id(struct connection *pc, const struct packet_edit_unit_remove_by_id *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_UNIT_REMOVE_BY_ID].packet != NULL, -1,
                        "Handler for PACKET_EDIT_UNIT_REMOVE_BY_ID not installed");
  return pc->phs.handlers->send[PACKET_EDIT_UNIT_REMOVE_BY_ID].packet(pc, packet);
}

int dsend_packet_edit_unit_remove_by_id(struct connection *pc, int id16, int id32)
{
  struct packet_edit_unit_remove_by_id packet, *real_packet = &packet;

  real_packet->id16 = id16;
  real_packet->id32 = id32;
  
  return send_packet_edit_unit_remove_by_id(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_unit_100 hash_const

#define cmp_packet_edit_unit_100 cmp_const

BV_DEFINE(packet_edit_unit_100_fields, 17);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_unit *receive_packet_edit_unit_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_100_fields fields;
  struct packet_edit_unit *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_UNIT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_unit, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "utype";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(utype);
    }
    real_packet->utype = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->homecity32)) {
    RECEIVE_PACKET_FIELD_ERROR(homecity32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moves_left";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->moves_left)) {
    RECEIVE_PACKET_FIELD_ERROR(moves_left);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
    RECEIVE_PACKET_FIELD_ERROR(hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
    RECEIVE_PACKET_FIELD_ERROR(fuel);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
    real_packet->activity = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->activity_count)) {
    RECEIVE_PACKET_FIELD_ERROR(activity_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_base";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_base);
    }
    real_packet->activity_base = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "debug";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->debug)) {
    RECEIVE_PACKET_FIELD_ERROR(debug);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moved";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->moved)) {
    RECEIVE_PACKET_FIELD_ERROR(moved);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paradropped";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->paradropped)) {
    RECEIVE_PACKET_FIELD_ERROR(paradropped);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "done_moving";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->done_moving)) {
    RECEIVE_PACKET_FIELD_ERROR(done_moving);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->transported_by32)) {
    RECEIVE_PACKET_FIELD_ERROR(transported_by32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stay";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->stay)) {
    RECEIVE_PACKET_FIELD_ERROR(stay);
  }

#endif
  log_packet_detailed("packet_edit_unit_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_100, cmp_packet_edit_unit_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'utype'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "utype";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(utype);
      }
      real_packet->utype = readin;
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'homecity32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "homecity32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->homecity32)) {
      RECEIVE_PACKET_FIELD_ERROR(homecity32);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'moves_left'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "moves_left";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->moves_left)) {
      RECEIVE_PACKET_FIELD_ERROR(moves_left);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
      RECEIVE_PACKET_FIELD_ERROR(hp);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'veteran'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
      RECEIVE_PACKET_FIELD_ERROR(veteran);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'fuel'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "fuel";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
      RECEIVE_PACKET_FIELD_ERROR(fuel);
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity);
      }
      real_packet->activity = readin;
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'activity_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->activity_count)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_count);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'activity_base'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_base";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity_base);
      }
      real_packet->activity_base = readin;
    }
  }
  real_packet->debug = BV_ISSET(fields, 11);
  real_packet->moved = BV_ISSET(fields, 12);
  real_packet->paradropped = BV_ISSET(fields, 13);
  real_packet->done_moving = BV_ISSET(fields, 14);
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'transported_by32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "transported_by32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->transported_by32)) {
      RECEIVE_PACKET_FIELD_ERROR(transported_by32);
    }
  }
  real_packet->stay = BV_ISSET(fields, 16);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_unit_100(struct connection *pc, const struct packet_edit_unit *packet)
{
  const struct packet_edit_unit *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_100_fields fields;
  struct packet_edit_unit *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_UNIT;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_UNIT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_unit_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_100, cmp_packet_edit_unit_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->utype != real_packet->utype);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->homecity32 != real_packet->homecity32);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->moves_left != real_packet->moves_left);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->hp != real_packet->hp);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->veteran != real_packet->veteran);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->fuel != real_packet->fuel);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (old->activity_count != real_packet->activity_count);
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (old->activity_base != real_packet->activity_base);
  if (differ) {
    BV_SET(fields, 10);
  }

  if (packet->debug) {
    BV_SET(fields, 11);
  }

  if (packet->moved) {
    BV_SET(fields, 12);
  }

  if (packet->paradropped) {
    BV_SET(fields, 13);
  }

  if (packet->done_moving) {
    BV_SET(fields, 14);
  }

  differ = (old->transported_by32 != real_packet->transported_by32);
  if (differ) {
    BV_SET(fields, 15);
  }

  if (packet->stay) {
    BV_SET(fields, 16);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'utype' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "utype";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->utype);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'homecity32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->homecity32);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'moves_left' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moves_left";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->moves_left);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'veteran' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'fuel' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'activity_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->activity_count);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'activity_base' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_base";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_base);
  }
  /* field 11 is folded into the header */
  /* field 12 is folded into the header */
  /* field 13 is folded into the header */
  /* field 14 is folded into the header */
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'transported_by32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->transported_by32);
  }
  /* field 16 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "utype";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->utype);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->homecity32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moves_left";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->moves_left);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->activity_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_base";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_base);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "debug";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->debug);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moved";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->moved);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paradropped";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->paradropped);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "done_moving";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->done_moving);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->transported_by32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stay";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->stay);

#endif
  SEND_PACKET_END(PACKET_EDIT_UNIT);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_edit_unit_101(const void *vkey)
{
  const struct packet_edit_unit *key = (const struct packet_edit_unit *) vkey;

  return key->id16;
}

static bool cmp_packet_edit_unit_101(const void *vkey1, const void *vkey2)
{
  const struct packet_edit_unit *key1 = (const struct packet_edit_unit *) vkey1;
  const struct packet_edit_unit *key2 = (const struct packet_edit_unit *) vkey2;

  return key1->id16 == key2->id16;
}
BV_DEFINE(packet_edit_unit_101_fields, 16);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_unit *receive_packet_edit_unit_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_101_fields fields;
  struct packet_edit_unit *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_UNIT;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_unit, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "utype";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(utype);
    }
    real_packet->utype = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->homecity16)) {
    RECEIVE_PACKET_FIELD_ERROR(homecity16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moves_left";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->moves_left)) {
    RECEIVE_PACKET_FIELD_ERROR(moves_left);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
    RECEIVE_PACKET_FIELD_ERROR(hp);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
    RECEIVE_PACKET_FIELD_ERROR(veteran);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
    RECEIVE_PACKET_FIELD_ERROR(fuel);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity);
    }
    real_packet->activity = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->activity_count)) {
    RECEIVE_PACKET_FIELD_ERROR(activity_count);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_base";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_base);
    }
    real_packet->activity_base = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "debug";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->debug)) {
    RECEIVE_PACKET_FIELD_ERROR(debug);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moved";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->moved)) {
    RECEIVE_PACKET_FIELD_ERROR(moved);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paradropped";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->paradropped)) {
    RECEIVE_PACKET_FIELD_ERROR(paradropped);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "done_moving";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->done_moving)) {
    RECEIVE_PACKET_FIELD_ERROR(done_moving);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->transported_by16)) {
    RECEIVE_PACKET_FIELD_ERROR(transported_by16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stay";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->stay)) {
    RECEIVE_PACKET_FIELD_ERROR(stay);
  }

#endif
  log_packet_detailed("packet_edit_unit_101: got info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_101, cmp_packet_edit_unit_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id16 = real_packet->id16;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id16 = id16;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'utype'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "utype";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(utype);
      }
      real_packet->utype = readin;
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'homecity16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "homecity16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->homecity16)) {
      RECEIVE_PACKET_FIELD_ERROR(homecity16);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'moves_left'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "moves_left";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->moves_left)) {
      RECEIVE_PACKET_FIELD_ERROR(moves_left);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'hp'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "hp";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->hp)) {
      RECEIVE_PACKET_FIELD_ERROR(hp);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'veteran'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "veteran";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->veteran)) {
      RECEIVE_PACKET_FIELD_ERROR(veteran);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'fuel'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "fuel";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->fuel)) {
      RECEIVE_PACKET_FIELD_ERROR(fuel);
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'activity'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity);
      }
      real_packet->activity = readin;
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'activity_count'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_count";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->activity_count)) {
      RECEIVE_PACKET_FIELD_ERROR(activity_count);
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'activity_base'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "activity_base";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(activity_base);
      }
      real_packet->activity_base = readin;
    }
  }
  real_packet->debug = BV_ISSET(fields, 10);
  real_packet->moved = BV_ISSET(fields, 11);
  real_packet->paradropped = BV_ISSET(fields, 12);
  real_packet->done_moving = BV_ISSET(fields, 13);
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'transported_by16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "transported_by16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->transported_by16)) {
      RECEIVE_PACKET_FIELD_ERROR(transported_by16);
    }
  }
  real_packet->stay = BV_ISSET(fields, 15);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_unit_101(struct connection *pc, const struct packet_edit_unit *packet)
{
  const struct packet_edit_unit *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_unit_101_fields fields;
  struct packet_edit_unit *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_UNIT;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_UNIT);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_unit_101: sending info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_unit_101, cmp_packet_edit_unit_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->utype != real_packet->utype);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->homecity16 != real_packet->homecity16);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->moves_left != real_packet->moves_left);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->hp != real_packet->hp);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->veteran != real_packet->veteran);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->fuel != real_packet->fuel);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->activity != real_packet->activity);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->activity_count != real_packet->activity_count);
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (old->activity_base != real_packet->activity_base);
  if (differ) {
    BV_SET(fields, 9);
  }

  if (packet->debug) {
    BV_SET(fields, 10);
  }

  if (packet->moved) {
    BV_SET(fields, 11);
  }

  if (packet->paradropped) {
    BV_SET(fields, 12);
  }

  if (packet->done_moving) {
    BV_SET(fields, 13);
  }

  differ = (old->transported_by16 != real_packet->transported_by16);
  if (differ) {
    BV_SET(fields, 14);
  }

  if (packet->stay) {
    BV_SET(fields, 15);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'utype' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "utype";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->utype);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'homecity16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->homecity16);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'moves_left' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moves_left";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->moves_left);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'hp' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'veteran' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'fuel' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'activity' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'activity_count' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->activity_count);
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'activity_base' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_base";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_base);
  }
  /* field 10 is folded into the header */
  /* field 11 is folded into the header */
  /* field 12 is folded into the header */
  /* field 13 is folded into the header */
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'transported_by16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->transported_by16);
  }
  /* field 15 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "utype";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->utype);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "homecity16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->homecity16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moves_left";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->moves_left);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "hp";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->hp);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "veteran";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->veteran);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fuel";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->fuel);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->activity);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_count";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->activity_count);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "activity_base";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->activity_base);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "debug";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->debug);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "moved";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->moved);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "paradropped";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->paradropped);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "done_moving";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->done_moving);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "transported_by16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->transported_by16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "stay";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->stay);

#endif
  SEND_PACKET_END(PACKET_EDIT_UNIT);
}

int send_packet_edit_unit(struct connection *pc, const struct packet_edit_unit *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_UNIT].packet != NULL, -1,
                        "Handler for PACKET_EDIT_UNIT not installed");
  return pc->phs.handlers->send[PACKET_EDIT_UNIT].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_city_create_100 hash_const

#define cmp_packet_edit_city_create_100 cmp_const

BV_DEFINE(packet_edit_city_create_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_city_create *receive_packet_edit_city_create_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_create_100_fields fields;
  struct packet_edit_city_create *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_CITY_CREATE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_city_create, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tag)) {
    RECEIVE_PACKET_FIELD_ERROR(tag);
  }

#endif
  log_packet_detailed("packet_edit_city_create_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_create_100, cmp_packet_edit_city_create_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'tag'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tag";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tag)) {
      RECEIVE_PACKET_FIELD_ERROR(tag);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_city_create_100(struct connection *pc, const struct packet_edit_city_create *packet)
{
  const struct packet_edit_city_create *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_create_100_fields fields;
  struct packet_edit_city_create *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_CITY_CREATE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_CITY_CREATE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_city_create_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_create_100, cmp_packet_edit_city_create_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->owner != real_packet->owner);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->tag != real_packet->tag);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'tag' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tag);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tag);

#endif
  SEND_PACKET_END(PACKET_EDIT_CITY_CREATE);
}

int send_packet_edit_city_create(struct connection *pc, const struct packet_edit_city_create *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_CITY_CREATE].packet != NULL, -1,
                        "Handler for PACKET_EDIT_CITY_CREATE not installed");
  return pc->phs.handlers->send[PACKET_EDIT_CITY_CREATE].packet(pc, packet);
}

int dsend_packet_edit_city_create(struct connection *pc, int owner, int tile, int size, int tag)
{
  struct packet_edit_city_create packet, *real_packet = &packet;

  real_packet->owner = owner;
  real_packet->tile = tile;
  real_packet->size = size;
  real_packet->tag = tag;
  
  return send_packet_edit_city_create(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_city_remove_100 hash_const

#define cmp_packet_edit_city_remove_100 cmp_const

BV_DEFINE(packet_edit_city_remove_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_city_remove *receive_packet_edit_city_remove_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_remove_100_fields fields;
  struct packet_edit_city_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_CITY_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_city_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }

#endif
  log_packet_detailed("packet_edit_city_remove_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_remove_100, cmp_packet_edit_city_remove_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_city_remove_100(struct connection *pc, const struct packet_edit_city_remove *packet)
{
  const struct packet_edit_city_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_remove_100_fields fields;
  struct packet_edit_city_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_CITY_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_CITY_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_city_remove_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_remove_100, cmp_packet_edit_city_remove_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);

#endif
  SEND_PACKET_END(PACKET_EDIT_CITY_REMOVE);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_city_remove_101 hash_const

#define cmp_packet_edit_city_remove_101 cmp_const

BV_DEFINE(packet_edit_city_remove_101_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_city_remove *receive_packet_edit_city_remove_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_remove_101_fields fields;
  struct packet_edit_city_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_CITY_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_city_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#endif
  log_packet_detailed("packet_edit_city_remove_101: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_remove_101, cmp_packet_edit_city_remove_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id16'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id16";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
      RECEIVE_PACKET_FIELD_ERROR(id16);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_city_remove_101(struct connection *pc, const struct packet_edit_city_remove *packet)
{
  const struct packet_edit_city_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_remove_101_fields fields;
  struct packet_edit_city_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_CITY_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_CITY_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_city_remove_101: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_remove_101, cmp_packet_edit_city_remove_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id16 != real_packet->id16);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id16' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

#endif
  SEND_PACKET_END(PACKET_EDIT_CITY_REMOVE);
}

int send_packet_edit_city_remove(struct connection *pc, const struct packet_edit_city_remove *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_CITY_REMOVE].packet != NULL, -1,
                        "Handler for PACKET_EDIT_CITY_REMOVE not installed");
  return pc->phs.handlers->send[PACKET_EDIT_CITY_REMOVE].packet(pc, packet);
}

int dsend_packet_edit_city_remove(struct connection *pc, int id16, int id32)
{
  struct packet_edit_city_remove packet, *real_packet = &packet;

  real_packet->id16 = id16;
  real_packet->id32 = id32;
  
  return send_packet_edit_city_remove(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_city_100 hash_const

#define cmp_packet_edit_city_100 cmp_const

BV_DEFINE(packet_edit_city_100_fields, 28);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_city *receive_packet_edit_city_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_100_fields fields;
  struct packet_edit_city *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_CITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_city, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->original)) {
    RECEIVE_PACKET_FIELD_ERROR(original);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
    RECEIVE_PACKET_FIELD_ERROR(history);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < 5; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < 5; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_content);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < 5; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < 5; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
    RECEIVE_PACKET_FIELD_ERROR(specialists_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->specialists_size > SP_MAX) {
      RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
    }
    for (i = 0; i < real_packet->specialists_size; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
        RECEIVE_PACKET_FIELD_ERROR(specialists);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->food_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(food_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(shield_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->airlift)) {
    RECEIVE_PACKET_FIELD_ERROR(airlift);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "debug";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->debug)) {
    RECEIVE_PACKET_FIELD_ERROR(debug);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_buy)) {
    RECEIVE_PACKET_FIELD_ERROR(did_buy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_sell)) {
    RECEIVE_PACKET_FIELD_ERROR(did_sell);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->was_happy)) {
    RECEIVE_PACKET_FIELD_ERROR(was_happy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "anarchy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->anarchy)) {
    RECEIVE_PACKET_FIELD_ERROR(anarchy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rapture";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->rapture)) {
    RECEIVE_PACKET_FIELD_ERROR(rapture);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->steal)) {
    RECEIVE_PACKET_FIELD_ERROR(steal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_founded);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "built";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
    for (i = 0; i < B_LAST; i++) {
      if (!DIO_GET(sint32, &din, &field_addr, &real_packet->built[i])) {
        RECEIVE_PACKET_FIELD_ERROR(built);
      }
    }
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(production_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
    RECEIVE_PACKET_FIELD_ERROR(production_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
    RECEIVE_PACKET_FIELD_ERROR(city_options);
  }

#endif
  log_packet_detailed("packet_edit_city_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_100, cmp_packet_edit_city_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'original'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "original";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->original)) {
      RECEIVE_PACKET_FIELD_ERROR(original);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'history'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "history";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
      RECEIVE_PACKET_FIELD_ERROR(history);
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'ppl_happy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_happy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < 5; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'ppl_content'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_content";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < 5; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_content);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'ppl_unhappy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_unhappy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < 5; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'ppl_angry'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_angry";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < 5; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'specialists_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
      RECEIVE_PACKET_FIELD_ERROR(specialists_size);
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'specialists'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->specialists_size > SP_MAX) {
        RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
      }
      for (i = 0; i < real_packet->specialists_size; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
          RECEIVE_PACKET_FIELD_ERROR(specialists);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'food_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "food_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->food_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(food_stock);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'shield_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "shield_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(shield_stock);
    }
  }
  real_packet->airlift = BV_ISSET(fields, 14);
  real_packet->debug = BV_ISSET(fields, 15);
  real_packet->did_buy = BV_ISSET(fields, 16);
  real_packet->did_sell = BV_ISSET(fields, 17);
  real_packet->was_happy = BV_ISSET(fields, 18);
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'anarchy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "anarchy";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->anarchy)) {
      RECEIVE_PACKET_FIELD_ERROR(anarchy);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'rapture'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rapture";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->rapture)) {
      RECEIVE_PACKET_FIELD_ERROR(rapture);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'steal'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "steal";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->steal)) {
      RECEIVE_PACKET_FIELD_ERROR(steal);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'turn_founded'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_founded";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_founded);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'turn_last_built'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_last_built";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'built'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "built";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
    #ifdef FREECIV_JSON_CONNECTION
    int count;
    
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
    
    for (count = 0;; count++) {
      int i;
    
      field_addr.sub_location->number = count;
    
      /* Enter diff array element (start at the index address). */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
    #else /* FREECIV_JSON_CONNECTION */
    while (TRUE) {
      int i;
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (!DIO_GET(uint8, &din, &field_addr, &i)) {
        RECEIVE_PACKET_FIELD_ERROR(built);
      }
      if (i == 255) {
    #ifdef FREECIV_JSON_CONNECTION
        /* Exit diff array element. */
        free(field_addr.sub_location->sub_location);
        field_addr.sub_location->sub_location = NULL;
    
        /* Exit diff array. */
        free(field_addr.sub_location);
        field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    
        break;
      }
      if (i > B_LAST) {
        RECEIVE_PACKET_FIELD_ERROR(built,
                                   ": unexpected value %d "
                                   "(> B_LAST) in array diff",
                                   i);
      } else {
    #ifdef FREECIV_JSON_CONNECTION
        /* Content address. */
        field_addr.sub_location->sub_location->number = 1;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint32, &din, &field_addr, &real_packet->built[i])) {
          RECEIVE_PACKET_FIELD_ERROR(built);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
    
    #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'production_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(production_kind);
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'production_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
      RECEIVE_PACKET_FIELD_ERROR(production_value);
    }
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  got field 'city_options'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_options";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
      RECEIVE_PACKET_FIELD_ERROR(city_options);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_city_100(struct connection *pc, const struct packet_edit_city *packet)
{
  const struct packet_edit_city *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_100_fields fields;
  struct packet_edit_city *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_CITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_CITY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_city_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_100, cmp_packet_edit_city_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->original != real_packet->original);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    BV_SET(fields, 4);
  }

  differ = (old->history != real_packet->history);
  if (differ) {
    BV_SET(fields, 5);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < 5; i++) {
          if (old->ppl_happy[i] != real_packet->ppl_happy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 6);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < 5; i++) {
          if (old->ppl_content[i] != real_packet->ppl_content[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 7);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < 5; i++) {
          if (old->ppl_unhappy[i] != real_packet->ppl_unhappy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 8);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < 5; i++) {
          if (old->ppl_angry[i] != real_packet->ppl_angry[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 9);
  }

  differ = (old->specialists_size != real_packet->specialists_size);
  if (differ) {
    BV_SET(fields, 10);
  }


    {
      differ = (old->specialists_size != real_packet->specialists_size);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->specialists_size; i++) {
          if (old->specialists[i] != real_packet->specialists[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (old->food_stock != real_packet->food_stock);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = (old->shield_stock != real_packet->shield_stock);
  if (differ) {
    BV_SET(fields, 13);
  }

  if (packet->airlift) {
    BV_SET(fields, 14);
  }

  if (packet->debug) {
    BV_SET(fields, 15);
  }

  if (packet->did_buy) {
    BV_SET(fields, 16);
  }

  if (packet->did_sell) {
    BV_SET(fields, 17);
  }

  if (packet->was_happy) {
    BV_SET(fields, 18);
  }

  differ = (old->anarchy != real_packet->anarchy);
  if (differ) {
    BV_SET(fields, 19);
  }

  differ = (old->rapture != real_packet->rapture);
  if (differ) {
    BV_SET(fields, 20);
  }

  differ = (old->steal != real_packet->steal);
  if (differ) {
    BV_SET(fields, 21);
  }

  differ = (old->turn_founded != real_packet->turn_founded);
  if (differ) {
    BV_SET(fields, 22);
  }

  differ = (old->turn_last_built != real_packet->turn_last_built);
  if (differ) {
    BV_SET(fields, 23);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < B_LAST; i++) {
          if (old->built[i] != real_packet->built[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 24);
  }

  differ = (old->production_kind != real_packet->production_kind);
  if (differ) {
    BV_SET(fields, 25);
  }

  differ = (old->production_value != real_packet->production_value);
  if (differ) {
    BV_SET(fields, 26);
  }

  differ = !BV_ARE_EQUAL(old->city_options, real_packet->city_options);
  if (differ) {
    BV_SET(fields, 27);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'original' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->original);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'history' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'ppl_happy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'ppl_content' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'ppl_unhappy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'ppl_angry' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'specialists_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'specialists' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'food_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->food_stock);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'shield_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
  }
  /* field 14 is folded into the header */
  /* field 15 is folded into the header */
  /* field 16 is folded into the header */
  /* field 17 is folded into the header */
  /* field 18 is folded into the header */
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'anarchy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "anarchy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->anarchy);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'rapture' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rapture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->rapture);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'steal' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->steal);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'turn_founded' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'turn_last_built' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'built' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "built";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      int count = 0;

      for (i = 0; i < B_LAST; i++) {
        if (old->built[i] != real_packet->built[i]) {
          count++;
        }
      }
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, count + 1);

      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);

      count = 0;
#endif /* FREECIV_JSON_CONNECTION */

      fc_assert(B_LAST < 255);

      for (i = 0; i < B_LAST; i++) {
        if (old->built[i] != real_packet->built[i]) {
#ifdef FREECIV_JSON_CONNECTION
          /* Next diff array element. */
          field_addr.sub_location->number = count - 1;

          /* Create the diff array element. */
          DIO_PUT(farray, &dout, &field_addr, 2);

          /* Enter diff array element (start at the index address). */
          field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(uint8, &dout, &field_addr, i);

#ifdef FREECIV_JSON_CONNECTION
          /* Content address. */
          field_addr.sub_location->sub_location->number = 1;
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(sint32, &dout, &field_addr, real_packet->built[i]);

#ifdef FREECIV_JSON_CONNECTION
          /* Exit diff array element. */
          free(field_addr.sub_location->sub_location);
          field_addr.sub_location->sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
        }
      }
#ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = count - 1;

      /* Create the diff array element. */
      DIO_PUT(farray, &dout, &field_addr, B_LAST);

      /* Enter diff array element. Point to index address. */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
      DIO_PUT(uint8, &dout, &field_addr, 255);

#ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;

      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'production_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'production_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
  }
  if (BV_ISSET(fields, 27)) {
    log_packet_detailed("  field 'city_options' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->original);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->food_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->airlift);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "debug";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->debug);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_buy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_sell);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->was_happy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "anarchy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->anarchy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rapture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->rapture);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->steal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "built";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, B_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < B_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->built[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);

#endif
  SEND_PACKET_END(PACKET_EDIT_CITY);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_edit_city_101(const void *vkey)
{
  const struct packet_edit_city *key = (const struct packet_edit_city *) vkey;

  return key->id16;
}

static bool cmp_packet_edit_city_101(const void *vkey1, const void *vkey2)
{
  const struct packet_edit_city *key1 = (const struct packet_edit_city *) vkey1;
  const struct packet_edit_city *key2 = (const struct packet_edit_city *) vkey2;

  return key1->id16 == key2->id16;
}
BV_DEFINE(packet_edit_city_101_fields, 27);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_city *receive_packet_edit_city_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_101_fields fields;
  struct packet_edit_city *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_CITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_city, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
    RECEIVE_PACKET_FIELD_ERROR(owner);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->original)) {
    RECEIVE_PACKET_FIELD_ERROR(original);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
    RECEIVE_PACKET_FIELD_ERROR(history);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < 5; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < 5; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_content);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < 5; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    for (i = 0; i < 5; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
        RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
    RECEIVE_PACKET_FIELD_ERROR(specialists_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
  #endif /* FREECIV_JSON_CONNECTION */
  
    if (real_packet->specialists_size > SP_MAX) {
      RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
    }
    for (i = 0; i < real_packet->specialists_size; i++) {
  #ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = i;
  #endif /* FREECIV_JSON_CONNECTION */
      if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
        RECEIVE_PACKET_FIELD_ERROR(specialists);
      }
    }
  
  #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
  #endif /* FREECIV_JSON_CONNECTION */
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->food_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(food_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
    RECEIVE_PACKET_FIELD_ERROR(shield_stock);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->airlift)) {
    RECEIVE_PACKET_FIELD_ERROR(airlift);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "debug";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->debug)) {
    RECEIVE_PACKET_FIELD_ERROR(debug);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_buy)) {
    RECEIVE_PACKET_FIELD_ERROR(did_buy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->did_sell)) {
    RECEIVE_PACKET_FIELD_ERROR(did_sell);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->was_happy)) {
    RECEIVE_PACKET_FIELD_ERROR(was_happy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "anarchy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->anarchy)) {
    RECEIVE_PACKET_FIELD_ERROR(anarchy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rapture";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->rapture)) {
    RECEIVE_PACKET_FIELD_ERROR(rapture);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->steal)) {
    RECEIVE_PACKET_FIELD_ERROR(steal);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_founded);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
    RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "built";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
    for (i = 0; i < B_LAST; i++) {
      if (!DIO_GET(sint32, &din, &field_addr, &real_packet->built[i])) {
        RECEIVE_PACKET_FIELD_ERROR(built);
      }
    }
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
    RECEIVE_PACKET_FIELD_ERROR(production_kind);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
    RECEIVE_PACKET_FIELD_ERROR(production_value);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
    RECEIVE_PACKET_FIELD_ERROR(city_options);
  }

#endif
  log_packet_detailed("packet_edit_city_101: got info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_101, cmp_packet_edit_city_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id16 = real_packet->id16;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id16 = id16;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(estring, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'owner'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "owner";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->owner)) {
      RECEIVE_PACKET_FIELD_ERROR(owner);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'original'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "original";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->original)) {
      RECEIVE_PACKET_FIELD_ERROR(original);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  got field 'history'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "history";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->history)) {
      RECEIVE_PACKET_FIELD_ERROR(history);
    }
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'ppl_happy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_happy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < 5; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_happy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_happy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'ppl_content'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_content";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < 5; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_content[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_content);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'ppl_unhappy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_unhappy";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < 5; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_unhappy[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_unhappy);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'ppl_angry'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ppl_angry";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      for (i = 0; i < 5; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->ppl_angry[i])) {
          RECEIVE_PACKET_FIELD_ERROR(ppl_angry);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  got field 'specialists_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists_size)) {
      RECEIVE_PACKET_FIELD_ERROR(specialists_size);
    }
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'specialists'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "specialists";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
      int i;
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (real_packet->specialists_size > SP_MAX) {
        RECEIVE_PACKET_FIELD_ERROR(specialists, ": truncation array");
      }
      for (i = 0; i < real_packet->specialists_size; i++) {
    #ifdef FREECIV_JSON_CONNECTION
        field_addr.sub_location->number = i;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(uint8, &din, &field_addr, &real_packet->specialists[i])) {
          RECEIVE_PACKET_FIELD_ERROR(specialists);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  got field 'food_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "food_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->food_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(food_stock);
    }
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'shield_stock'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "shield_stock";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->shield_stock)) {
      RECEIVE_PACKET_FIELD_ERROR(shield_stock);
    }
  }
  real_packet->airlift = BV_ISSET(fields, 13);
  real_packet->debug = BV_ISSET(fields, 14);
  real_packet->did_buy = BV_ISSET(fields, 15);
  real_packet->did_sell = BV_ISSET(fields, 16);
  real_packet->was_happy = BV_ISSET(fields, 17);
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'anarchy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "anarchy";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->anarchy)) {
      RECEIVE_PACKET_FIELD_ERROR(anarchy);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'rapture'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "rapture";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->rapture)) {
      RECEIVE_PACKET_FIELD_ERROR(rapture);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'steal'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "steal";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->steal)) {
      RECEIVE_PACKET_FIELD_ERROR(steal);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'turn_founded'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_founded";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_founded)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_founded);
    }
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  got field 'turn_last_built'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "turn_last_built";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->turn_last_built)) {
      RECEIVE_PACKET_FIELD_ERROR(turn_last_built);
    }
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  got field 'built'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "built";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
    #ifdef FREECIV_JSON_CONNECTION
    int count;
    
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
    
    for (count = 0;; count++) {
      int i;
    
      field_addr.sub_location->number = count;
    
      /* Enter diff array element (start at the index address). */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
    #else /* FREECIV_JSON_CONNECTION */
    while (TRUE) {
      int i;
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (!DIO_GET(uint8, &din, &field_addr, &i)) {
        RECEIVE_PACKET_FIELD_ERROR(built);
      }
      if (i == 255) {
    #ifdef FREECIV_JSON_CONNECTION
        /* Exit diff array element. */
        free(field_addr.sub_location->sub_location);
        field_addr.sub_location->sub_location = NULL;
    
        /* Exit diff array. */
        free(field_addr.sub_location);
        field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    
        break;
      }
      if (i > B_LAST) {
        RECEIVE_PACKET_FIELD_ERROR(built,
                                   ": unexpected value %d "
                                   "(> B_LAST) in array diff",
                                   i);
      } else {
    #ifdef FREECIV_JSON_CONNECTION
        /* Content address. */
        field_addr.sub_location->sub_location->number = 1;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(sint32, &din, &field_addr, &real_packet->built[i])) {
          RECEIVE_PACKET_FIELD_ERROR(built);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
    
    #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  got field 'production_kind'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_kind";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_kind)) {
      RECEIVE_PACKET_FIELD_ERROR(production_kind);
    }
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  got field 'production_value'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "production_value";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->production_value)) {
      RECEIVE_PACKET_FIELD_ERROR(production_value);
    }
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  got field 'city_options'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "city_options";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->city_options)) {
      RECEIVE_PACKET_FIELD_ERROR(city_options);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_city_101(struct connection *pc, const struct packet_edit_city *packet)
{
  const struct packet_edit_city *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_city_101_fields fields;
  struct packet_edit_city *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_CITY;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_CITY);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_city_101: sending info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_city_101, cmp_packet_edit_city_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->owner != real_packet->owner);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (old->original != real_packet->original);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    BV_SET(fields, 3);
  }

  differ = (old->history != real_packet->history);
  if (differ) {
    BV_SET(fields, 4);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < 5; i++) {
          if (old->ppl_happy[i] != real_packet->ppl_happy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 5);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < 5; i++) {
          if (old->ppl_content[i] != real_packet->ppl_content[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 6);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < 5; i++) {
          if (old->ppl_unhappy[i] != real_packet->ppl_unhappy[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 7);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < 5; i++) {
          if (old->ppl_angry[i] != real_packet->ppl_angry[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 8);
  }

  differ = (old->specialists_size != real_packet->specialists_size);
  if (differ) {
    BV_SET(fields, 9);
  }


    {
      differ = (old->specialists_size != real_packet->specialists_size);
      if (!differ) {
        int i;

        for (i = 0; i < real_packet->specialists_size; i++) {
          if (old->specialists[i] != real_packet->specialists[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 10);
  }

  differ = (old->food_stock != real_packet->food_stock);
  if (differ) {
    BV_SET(fields, 11);
  }

  differ = (old->shield_stock != real_packet->shield_stock);
  if (differ) {
    BV_SET(fields, 12);
  }

  if (packet->airlift) {
    BV_SET(fields, 13);
  }

  if (packet->debug) {
    BV_SET(fields, 14);
  }

  if (packet->did_buy) {
    BV_SET(fields, 15);
  }

  if (packet->did_sell) {
    BV_SET(fields, 16);
  }

  if (packet->was_happy) {
    BV_SET(fields, 17);
  }

  differ = (old->anarchy != real_packet->anarchy);
  if (differ) {
    BV_SET(fields, 18);
  }

  differ = (old->rapture != real_packet->rapture);
  if (differ) {
    BV_SET(fields, 19);
  }

  differ = (old->steal != real_packet->steal);
  if (differ) {
    BV_SET(fields, 20);
  }

  differ = (old->turn_founded != real_packet->turn_founded);
  if (differ) {
    BV_SET(fields, 21);
  }

  differ = (old->turn_last_built != real_packet->turn_last_built);
  if (differ) {
    BV_SET(fields, 22);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < B_LAST; i++) {
          if (old->built[i] != real_packet->built[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 23);
  }

  differ = (old->production_kind != real_packet->production_kind);
  if (differ) {
    BV_SET(fields, 24);
  }

  differ = (old->production_value != real_packet->production_value);
  if (differ) {
    BV_SET(fields, 25);
  }

  differ = !BV_ARE_EQUAL(old->city_options, real_packet->city_options);
  if (differ) {
    BV_SET(fields, 26);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'owner' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'original' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->original);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }
  if (BV_ISSET(fields, 4)) {
    log_packet_detailed("  field 'history' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
  }
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'ppl_happy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'ppl_content' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'ppl_unhappy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'ppl_angry' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 9)) {
    log_packet_detailed("  field 'specialists_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
  }
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'specialists' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 11)) {
    log_packet_detailed("  field 'food_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->food_stock);
  }
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'shield_stock' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
  }
  /* field 13 is folded into the header */
  /* field 14 is folded into the header */
  /* field 15 is folded into the header */
  /* field 16 is folded into the header */
  /* field 17 is folded into the header */
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'anarchy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "anarchy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->anarchy);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'rapture' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rapture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->rapture);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'steal' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->steal);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'turn_founded' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
  }
  if (BV_ISSET(fields, 22)) {
    log_packet_detailed("  field 'turn_last_built' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
  }
  if (BV_ISSET(fields, 23)) {
    log_packet_detailed("  field 'built' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "built";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      int count = 0;

      for (i = 0; i < B_LAST; i++) {
        if (old->built[i] != real_packet->built[i]) {
          count++;
        }
      }
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, count + 1);

      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);

      count = 0;
#endif /* FREECIV_JSON_CONNECTION */

      fc_assert(B_LAST < 255);

      for (i = 0; i < B_LAST; i++) {
        if (old->built[i] != real_packet->built[i]) {
#ifdef FREECIV_JSON_CONNECTION
          /* Next diff array element. */
          field_addr.sub_location->number = count - 1;

          /* Create the diff array element. */
          DIO_PUT(farray, &dout, &field_addr, 2);

          /* Enter diff array element (start at the index address). */
          field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(uint8, &dout, &field_addr, i);

#ifdef FREECIV_JSON_CONNECTION
          /* Content address. */
          field_addr.sub_location->sub_location->number = 1;
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(sint32, &dout, &field_addr, real_packet->built[i]);

#ifdef FREECIV_JSON_CONNECTION
          /* Exit diff array element. */
          free(field_addr.sub_location->sub_location);
          field_addr.sub_location->sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
        }
      }
#ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = count - 1;

      /* Create the diff array element. */
      DIO_PUT(farray, &dout, &field_addr, B_LAST);

      /* Enter diff array element. Point to index address. */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
      DIO_PUT(uint8, &dout, &field_addr, 255);

#ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;

      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  if (BV_ISSET(fields, 24)) {
    log_packet_detailed("  field 'production_kind' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
  }
  if (BV_ISSET(fields, 25)) {
    log_packet_detailed("  field 'production_value' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
  }
  if (BV_ISSET(fields, 26)) {
    log_packet_detailed("  field 'city_options' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(estring, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "owner";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->owner);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "original";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->original);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "history";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->history);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_happy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_happy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_content";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_content[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_unhappy";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_unhappy[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ppl_angry";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, 5);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < 5; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->ppl_angry[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "specialists";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, real_packet->specialists_size);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < real_packet->specialists_size; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(uint8, &dout, &field_addr, real_packet->specialists[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "food_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->food_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "shield_stock";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->shield_stock);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "airlift";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->airlift);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "debug";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->debug);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_buy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_buy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "did_sell";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->did_sell);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "was_happy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->was_happy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "anarchy";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->anarchy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "rapture";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->rapture);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "steal";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->steal);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_founded";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_founded);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "turn_last_built";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->turn_last_built);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "built";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, B_LAST);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < B_LAST; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(sint32, &dout, &field_addr, real_packet->built[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_kind";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_kind);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "production_value";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->production_value);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "city_options";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->city_options);

#endif
  SEND_PACKET_END(PACKET_EDIT_CITY);
}

int send_packet_edit_city(struct connection *pc, const struct packet_edit_city *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_CITY].packet != NULL, -1,
                        "Handler for PACKET_EDIT_CITY not installed");
  return pc->phs.handlers->send[PACKET_EDIT_CITY].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_player_create_100 hash_const

#define cmp_packet_edit_player_create_100 cmp_const

BV_DEFINE(packet_edit_player_create_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_player_create *receive_packet_edit_player_create_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_player_create_100_fields fields;
  struct packet_edit_player_create *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_PLAYER_CREATE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_player_create, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tag)) {
    RECEIVE_PACKET_FIELD_ERROR(tag);
  }

#endif
  log_packet_detailed("packet_edit_player_create_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_player_create_100, cmp_packet_edit_player_create_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tag'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tag";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tag)) {
      RECEIVE_PACKET_FIELD_ERROR(tag);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_player_create_100(struct connection *pc, const struct packet_edit_player_create *packet)
{
  const struct packet_edit_player_create *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_player_create_100_fields fields;
  struct packet_edit_player_create *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_PLAYER_CREATE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_PLAYER_CREATE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_player_create_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_player_create_100, cmp_packet_edit_player_create_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->tag != real_packet->tag);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tag' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tag);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tag);

#endif
  SEND_PACKET_END(PACKET_EDIT_PLAYER_CREATE);
}

int send_packet_edit_player_create(struct connection *pc, const struct packet_edit_player_create *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_PLAYER_CREATE].packet != NULL, -1,
                        "Handler for PACKET_EDIT_PLAYER_CREATE not installed");
  return pc->phs.handlers->send[PACKET_EDIT_PLAYER_CREATE].packet(pc, packet);
}

int dsend_packet_edit_player_create(struct connection *pc, int tag)
{
  struct packet_edit_player_create packet, *real_packet = &packet;

  real_packet->tag = tag;
  
  return send_packet_edit_player_create(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_player_remove_100 hash_const

#define cmp_packet_edit_player_remove_100 cmp_const

BV_DEFINE(packet_edit_player_remove_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_player_remove *receive_packet_edit_player_remove_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_player_remove_100_fields fields;
  struct packet_edit_player_remove *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_PLAYER_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_player_remove, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#endif
  log_packet_detailed("packet_edit_player_remove_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_player_remove_100, cmp_packet_edit_player_remove_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_player_remove_100(struct connection *pc, const struct packet_edit_player_remove *packet)
{
  const struct packet_edit_player_remove *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_player_remove_100_fields fields;
  struct packet_edit_player_remove *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_PLAYER_REMOVE;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_PLAYER_REMOVE);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_player_remove_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_player_remove_100, cmp_packet_edit_player_remove_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);

#endif
  SEND_PACKET_END(PACKET_EDIT_PLAYER_REMOVE);
}

int send_packet_edit_player_remove(struct connection *pc, const struct packet_edit_player_remove *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_PLAYER_REMOVE].packet != NULL, -1,
                        "Handler for PACKET_EDIT_PLAYER_REMOVE not installed");
  return pc->phs.handlers->send[PACKET_EDIT_PLAYER_REMOVE].packet(pc, packet);
}

int dsend_packet_edit_player_remove(struct connection *pc, int id)
{
  struct packet_edit_player_remove packet, *real_packet = &packet;

  real_packet->id = id;
  
  return send_packet_edit_player_remove(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_edit_player_100(const void *vkey)
{
  const struct packet_edit_player *key = (const struct packet_edit_player *) vkey;

  return key->id;
}

static bool cmp_packet_edit_player_100(const void *vkey1, const void *vkey2)
{
  const struct packet_edit_player *key1 = (const struct packet_edit_player *) vkey1;
  const struct packet_edit_player *key2 = (const struct packet_edit_player *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_edit_player_100_fields, 24);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_player *receive_packet_edit_player_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_player_100_fields fields;
  struct packet_edit_player *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_PLAYER;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_player, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
    RECEIVE_PACKET_FIELD_ERROR(name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->username, sizeof(real_packet->username))) {
    RECEIVE_PACKET_FIELD_ERROR(username);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ranked_username";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->ranked_username, sizeof(real_packet->ranked_username))) {
    RECEIVE_PACKET_FIELD_ERROR(ranked_username);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "user_turns";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->user_turns)) {
    RECEIVE_PACKET_FIELD_ERROR(user_turns);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_male";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_male)) {
    RECEIVE_PACKET_FIELD_ERROR(is_male);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(government);
    }
    real_packet->government = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_government";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(target_government);
    }
    real_packet->target_government = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(nation);
    }
    real_packet->nation = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->team)) {
    RECEIVE_PACKET_FIELD_ERROR(team);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase_done";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->phase_done)) {
    RECEIVE_PACKET_FIELD_ERROR(phase_done);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nturns_idle";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->nturns_idle)) {
    RECEIVE_PACKET_FIELD_ERROR(nturns_idle);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_alive";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->is_alive)) {
    RECEIVE_PACKET_FIELD_ERROR(is_alive);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "revolution_finishes";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->revolution_finishes)) {
    RECEIVE_PACKET_FIELD_ERROR(revolution_finishes);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "embassy";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->embassy)) {
    RECEIVE_PACKET_FIELD_ERROR(embassy);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->gold)) {
    RECEIVE_PACKET_FIELD_ERROR(gold);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tax";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tax)) {
    RECEIVE_PACKET_FIELD_ERROR(tax);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->science)) {
    RECEIVE_PACKET_FIELD_ERROR(science);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "luxury";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->luxury)) {
    RECEIVE_PACKET_FIELD_ERROR(luxury);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "future_tech";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->future_tech)) {
    RECEIVE_PACKET_FIELD_ERROR(future_tech);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "researching";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->researching)) {
    RECEIVE_PACKET_FIELD_ERROR(researching);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bulbs_researched";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->bulbs_researched)) {
    RECEIVE_PACKET_FIELD_ERROR(bulbs_researched);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "inventions";
  #endif /* FREECIV_JSON_CONNECTION */
  
  {
    int i;
  
    for (i = 0; i < A_LAST + 1; i++) {
      if (!DIO_GET(bool8, &din, &field_addr, &real_packet->inventions[i])) {
        RECEIVE_PACKET_FIELD_ERROR(inventions);
      }
    }
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ai";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->ai)) {
    RECEIVE_PACKET_FIELD_ERROR(ai);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_reserved";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->scenario_reserved)) {
    RECEIVE_PACKET_FIELD_ERROR(scenario_reserved);
  }

#endif
  log_packet_detailed("packet_edit_player_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_player_100, cmp_packet_edit_player_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->name, sizeof(real_packet->name))) {
      RECEIVE_PACKET_FIELD_ERROR(name);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'username'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "username";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->username, sizeof(real_packet->username))) {
      RECEIVE_PACKET_FIELD_ERROR(username);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'ranked_username'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "ranked_username";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->ranked_username, sizeof(real_packet->ranked_username))) {
      RECEIVE_PACKET_FIELD_ERROR(ranked_username);
    }
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'user_turns'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "user_turns";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->user_turns)) {
      RECEIVE_PACKET_FIELD_ERROR(user_turns);
    }
  }
  real_packet->is_male = BV_ISSET(fields, 4);
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  got field 'government'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "government";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(government);
      }
      real_packet->government = readin;
    }
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  got field 'target_government'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "target_government";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint8, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(target_government);
      }
      real_packet->target_government = readin;
    }
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  got field 'nation'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nation";
    #endif /* FREECIV_JSON_CONNECTION */
    {
      int readin;
    
      if (!DIO_GET(sint16, &din, &field_addr, &readin)) {
        RECEIVE_PACKET_FIELD_ERROR(nation);
      }
      real_packet->nation = readin;
    }
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  got field 'team'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "team";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->team)) {
      RECEIVE_PACKET_FIELD_ERROR(team);
    }
  }
  real_packet->phase_done = BV_ISSET(fields, 9);
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  got field 'nturns_idle'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "nturns_idle";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->nturns_idle)) {
      RECEIVE_PACKET_FIELD_ERROR(nturns_idle);
    }
  }
  real_packet->is_alive = BV_ISSET(fields, 11);
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  got field 'revolution_finishes'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "revolution_finishes";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->revolution_finishes)) {
      RECEIVE_PACKET_FIELD_ERROR(revolution_finishes);
    }
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  got field 'embassy'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "embassy";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->embassy)) {
      RECEIVE_PACKET_FIELD_ERROR(embassy);
    }
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  got field 'gold'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "gold";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->gold)) {
      RECEIVE_PACKET_FIELD_ERROR(gold);
    }
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  got field 'tax'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tax";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->tax)) {
      RECEIVE_PACKET_FIELD_ERROR(tax);
    }
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  got field 'science'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "science";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->science)) {
      RECEIVE_PACKET_FIELD_ERROR(science);
    }
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  got field 'luxury'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "luxury";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->luxury)) {
      RECEIVE_PACKET_FIELD_ERROR(luxury);
    }
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  got field 'future_tech'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "future_tech";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->future_tech)) {
      RECEIVE_PACKET_FIELD_ERROR(future_tech);
    }
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  got field 'researching'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "researching";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->researching)) {
      RECEIVE_PACKET_FIELD_ERROR(researching);
    }
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  got field 'bulbs_researched'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "bulbs_researched";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->bulbs_researched)) {
      RECEIVE_PACKET_FIELD_ERROR(bulbs_researched);
    }
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  got field 'inventions'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "inventions";
    #endif /* FREECIV_JSON_CONNECTION */
    
    {
    #ifdef FREECIV_JSON_CONNECTION
    int count;
    
    /* Enter array. */
    field_addr.sub_location = plocation_elem_new(0);
    
    for (count = 0;; count++) {
      int i;
    
      field_addr.sub_location->number = count;
    
      /* Enter diff array element (start at the index address). */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
    #else /* FREECIV_JSON_CONNECTION */
    while (TRUE) {
      int i;
    #endif /* FREECIV_JSON_CONNECTION */
    
      if (!DIO_GET(uint8, &din, &field_addr, &i)) {
        RECEIVE_PACKET_FIELD_ERROR(inventions);
      }
      if (i == 255) {
    #ifdef FREECIV_JSON_CONNECTION
        /* Exit diff array element. */
        free(field_addr.sub_location->sub_location);
        field_addr.sub_location->sub_location = NULL;
    
        /* Exit diff array. */
        free(field_addr.sub_location);
        field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    
        break;
      }
      if (i > A_LAST + 1) {
        RECEIVE_PACKET_FIELD_ERROR(inventions,
                                   ": unexpected value %d "
                                   "(> A_LAST + 1) in array diff",
                                   i);
      } else {
    #ifdef FREECIV_JSON_CONNECTION
        /* Content address. */
        field_addr.sub_location->sub_location->number = 1;
    #endif /* FREECIV_JSON_CONNECTION */
        if (!DIO_GET(bool8, &din, &field_addr, &real_packet->inventions[i])) {
          RECEIVE_PACKET_FIELD_ERROR(inventions);
        }
      }
    
    #ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
    
    #ifdef FREECIV_JSON_CONNECTION
    /* Exit array. */
    free(field_addr.sub_location);
    field_addr.sub_location = NULL;
    #endif /* FREECIV_JSON_CONNECTION */
    }
  }
  real_packet->ai = BV_ISSET(fields, 22);
  real_packet->scenario_reserved = BV_ISSET(fields, 23);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_player_100(struct connection *pc, const struct packet_edit_player *packet)
{
  const struct packet_edit_player *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_player_100_fields fields;
  struct packet_edit_player *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_PLAYER;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_PLAYER);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_player_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_player_100, cmp_packet_edit_player_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->name, real_packet->name) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->username, real_packet->username) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->ranked_username, real_packet->ranked_username) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  differ = (old->user_turns != real_packet->user_turns);
  if (differ) {
    BV_SET(fields, 3);
  }

  if (packet->is_male) {
    BV_SET(fields, 4);
  }

  differ = (old->government != real_packet->government);
  if (differ) {
    BV_SET(fields, 5);
  }

  differ = (old->target_government != real_packet->target_government);
  if (differ) {
    BV_SET(fields, 6);
  }

  differ = (old->nation != real_packet->nation);
  if (differ) {
    BV_SET(fields, 7);
  }

  differ = (old->team != real_packet->team);
  if (differ) {
    BV_SET(fields, 8);
  }

  if (packet->phase_done) {
    BV_SET(fields, 9);
  }

  differ = (old->nturns_idle != real_packet->nturns_idle);
  if (differ) {
    BV_SET(fields, 10);
  }

  if (packet->is_alive) {
    BV_SET(fields, 11);
  }

  differ = (old->revolution_finishes != real_packet->revolution_finishes);
  if (differ) {
    BV_SET(fields, 12);
  }

  differ = !BV_ARE_EQUAL(old->embassy, real_packet->embassy);
  if (differ) {
    BV_SET(fields, 13);
  }

  differ = (old->gold != real_packet->gold);
  if (differ) {
    BV_SET(fields, 14);
  }

  differ = (old->tax != real_packet->tax);
  if (differ) {
    BV_SET(fields, 15);
  }

  differ = (old->science != real_packet->science);
  if (differ) {
    BV_SET(fields, 16);
  }

  differ = (old->luxury != real_packet->luxury);
  if (differ) {
    BV_SET(fields, 17);
  }

  differ = (old->future_tech != real_packet->future_tech);
  if (differ) {
    BV_SET(fields, 18);
  }

  differ = (old->researching != real_packet->researching);
  if (differ) {
    BV_SET(fields, 19);
  }

  differ = (old->bulbs_researched != real_packet->bulbs_researched);
  if (differ) {
    BV_SET(fields, 20);
  }


    {
      differ = FALSE;
      {
        int i;

        for (i = 0; i < A_LAST + 1; i++) {
          if (old->inventions[i] != real_packet->inventions[i]) {
            differ = TRUE;
            break;
          }
        }
      }
    }
  if (differ) {
    BV_SET(fields, 21);
  }

  if (packet->ai) {
    BV_SET(fields, 22);
  }

  if (packet->scenario_reserved) {
    BV_SET(fields, 23);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'username' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->username);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'ranked_username' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ranked_username";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->ranked_username);
  }
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'user_turns' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "user_turns";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->user_turns);
  }
  /* field 4 is folded into the header */
  if (BV_ISSET(fields, 5)) {
    log_packet_detailed("  field 'government' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->government);
  }
  if (BV_ISSET(fields, 6)) {
    log_packet_detailed("  field 'target_government' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_government);
  }
  if (BV_ISSET(fields, 7)) {
    log_packet_detailed("  field 'nation' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nation);
  }
  if (BV_ISSET(fields, 8)) {
    log_packet_detailed("  field 'team' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->team);
  }
  /* field 9 is folded into the header */
  if (BV_ISSET(fields, 10)) {
    log_packet_detailed("  field 'nturns_idle' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nturns_idle";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nturns_idle);
  }
  /* field 11 is folded into the header */
  if (BV_ISSET(fields, 12)) {
    log_packet_detailed("  field 'revolution_finishes' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "revolution_finishes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->revolution_finishes);
  }
  if (BV_ISSET(fields, 13)) {
    log_packet_detailed("  field 'embassy' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "embassy";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->embassy);
  }
  if (BV_ISSET(fields, 14)) {
    log_packet_detailed("  field 'gold' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->gold);
  }
  if (BV_ISSET(fields, 15)) {
    log_packet_detailed("  field 'tax' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tax";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tax);
  }
  if (BV_ISSET(fields, 16)) {
    log_packet_detailed("  field 'science' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->science);
  }
  if (BV_ISSET(fields, 17)) {
    log_packet_detailed("  field 'luxury' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "luxury";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->luxury);
  }
  if (BV_ISSET(fields, 18)) {
    log_packet_detailed("  field 'future_tech' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "future_tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->future_tech);
  }
  if (BV_ISSET(fields, 19)) {
    log_packet_detailed("  field 'researching' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "researching";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->researching);
  }
  if (BV_ISSET(fields, 20)) {
    log_packet_detailed("  field 'bulbs_researched' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bulbs_researched";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->bulbs_researched);
  }
  if (BV_ISSET(fields, 21)) {
    log_packet_detailed("  field 'inventions' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "inventions";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      int count = 0;

      for (i = 0; i < A_LAST + 1; i++) {
        if (old->inventions[i] != real_packet->inventions[i]) {
          count++;
        }
      }
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, count + 1);

      /* Enter array. */
      field_addr.sub_location = plocation_elem_new(0);

      count = 0;
#endif /* FREECIV_JSON_CONNECTION */

      fc_assert(A_LAST + 1 < 255);

      for (i = 0; i < A_LAST + 1; i++) {
        if (old->inventions[i] != real_packet->inventions[i]) {
#ifdef FREECIV_JSON_CONNECTION
          /* Next diff array element. */
          field_addr.sub_location->number = count - 1;

          /* Create the diff array element. */
          DIO_PUT(farray, &dout, &field_addr, 2);

          /* Enter diff array element (start at the index address). */
          field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(uint8, &dout, &field_addr, i);

#ifdef FREECIV_JSON_CONNECTION
          /* Content address. */
          field_addr.sub_location->sub_location->number = 1;
#endif /* FREECIV_JSON_CONNECTION */
          DIO_PUT(bool8, &dout, &field_addr, real_packet->inventions[i]);

#ifdef FREECIV_JSON_CONNECTION
          /* Exit diff array element. */
          free(field_addr.sub_location->sub_location);
          field_addr.sub_location->sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
        }
      }
#ifdef FREECIV_JSON_CONNECTION
      field_addr.sub_location->number = count - 1;

      /* Create the diff array element. */
      DIO_PUT(farray, &dout, &field_addr, A_LAST + 1);

      /* Enter diff array element. Point to index address. */
      field_addr.sub_location->sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */
      DIO_PUT(uint8, &dout, &field_addr, 255);

#ifdef FREECIV_JSON_CONNECTION
      /* Exit diff array element. */
      free(field_addr.sub_location->sub_location);
      field_addr.sub_location->sub_location = NULL;

      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
  }
  /* field 22 is folded into the header */
  /* field 23 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "username";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->username);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ranked_username";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->ranked_username);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "user_turns";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->user_turns);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_male";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_male);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->government);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "target_government";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint8, &dout, &field_addr, real_packet->target_government);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nation";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nation);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "team";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->team);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "phase_done";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->phase_done);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "nturns_idle";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->nturns_idle);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "is_alive";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->is_alive);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "revolution_finishes";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->revolution_finishes);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "embassy";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->embassy);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "gold";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->gold);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tax";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->tax);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "science";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->science);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "luxury";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->luxury);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "future_tech";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->future_tech);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "researching";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->researching);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "bulbs_researched";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->bulbs_researched);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "inventions";
#endif /* FREECIV_JSON_CONNECTION */

    {
      int i;

#ifdef FREECIV_JSON_CONNECTION
      /* Create the array. */
      DIO_PUT(farray, &dout, &field_addr, A_LAST + 1);

      /* Enter the array. */
      field_addr.sub_location = plocation_elem_new(0);
#endif /* FREECIV_JSON_CONNECTION */

      for (i = 0; i < A_LAST + 1; i++) {
#ifdef FREECIV_JSON_CONNECTION
        /* Next array element. */
        field_addr.sub_location->number = i;
#endif /* FREECIV_JSON_CONNECTION */
        DIO_PUT(bool8, &dout, &field_addr, real_packet->inventions[i]);
      }

#ifdef FREECIV_JSON_CONNECTION
      /* Exit array. */
      free(field_addr.sub_location);
      field_addr.sub_location = NULL;
#endif /* FREECIV_JSON_CONNECTION */
    }
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ai";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->ai);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_reserved";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->scenario_reserved);

#endif
  SEND_PACKET_END(PACKET_EDIT_PLAYER);
}

int send_packet_edit_player(struct connection *pc, const struct packet_edit_player *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_PLAYER].packet != NULL, -1,
                        "Handler for PACKET_EDIT_PLAYER not installed");
  return pc->phs.handlers->send[PACKET_EDIT_PLAYER].packet(pc, packet);
}

void lsend_packet_edit_player(struct conn_list *dest, const struct packet_edit_player *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_edit_player(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_player_vision_100 hash_const

#define cmp_packet_edit_player_vision_100 cmp_const

BV_DEFINE(packet_edit_player_vision_100_fields, 4);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_player_vision *receive_packet_edit_player_vision_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_player_vision_100_fields fields;
  struct packet_edit_player_vision *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_PLAYER_VISION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_player_vision, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player)) {
    RECEIVE_PACKET_FIELD_ERROR(player);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
    RECEIVE_PACKET_FIELD_ERROR(tile);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "known";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->known)) {
    RECEIVE_PACKET_FIELD_ERROR(known);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
    RECEIVE_PACKET_FIELD_ERROR(size);
  }

#endif
  log_packet_detailed("packet_edit_player_vision_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_player_vision_100, cmp_packet_edit_player_vision_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'player'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "player";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->player)) {
      RECEIVE_PACKET_FIELD_ERROR(player);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'tile'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tile";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tile)) {
      RECEIVE_PACKET_FIELD_ERROR(tile);
    }
  }
  real_packet->known = BV_ISSET(fields, 2);
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  got field 'size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint8, &din, &field_addr, &real_packet->size)) {
      RECEIVE_PACKET_FIELD_ERROR(size);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_player_vision_100(struct connection *pc, const struct packet_edit_player_vision *packet)
{
  const struct packet_edit_player_vision *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_player_vision_100_fields fields;
  struct packet_edit_player_vision *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_PLAYER_VISION;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_PLAYER_VISION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_player_vision_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_player_vision_100, cmp_packet_edit_player_vision_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->player != real_packet->player);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->tile != real_packet->tile);
  if (differ) {
    BV_SET(fields, 1);
  }

  if (packet->known) {
    BV_SET(fields, 2);
  }

  differ = (old->size != real_packet->size);
  if (differ) {
    BV_SET(fields, 3);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'player' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'tile' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
  }
  /* field 2 is folded into the header */
  if (BV_ISSET(fields, 3)) {
    log_packet_detailed("  field 'size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "player";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->player);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tile";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tile);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "known";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->known);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->size);

#endif
  SEND_PACKET_END(PACKET_EDIT_PLAYER_VISION);
}

int send_packet_edit_player_vision(struct connection *pc, const struct packet_edit_player_vision *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_PLAYER_VISION].packet != NULL, -1,
                        "Handler for PACKET_EDIT_PLAYER_VISION not installed");
  return pc->phs.handlers->send[PACKET_EDIT_PLAYER_VISION].packet(pc, packet);
}

int dsend_packet_edit_player_vision(struct connection *pc, int player, int tile, bool known, int size)
{
  struct packet_edit_player_vision packet, *real_packet = &packet;

  real_packet->player = player;
  real_packet->tile = tile;
  real_packet->known = known;
  real_packet->size = size;
  
  return send_packet_edit_player_vision(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_game_100 hash_const

#define cmp_packet_edit_game_100 cmp_const

BV_DEFINE(packet_edit_game_100_fields, 9);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_game *receive_packet_edit_game_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_game_100_fields fields;
  struct packet_edit_game *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_GAME;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_game, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->scenario)) {
    RECEIVE_PACKET_FIELD_ERROR(scenario);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_name";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->scenario_name, sizeof(real_packet->scenario_name))) {
    RECEIVE_PACKET_FIELD_ERROR(scenario_name);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_authors";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->scenario_authors, sizeof(real_packet->scenario_authors))) {
    RECEIVE_PACKET_FIELD_ERROR(scenario_authors);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_random";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->scenario_random)) {
    RECEIVE_PACKET_FIELD_ERROR(scenario_random);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_players";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->scenario_players)) {
    RECEIVE_PACKET_FIELD_ERROR(scenario_players);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "startpos_nations";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->startpos_nations)) {
    RECEIVE_PACKET_FIELD_ERROR(startpos_nations);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prevent_new_cities";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->prevent_new_cities)) {
    RECEIVE_PACKET_FIELD_ERROR(prevent_new_cities);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lake_flooding";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->lake_flooding)) {
    RECEIVE_PACKET_FIELD_ERROR(lake_flooding);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ruleset_locked";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(bool8, &din, &field_addr, &real_packet->ruleset_locked)) {
    RECEIVE_PACKET_FIELD_ERROR(ruleset_locked);
  }

#endif
  log_packet_detailed("packet_edit_game_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_game_100, cmp_packet_edit_game_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  real_packet->scenario = BV_ISSET(fields, 0);
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'scenario_name'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "scenario_name";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->scenario_name, sizeof(real_packet->scenario_name))) {
      RECEIVE_PACKET_FIELD_ERROR(scenario_name);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'scenario_authors'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "scenario_authors";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->scenario_authors, sizeof(real_packet->scenario_authors))) {
      RECEIVE_PACKET_FIELD_ERROR(scenario_authors);
    }
  }
  real_packet->scenario_random = BV_ISSET(fields, 3);
  real_packet->scenario_players = BV_ISSET(fields, 4);
  real_packet->startpos_nations = BV_ISSET(fields, 5);
  real_packet->prevent_new_cities = BV_ISSET(fields, 6);
  real_packet->lake_flooding = BV_ISSET(fields, 7);
  real_packet->ruleset_locked = BV_ISSET(fields, 8);

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_game_100(struct connection *pc, const struct packet_edit_game *packet)
{
  const struct packet_edit_game *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_game_100_fields fields;
  struct packet_edit_game *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_GAME;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_GAME);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_game_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_game_100, cmp_packet_edit_game_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  if (packet->scenario) {
    BV_SET(fields, 0);
  }

  differ = (strcmp(old->scenario_name, real_packet->scenario_name) != 0);
  if (differ) {
    BV_SET(fields, 1);
  }

  differ = (strcmp(old->scenario_authors, real_packet->scenario_authors) != 0);
  if (differ) {
    BV_SET(fields, 2);
  }

  if (packet->scenario_random) {
    BV_SET(fields, 3);
  }

  if (packet->scenario_players) {
    BV_SET(fields, 4);
  }

  if (packet->startpos_nations) {
    BV_SET(fields, 5);
  }

  if (packet->prevent_new_cities) {
    BV_SET(fields, 6);
  }

  if (packet->lake_flooding) {
    BV_SET(fields, 7);
  }

  if (packet->ruleset_locked) {
    BV_SET(fields, 8);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  /* field 0 is folded into the header */
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'scenario_name' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->scenario_name);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'scenario_authors' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_authors";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->scenario_authors);
  }
  /* field 3 is folded into the header */
  /* field 4 is folded into the header */
  /* field 5 is folded into the header */
  /* field 6 is folded into the header */
  /* field 7 is folded into the header */
  /* field 8 is folded into the header */

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->scenario);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_name";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->scenario_name);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_authors";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->scenario_authors);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_random";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->scenario_random);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_players";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->scenario_players);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "startpos_nations";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->startpos_nations);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "prevent_new_cities";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->prevent_new_cities);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "lake_flooding";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->lake_flooding);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "ruleset_locked";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(bool8, &dout, &field_addr, real_packet->ruleset_locked);

#endif
  SEND_PACKET_END(PACKET_EDIT_GAME);
}

int send_packet_edit_game(struct connection *pc, const struct packet_edit_game *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_GAME].packet != NULL, -1,
                        "Handler for PACKET_EDIT_GAME not installed");
  return pc->phs.handlers->send[PACKET_EDIT_GAME].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_scenario_desc_100 hash_const

#define cmp_packet_edit_scenario_desc_100 cmp_const

BV_DEFINE(packet_edit_scenario_desc_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_scenario_desc *receive_packet_edit_scenario_desc_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_scenario_desc_100_fields fields;
  struct packet_edit_scenario_desc *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_SCENARIO_DESC;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_scenario_desc, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_desc";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->scenario_desc, sizeof(real_packet->scenario_desc))) {
    RECEIVE_PACKET_FIELD_ERROR(scenario_desc);
  }

#endif
  log_packet_detailed("packet_edit_scenario_desc_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_scenario_desc_100, cmp_packet_edit_scenario_desc_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'scenario_desc'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "scenario_desc";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->scenario_desc, sizeof(real_packet->scenario_desc))) {
      RECEIVE_PACKET_FIELD_ERROR(scenario_desc);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_scenario_desc_100(struct connection *pc, const struct packet_edit_scenario_desc *packet)
{
  const struct packet_edit_scenario_desc *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_scenario_desc_100_fields fields;
  struct packet_edit_scenario_desc *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_SCENARIO_DESC;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_SCENARIO_DESC);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_scenario_desc_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_scenario_desc_100, cmp_packet_edit_scenario_desc_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->scenario_desc, real_packet->scenario_desc) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'scenario_desc' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_desc";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->scenario_desc);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "scenario_desc";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->scenario_desc);

#endif
  SEND_PACKET_END(PACKET_EDIT_SCENARIO_DESC);
}

int send_packet_edit_scenario_desc(struct connection *pc, const struct packet_edit_scenario_desc *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_SCENARIO_DESC].packet != NULL, -1,
                        "Handler for PACKET_EDIT_SCENARIO_DESC not installed");
  return pc->phs.handlers->send[PACKET_EDIT_SCENARIO_DESC].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_edit_object_created_100 hash_const

#define cmp_packet_edit_object_created_100 cmp_const

BV_DEFINE(packet_edit_object_created_100_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_edit_object_created *receive_packet_edit_object_created_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_object_created_100_fields fields;
  struct packet_edit_object_created *old;
  struct genhash **hash = pc->phs.received + PACKET_EDIT_OBJECT_CREATED;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_edit_object_created, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tag)) {
    RECEIVE_PACKET_FIELD_ERROR(tag);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint32, &din, &field_addr, &real_packet->id)) {
    RECEIVE_PACKET_FIELD_ERROR(id);
  }

#endif
  log_packet_detailed("packet_edit_object_created_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_object_created_100, cmp_packet_edit_object_created_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tag'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tag";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->tag)) {
      RECEIVE_PACKET_FIELD_ERROR(tag);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'id'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint32, &din, &field_addr, &real_packet->id)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_edit_object_created_100(struct connection *pc, const struct packet_edit_object_created *packet)
{
  const struct packet_edit_object_created *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_edit_object_created_100_fields fields;
  struct packet_edit_object_created *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_EDIT_OBJECT_CREATED;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_EDIT_OBJECT_CREATED);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_edit_object_created_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_edit_object_created_100, cmp_packet_edit_object_created_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (old->tag != real_packet->tag);
  if (differ) {
    BV_SET(fields, 0);
  }

  differ = (old->id != real_packet->id);
  if (differ) {
    BV_SET(fields, 1);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tag' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tag);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'id' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->id);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->tag);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint32, &dout, &field_addr, real_packet->id);

#endif
  SEND_PACKET_END(PACKET_EDIT_OBJECT_CREATED);
}

int send_packet_edit_object_created(struct connection *pc, const struct packet_edit_object_created *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_EDIT_OBJECT_CREATED].packet != NULL, -1,
                        "Handler for PACKET_EDIT_OBJECT_CREATED not installed");
  return pc->phs.handlers->send[PACKET_EDIT_OBJECT_CREATED].packet(pc, packet);
}

int dsend_packet_edit_object_created(struct connection *pc, int tag, int id)
{
  struct packet_edit_object_created packet, *real_packet = &packet;

  real_packet->tag = tag;
  real_packet->id = id;
  
  return send_packet_edit_object_created(pc, real_packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_play_music_100 hash_const

#define cmp_packet_play_music_100 cmp_const

BV_DEFINE(packet_play_music_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_play_music *receive_packet_play_music_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_play_music_100_fields fields;
  struct packet_play_music *old;
  struct genhash **hash = pc->phs.received + PACKET_PLAY_MUSIC;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_play_music, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(string, &din, &field_addr, real_packet->tag, sizeof(real_packet->tag))) {
    RECEIVE_PACKET_FIELD_ERROR(tag);
  }

#endif
  log_packet_detailed("packet_play_music_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_play_music_100, cmp_packet_play_music_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'tag'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "tag";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(string, &din, &field_addr, real_packet->tag, sizeof(real_packet->tag))) {
      RECEIVE_PACKET_FIELD_ERROR(tag);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_play_music_100(struct connection *pc, const struct packet_play_music *packet)
{
  const struct packet_play_music *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_play_music_100_fields fields;
  struct packet_play_music *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_PLAY_MUSIC;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_PLAY_MUSIC);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_play_music_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_play_music_100, cmp_packet_play_music_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = (strcmp(old->tag, real_packet->tag) != 0);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'tag' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->tag);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "tag";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(string, &dout, &field_addr, real_packet->tag);

#endif
  SEND_PACKET_END(PACKET_PLAY_MUSIC);
}

int send_packet_play_music(struct connection *pc, const struct packet_play_music *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_PLAY_MUSIC].packet != NULL, -1,
                        "Handler for PACKET_PLAY_MUSIC not installed");
  return pc->phs.handlers->send[PACKET_PLAY_MUSIC].packet(pc, packet);
}

void lsend_packet_play_music(struct conn_list *dest, const struct packet_play_music *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_play_music(pconn, packet);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
#define hash_packet_web_city_info_addition_100 hash_const

#define cmp_packet_web_city_info_addition_100 cmp_const

BV_DEFINE(packet_web_city_info_addition_100_fields, 3);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_web_city_info_addition *receive_packet_web_city_info_addition_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_web_city_info_addition_100_fields fields;
  struct packet_web_city_info_addition *old;
  struct genhash **hash = pc->phs.received + PACKET_WEB_CITY_INFO_ADDITION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_web_city_info_addition, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
  
#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
    RECEIVE_PACKET_FIELD_ERROR(id32);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granary_size)) {
    RECEIVE_PACKET_FIELD_ERROR(granary_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_turns";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->granary_turns)) {
    RECEIVE_PACKET_FIELD_ERROR(granary_turns);
  }

#endif
  log_packet_detailed("packet_web_city_info_addition_100: got info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_web_city_info_addition_100, cmp_packet_web_city_info_addition_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'id32'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "id32";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->id32)) {
      RECEIVE_PACKET_FIELD_ERROR(id32);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'granary_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "granary_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granary_size)) {
      RECEIVE_PACKET_FIELD_ERROR(granary_size);
    }
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  got field 'granary_turns'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "granary_turns";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->granary_turns)) {
      RECEIVE_PACKET_FIELD_ERROR(granary_turns);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_web_city_info_addition_100(struct connection *pc, const struct packet_web_city_info_addition *packet, bool force_to_send)
{
  const struct packet_web_city_info_addition *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_web_city_info_addition_100_fields fields;
  struct packet_web_city_info_addition *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_WEB_CITY_INFO_ADDITION;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_WEB_CITY_INFO_ADDITION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_web_city_info_addition_100: sending info about ()");

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_web_city_info_addition_100, cmp_packet_web_city_info_addition_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->id32 != real_packet->id32);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->granary_size != real_packet->granary_size);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }

  differ = (old->granary_turns != real_packet->granary_turns);
  if (differ) {
    different++;
    BV_SET(fields, 2);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'id32' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'granary_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->granary_size);
  }
  if (BV_ISSET(fields, 2)) {
    log_packet_detailed("  field 'granary_turns' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_turns";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->granary_turns);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id32";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->id32);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->granary_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_turns";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->granary_turns);

#endif
  SEND_PACKET_END(PACKET_WEB_CITY_INFO_ADDITION);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_web_city_info_addition_101(const void *vkey)
{
  const struct packet_web_city_info_addition *key = (const struct packet_web_city_info_addition *) vkey;

  return key->id16;
}

static bool cmp_packet_web_city_info_addition_101(const void *vkey1, const void *vkey2)
{
  const struct packet_web_city_info_addition *key1 = (const struct packet_web_city_info_addition *) vkey1;
  const struct packet_web_city_info_addition *key2 = (const struct packet_web_city_info_addition *) vkey2;

  return key1->id16 == key2->id16;
}
BV_DEFINE(packet_web_city_info_addition_101_fields, 2);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_web_city_info_addition *receive_packet_web_city_info_addition_101(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_web_city_info_addition_101_fields fields;
  struct packet_web_city_info_addition *old;
  struct genhash **hash = pc->phs.received + PACKET_WEB_CITY_INFO_ADDITION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_web_city_info_addition, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->id16)) {
    RECEIVE_PACKET_FIELD_ERROR(id16);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_size";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granary_size)) {
    RECEIVE_PACKET_FIELD_ERROR(granary_size);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_turns";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(sint16, &din, &field_addr, &real_packet->granary_turns)) {
    RECEIVE_PACKET_FIELD_ERROR(granary_turns);
  }

#endif
  log_packet_detailed("packet_web_city_info_addition_101: got info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_web_city_info_addition_101, cmp_packet_web_city_info_addition_101,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int id16 = real_packet->id16;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id16 = id16;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'granary_size'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "granary_size";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint16, &din, &field_addr, &real_packet->granary_size)) {
      RECEIVE_PACKET_FIELD_ERROR(granary_size);
    }
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  got field 'granary_turns'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "granary_turns";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(sint16, &din, &field_addr, &real_packet->granary_turns)) {
      RECEIVE_PACKET_FIELD_ERROR(granary_turns);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

  hash = pc->phs.received + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_web_city_info_addition_101(struct connection *pc, const struct packet_web_city_info_addition *packet, bool force_to_send)
{
  const struct packet_web_city_info_addition *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_web_city_info_addition_101_fields fields;
  struct packet_web_city_info_addition *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_WEB_CITY_INFO_ADDITION;
  int different = force_to_send;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_WEB_CITY_INFO_ADDITION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_web_city_info_addition_101: sending info about (%d)",
    real_packet->id16);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_web_city_info_addition_101, cmp_packet_web_city_info_addition_101,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->granary_size != real_packet->granary_size);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }

  differ = (old->granary_turns != real_packet->granary_turns);
  if (differ) {
    different++;
    BV_SET(fields, 1);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'granary_size' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->granary_size);
  }
  if (BV_ISSET(fields, 1)) {
    log_packet_detailed("  field 'granary_turns' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_turns";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->granary_turns);
  }

  *old = *real_packet;

  hash = pc->phs.sent + PACKET_CITY_SHORT_INFO;
  if (NULL != *hash) {
    genhash_remove(*hash, real_packet);
  }
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id16";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->id16);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_size";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->granary_size);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "granary_turns";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(sint16, &dout, &field_addr, real_packet->granary_turns);

#endif
  SEND_PACKET_END(PACKET_WEB_CITY_INFO_ADDITION);
}

int send_packet_web_city_info_addition(struct connection *pc, const struct packet_web_city_info_addition *packet, bool force_to_send)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_WEB_CITY_INFO_ADDITION].force_to_send != NULL, -1,
                        "Handler for PACKET_WEB_CITY_INFO_ADDITION not installed");
  return pc->phs.handlers->send[PACKET_WEB_CITY_INFO_ADDITION].force_to_send(pc, packet, force_to_send);
}

void lsend_packet_web_city_info_addition(struct conn_list *dest, const struct packet_web_city_info_addition *packet, bool force_to_send)
{
  conn_list_iterate(dest, pconn) {
    send_packet_web_city_info_addition(pconn, packet, force_to_send);
  } conn_list_iterate_end;
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_web_player_info_addition_100(const void *vkey)
{
  const struct packet_web_player_info_addition *key = (const struct packet_web_player_info_addition *) vkey;

  return key->playerno;
}

static bool cmp_packet_web_player_info_addition_100(const void *vkey1, const void *vkey2)
{
  const struct packet_web_player_info_addition *key1 = (const struct packet_web_player_info_addition *) vkey1;
  const struct packet_web_player_info_addition *key2 = (const struct packet_web_player_info_addition *) vkey2;

  return key1->playerno == key2->playerno;
}
BV_DEFINE(packet_web_player_info_addition_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_web_player_info_addition *receive_packet_web_player_info_addition_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_web_player_info_addition_100_fields fields;
  struct packet_web_player_info_addition *old;
  struct genhash **hash = pc->phs.received + PACKET_WEB_PLAYER_INFO_ADDITION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_web_player_info_addition, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->playerno)) {
    RECEIVE_PACKET_FIELD_ERROR(playerno);
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint16, &din, &field_addr, &real_packet->playerno)) {
    RECEIVE_PACKET_FIELD_ERROR(playerno);
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "expected_income";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_GET(uint32, &din, &field_addr, &real_packet->expected_income)) {
    RECEIVE_PACKET_FIELD_ERROR(expected_income);
  }

#endif
  log_packet_detailed("packet_web_player_info_addition_100: got info about (%d)",
    real_packet->playerno);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_web_player_info_addition_100, cmp_packet_web_player_info_addition_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    int playerno = real_packet->playerno;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->playerno = playerno;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'expected_income'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "expected_income";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_GET(uint32, &din, &field_addr, &real_packet->expected_income)) {
      RECEIVE_PACKET_FIELD_ERROR(expected_income);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_web_player_info_addition_100(struct connection *pc, const struct packet_web_player_info_addition *packet)
{
  const struct packet_web_player_info_addition *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_web_player_info_addition_100_fields fields;
  struct packet_web_player_info_addition *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_WEB_PLAYER_INFO_ADDITION;
  int different = 0;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_WEB_PLAYER_INFO_ADDITION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_web_player_info_addition_100: sending info about (%d)",
    real_packet->playerno);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_web_player_info_addition_100, cmp_packet_web_player_info_addition_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
    different = 1;      /* Force to send. */
  }
  differ = (old->expected_income != real_packet->expected_income);
  if (differ) {
    different++;
    BV_SET(fields, 0);
  }


  if (different == 0) {
    log_packet_detailed("  no change -> discard");
    return 0;
  }

#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->playerno);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'expected_income' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "expected_income";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->expected_income);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "playerno";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint16, &dout, &field_addr, real_packet->playerno);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "expected_income";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint32, &dout, &field_addr, real_packet->expected_income);

#endif
  SEND_PACKET_END(PACKET_WEB_PLAYER_INFO_ADDITION);
}

int send_packet_web_player_info_addition(struct connection *pc, const struct packet_web_player_info_addition *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_WEB_PLAYER_INFO_ADDITION].packet != NULL, -1,
                        "Handler for PACKET_WEB_PLAYER_INFO_ADDITION not installed");
  return pc->phs.handlers->send[PACKET_WEB_PLAYER_INFO_ADDITION].packet(pc, packet);
}

#ifdef FREECIV_DELTA_PROTOCOL
static genhash_val_t hash_packet_web_ruleset_unit_addition_100(const void *vkey)
{
  const struct packet_web_ruleset_unit_addition *key = (const struct packet_web_ruleset_unit_addition *) vkey;

  return key->id;
}

static bool cmp_packet_web_ruleset_unit_addition_100(const void *vkey1, const void *vkey2)
{
  const struct packet_web_ruleset_unit_addition *key1 = (const struct packet_web_ruleset_unit_addition *) vkey1;
  const struct packet_web_ruleset_unit_addition *key2 = (const struct packet_web_ruleset_unit_addition *) vkey2;

  return key1->id == key2->id;
}
BV_DEFINE(packet_web_ruleset_unit_addition_100_fields, 1);
#endif /* FREECIV_DELTA_PROTOCOL */

static struct packet_web_ruleset_unit_addition *receive_packet_web_ruleset_unit_addition_100(struct connection *pc)
{
#ifdef FREECIV_DELTA_PROTOCOL
  packet_web_ruleset_unit_addition_100_fields fields;
  struct packet_web_ruleset_unit_addition *old;
  struct genhash **hash = pc->phs.received + PACKET_WEB_RULESET_UNIT_ADDITION;
#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_START(packet_web_ruleset_unit_addition, real_packet);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

#ifdef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_GET(&din, &field_addr, fields);
    #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }

#else /* FREECIV_DELTA_PROTOCOL */
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
  #endif /* FREECIV_JSON_CONNECTION */
  {
    int readin;
  
    if (!DIO_GET(uint8, &din, &field_addr, &readin)) {
      RECEIVE_PACKET_FIELD_ERROR(id);
    }
    real_packet->id = readin;
  }
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "utype_actions";
  #endif /* FREECIV_JSON_CONNECTION */
  if (!DIO_BV_GET(&din, &field_addr, real_packet->utype_actions)) {
    RECEIVE_PACKET_FIELD_ERROR(utype_actions);
  }

#endif
  log_packet_detailed("packet_web_ruleset_unit_addition_100: got info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_web_ruleset_unit_addition_100, cmp_packet_web_ruleset_unit_addition_100,
                             NULL, NULL, NULL, free);
  }

  if (genhash_lookup(*hash, real_packet, (void **) &old)) {
    *real_packet = *old;
  } else {
    Unit_type_id id = real_packet->id;

    log_packet_detailed("  no old info");
    memset(real_packet, 0, sizeof(*real_packet));

    real_packet->id = id;
  }

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  got field 'utype_actions'");
    #ifdef FREECIV_JSON_CONNECTION
    field_addr.name = "utype_actions";
    #endif /* FREECIV_JSON_CONNECTION */
    if (!DIO_BV_GET(&din, &field_addr, real_packet->utype_actions)) {
      RECEIVE_PACKET_FIELD_ERROR(utype_actions);
    }
  }

  if (NULL == old) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
  } else {
    *old = *real_packet;
  }

#endif /* FREECIV_DELTA_PROTOCOL */
  RECEIVE_PACKET_END(real_packet);
}

static int send_packet_web_ruleset_unit_addition_100(struct connection *pc, const struct packet_web_ruleset_unit_addition *packet)
{
  const struct packet_web_ruleset_unit_addition *real_packet = packet;
#ifdef FREECIV_DELTA_PROTOCOL
  packet_web_ruleset_unit_addition_100_fields fields;
  struct packet_web_ruleset_unit_addition *old;
  bool differ;
  struct genhash **hash = pc->phs.sent + PACKET_WEB_RULESET_UNIT_ADDITION;
#endif /* FREECIV_DELTA_PROTOCOL */
  SEND_PACKET_START(PACKET_WEB_RULESET_UNIT_ADDITION);
#ifdef FREECIV_JSON_CONNECTION
  struct plocation field_addr;
  {
    struct plocation *field_addr_tmp = plocation_field_new(NULL);
    field_addr = *field_addr_tmp;
    FC_FREE(field_addr_tmp);
  }
#endif /* FREECIV_JSON_CONNECTION */

  log_packet_detailed("packet_web_ruleset_unit_addition_100: sending info about (%d)",
    real_packet->id);

#ifdef FREECIV_DELTA_PROTOCOL
  if (NULL == *hash) {
    *hash = genhash_new_full(hash_packet_web_ruleset_unit_addition_100, cmp_packet_web_ruleset_unit_addition_100,
                             NULL, NULL, NULL, free);
  }
  BV_CLR_ALL(fields);

  if (!genhash_lookup(*hash, real_packet, (void **) &old)) {
    old = fc_malloc(sizeof(*old));
    *old = *real_packet;
    genhash_insert(*hash, old, old);
    memset(old, 0, sizeof(*old));
  }
  differ = !BV_ARE_EQUAL(old->utype_actions, real_packet->utype_actions);
  if (differ) {
    BV_SET(fields, 0);
  }


#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "fields";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_BV_PUT(&dout, &field_addr, fields);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);

  if (BV_ISSET(fields, 0)) {
    log_packet_detailed("  field 'utype_actions' has changed");
  #ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "utype_actions";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->utype_actions);
  }

  *old = *real_packet;
#endif /* FREECIV_DELTA_PROTOCOL */
#ifndef FREECIV_DELTA_PROTOCOL
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "id";
#endif /* FREECIV_JSON_CONNECTION */
  DIO_PUT(uint8, &dout, &field_addr, real_packet->id);
#ifdef FREECIV_JSON_CONNECTION
  field_addr.name = "utype_actions";
#endif /* FREECIV_JSON_CONNECTION */
DIO_BV_PUT(&dout, &field_addr, packet->utype_actions);

#endif
  SEND_PACKET_END(PACKET_WEB_RULESET_UNIT_ADDITION);
}

int send_packet_web_ruleset_unit_addition(struct connection *pc, const struct packet_web_ruleset_unit_addition *packet)
{
  if (!pc->used) {
    log_error("WARNING: trying to send data to the closed connection %s",
              conn_description(pc));
    return -1;
  }
  fc_assert_ret_val_msg(pc->phs.handlers->send[PACKET_WEB_RULESET_UNIT_ADDITION].packet != NULL, -1,
                        "Handler for PACKET_WEB_RULESET_UNIT_ADDITION not installed");
  return pc->phs.handlers->send[PACKET_WEB_RULESET_UNIT_ADDITION].packet(pc, packet);
}

void lsend_packet_web_ruleset_unit_addition(struct conn_list *dest, const struct packet_web_ruleset_unit_addition *packet)
{
  conn_list_iterate(dest, pconn) {
    send_packet_web_ruleset_unit_addition(pconn, packet);
  } conn_list_iterate_end;
}

void packet_handlers_fill_initial(struct packet_handlers *phandlers)
{
  fc_assert_msg(has_capability("ids32", our_capability),
                "Packets have support for unknown 'ids32' capability!");
  fc_assert_msg(has_capability("city-original", our_capability),
                "Packets have support for unknown 'city-original' capability!");
  fc_assert_msg(has_capability("rsdesc32", our_capability),
                "Packets have support for unknown 'rsdesc32' capability!");
  phandlers->send[PACKET_PLAYER_ATTRIBUTE_CHUNK].packet = (int(*)(struct connection *, const void *)) send_packet_player_attribute_chunk_100;
  phandlers->receive[PACKET_PLAYER_ATTRIBUTE_CHUNK] = (void *(*)(struct connection *)) receive_packet_player_attribute_chunk_100;
  phandlers->send[PACKET_EDIT_STARTPOS].packet = (int(*)(struct connection *, const void *)) send_packet_edit_startpos_100;
  phandlers->receive[PACKET_EDIT_STARTPOS] = (void *(*)(struct connection *)) receive_packet_edit_startpos_100;
  phandlers->send[PACKET_EDIT_STARTPOS_FULL].packet = (int(*)(struct connection *, const void *)) send_packet_edit_startpos_full_100;
  phandlers->receive[PACKET_EDIT_STARTPOS_FULL] = (void *(*)(struct connection *)) receive_packet_edit_startpos_full_100;
  if (is_server()) {
    phandlers->send[PACKET_PROCESSING_STARTED].no_packet = (int(*)(struct connection *)) send_packet_processing_started_100;
    phandlers->send[PACKET_PROCESSING_FINISHED].no_packet = (int(*)(struct connection *)) send_packet_processing_finished_100;
    phandlers->send[PACKET_SERVER_JOIN_REPLY].packet = (int(*)(struct connection *, const void *)) send_packet_server_join_reply_100;
    phandlers->send[PACKET_AUTHENTICATION_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_authentication_req_100;
    phandlers->send[PACKET_SERVER_SHUTDOWN].no_packet = (int(*)(struct connection *)) send_packet_server_shutdown_100;
    phandlers->send[PACKET_ENDGAME_REPORT].packet = (int(*)(struct connection *, const void *)) send_packet_endgame_report_100;
    phandlers->send[PACKET_ENDGAME_PLAYER].packet = (int(*)(struct connection *, const void *)) send_packet_endgame_player_100;
    phandlers->send[PACKET_GAME_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_game_info_100;
    phandlers->send[PACKET_CALENDAR_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_calendar_info_100;
    phandlers->send[PACKET_TIMEOUT_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_timeout_info_100;
    phandlers->send[PACKET_MAP_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_map_info_100;
    phandlers->send[PACKET_NUKE_TILE_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_nuke_tile_info_100;
    phandlers->send[PACKET_TEAM_NAME_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_team_name_info_100;
    phandlers->send[PACKET_ACHIEVEMENT_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_achievement_info_100;
    phandlers->send[PACKET_CHAT_MSG].packet = (int(*)(struct connection *, const void *)) send_packet_chat_msg_100;
    phandlers->send[PACKET_EARLY_CHAT_MSG].packet = (int(*)(struct connection *, const void *)) send_packet_early_chat_msg_100;
    phandlers->send[PACKET_CONNECT_MSG].packet = (int(*)(struct connection *, const void *)) send_packet_connect_msg_100;
    phandlers->send[PACKET_SERVER_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_server_info_100;
    phandlers->send[PACKET_PLAYER_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_player_remove_100;
    phandlers->send[PACKET_PLAYER_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_player_info_100;
    phandlers->send[PACKET_PLAYER_DIPLSTATE].packet = (int(*)(struct connection *, const void *)) send_packet_player_diplstate_100;
    phandlers->send[PACKET_RESEARCH_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_research_info_100;
    phandlers->send[PACKET_UNKNOWN_RESEARCH].packet = (int(*)(struct connection *, const void *)) send_packet_unknown_research_100;
    phandlers->send[PACKET_DIPLOMACY_INIT_MEETING].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_init_meeting_100;
    phandlers->send[PACKET_DIPLOMACY_CANCEL_MEETING].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_cancel_meeting_100;
    phandlers->send[PACKET_DIPLOMACY_CREATE_CLAUSE].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_create_clause_100;
    phandlers->send[PACKET_DIPLOMACY_REMOVE_CLAUSE].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_remove_clause_100;
    phandlers->send[PACKET_DIPLOMACY_ACCEPT_TREATY].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_accept_treaty_100;
    phandlers->send[PACKET_PAGE_MSG].packet = (int(*)(struct connection *, const void *)) send_packet_page_msg_100;
    phandlers->send[PACKET_PAGE_MSG_PART].packet = (int(*)(struct connection *, const void *)) send_packet_page_msg_part_100;
    phandlers->send[PACKET_CONN_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_conn_info_100;
    phandlers->send[PACKET_CONN_PING_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_conn_ping_info_100;
    phandlers->send[PACKET_CONN_PING].no_packet = (int(*)(struct connection *)) send_packet_conn_ping_100;
    phandlers->send[PACKET_END_PHASE].no_packet = (int(*)(struct connection *)) send_packet_end_phase_100;
    phandlers->send[PACKET_START_PHASE].packet = (int(*)(struct connection *, const void *)) send_packet_start_phase_100;
    phandlers->send[PACKET_NEW_YEAR].packet = (int(*)(struct connection *, const void *)) send_packet_new_year_100;
    phandlers->send[PACKET_BEGIN_TURN].no_packet = (int(*)(struct connection *)) send_packet_begin_turn_100;
    phandlers->send[PACKET_END_TURN].no_packet = (int(*)(struct connection *)) send_packet_end_turn_100;
    phandlers->send[PACKET_FREEZE_CLIENT].no_packet = (int(*)(struct connection *)) send_packet_freeze_client_100;
    phandlers->send[PACKET_THAW_CLIENT].no_packet = (int(*)(struct connection *)) send_packet_thaw_client_100;
    phandlers->send[PACKET_SPACESHIP_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_spaceship_info_100;
    phandlers->send[PACKET_RULESET_UNIT].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_unit_100;
    phandlers->send[PACKET_RULESET_UNIT_BONUS].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_unit_bonus_100;
    phandlers->send[PACKET_RULESET_UNIT_FLAG].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_unit_flag_100;
    phandlers->send[PACKET_RULESET_UNIT_CLASS_FLAG].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_unit_class_flag_100;
    phandlers->send[PACKET_RULESET_GAME].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_game_100;
    phandlers->send[PACKET_RULESET_SPECIALIST].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_specialist_100;
    phandlers->send[PACKET_RULESET_GOVERNMENT_RULER_TITLE].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_government_ruler_title_100;
    phandlers->send[PACKET_RULESET_TECH].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_tech_100;
    phandlers->send[PACKET_RULESET_TECH_CLASS].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_tech_class_100;
    phandlers->send[PACKET_RULESET_TECH_FLAG].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_tech_flag_100;
    phandlers->send[PACKET_RULESET_GOVERNMENT].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_government_100;
    phandlers->send[PACKET_RULESET_TERRAIN_CONTROL].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_terrain_control_100;
    phandlers->send[PACKET_RULESETS_READY].no_packet = (int(*)(struct connection *)) send_packet_rulesets_ready_100;
    phandlers->send[PACKET_RULESET_NATION_SETS].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_nation_sets_100;
    phandlers->send[PACKET_RULESET_NATION_GROUPS].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_nation_groups_100;
    phandlers->send[PACKET_RULESET_NATION].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_nation_100;
    phandlers->send[PACKET_NATION_AVAILABILITY].packet = (int(*)(struct connection *, const void *)) send_packet_nation_availability_100;
    phandlers->send[PACKET_RULESET_STYLE].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_style_100;
    phandlers->send[PACKET_RULESET_CITY].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_city_100;
    phandlers->send[PACKET_RULESET_BUILDING].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_building_100;
    phandlers->send[PACKET_RULESET_TERRAIN].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_terrain_100;
    phandlers->send[PACKET_RULESET_TERRAIN_FLAG].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_terrain_flag_100;
    phandlers->send[PACKET_RULESET_UNIT_CLASS].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_unit_class_100;
    phandlers->send[PACKET_RULESET_EXTRA].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_extra_100;
    phandlers->send[PACKET_RULESET_EXTRA_FLAG].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_extra_flag_100;
    phandlers->send[PACKET_RULESET_BASE].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_base_100;
    phandlers->send[PACKET_RULESET_ROAD].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_road_100;
    phandlers->send[PACKET_RULESET_GOODS].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_goods_100;
    phandlers->send[PACKET_RULESET_DISASTER].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_disaster_100;
    phandlers->send[PACKET_RULESET_ACHIEVEMENT].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_achievement_100;
    phandlers->send[PACKET_RULESET_TRADE].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_trade_100;
    phandlers->send[PACKET_RULESET_ACTION].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_action_100;
    phandlers->send[PACKET_RULESET_ACTION_ENABLER].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_action_enabler_100;
    phandlers->send[PACKET_RULESET_ACTION_AUTO].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_action_auto_100;
    phandlers->send[PACKET_RULESET_MUSIC].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_music_100;
    phandlers->send[PACKET_RULESET_MULTIPLIER].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_multiplier_100;
    phandlers->send[PACKET_RULESET_CLAUSE].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_clause_100;
    phandlers->send[PACKET_RULESET_SUMMARY].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_summary_100;
    phandlers->send[PACKET_RULESET_DESCRIPTION_PART].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_description_part_100;
    phandlers->send[PACKET_SINGLE_WANT_HACK_REPLY].packet = (int(*)(struct connection *, const void *)) send_packet_single_want_hack_reply_100;
    phandlers->send[PACKET_RULESET_CHOICES].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_choices_100;
    phandlers->send[PACKET_GAME_LOAD].packet = (int(*)(struct connection *, const void *)) send_packet_game_load_100;
    phandlers->send[PACKET_SERVER_SETTING_CONTROL].packet = (int(*)(struct connection *, const void *)) send_packet_server_setting_control_100;
    phandlers->send[PACKET_SERVER_SETTING_CONST].packet = (int(*)(struct connection *, const void *)) send_packet_server_setting_const_100;
    phandlers->send[PACKET_SERVER_SETTING_BOOL].packet = (int(*)(struct connection *, const void *)) send_packet_server_setting_bool_100;
    phandlers->send[PACKET_SERVER_SETTING_INT].packet = (int(*)(struct connection *, const void *)) send_packet_server_setting_int_100;
    phandlers->send[PACKET_SERVER_SETTING_STR].packet = (int(*)(struct connection *, const void *)) send_packet_server_setting_str_100;
    phandlers->send[PACKET_SERVER_SETTING_ENUM].packet = (int(*)(struct connection *, const void *)) send_packet_server_setting_enum_100;
    phandlers->send[PACKET_SERVER_SETTING_BITWISE].packet = (int(*)(struct connection *, const void *)) send_packet_server_setting_bitwise_100;
    phandlers->send[PACKET_SET_TOPOLOGY].packet = (int(*)(struct connection *, const void *)) send_packet_set_topology_100;
    phandlers->send[PACKET_RULESET_EFFECT].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_effect_100;
    phandlers->send[PACKET_RULESET_RESOURCE].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_resource_100;
    phandlers->send[PACKET_SCENARIO_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_scenario_info_100;
    phandlers->send[PACKET_SCENARIO_DESCRIPTION].packet = (int(*)(struct connection *, const void *)) send_packet_scenario_description_100;
    phandlers->send[PACKET_VOTE_NEW].packet = (int(*)(struct connection *, const void *)) send_packet_vote_new_100;
    phandlers->send[PACKET_VOTE_UPDATE].packet = (int(*)(struct connection *, const void *)) send_packet_vote_update_100;
    phandlers->send[PACKET_VOTE_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_vote_remove_100;
    phandlers->send[PACKET_VOTE_RESOLVE].packet = (int(*)(struct connection *, const void *)) send_packet_vote_resolve_100;
    phandlers->send[PACKET_EDIT_OBJECT_CREATED].packet = (int(*)(struct connection *, const void *)) send_packet_edit_object_created_100;
    phandlers->send[PACKET_PLAY_MUSIC].packet = (int(*)(struct connection *, const void *)) send_packet_play_music_100;
    phandlers->send[PACKET_WEB_PLAYER_INFO_ADDITION].packet = (int(*)(struct connection *, const void *)) send_packet_web_player_info_addition_100;
    phandlers->send[PACKET_WEB_RULESET_UNIT_ADDITION].packet = (int(*)(struct connection *, const void *)) send_packet_web_ruleset_unit_addition_100;
    phandlers->receive[PACKET_SERVER_JOIN_REQ] = (void *(*)(struct connection *)) receive_packet_server_join_req_100;
    phandlers->receive[PACKET_AUTHENTICATION_REPLY] = (void *(*)(struct connection *)) receive_packet_authentication_reply_100;
    phandlers->receive[PACKET_NATION_SELECT_REQ] = (void *(*)(struct connection *)) receive_packet_nation_select_req_100;
    phandlers->receive[PACKET_PLAYER_READY] = (void *(*)(struct connection *)) receive_packet_player_ready_100;
    phandlers->receive[PACKET_CHAT_MSG_REQ] = (void *(*)(struct connection *)) receive_packet_chat_msg_req_100;
    phandlers->receive[PACKET_PLAYER_PHASE_DONE] = (void *(*)(struct connection *)) receive_packet_player_phase_done_100;
    phandlers->receive[PACKET_PLAYER_RATES] = (void *(*)(struct connection *)) receive_packet_player_rates_100;
    phandlers->receive[PACKET_PLAYER_CHANGE_GOVERNMENT] = (void *(*)(struct connection *)) receive_packet_player_change_government_100;
    phandlers->receive[PACKET_PLAYER_PLACE_INFRA] = (void *(*)(struct connection *)) receive_packet_player_place_infra_100;
    phandlers->receive[PACKET_PLAYER_ATTRIBUTE_BLOCK] = (void *(*)(struct connection *)) receive_packet_player_attribute_block_100;
    phandlers->receive[PACKET_PLAYER_MULTIPLIER] = (void *(*)(struct connection *)) receive_packet_player_multiplier_100;
    phandlers->receive[PACKET_PLAYER_RESEARCH] = (void *(*)(struct connection *)) receive_packet_player_research_100;
    phandlers->receive[PACKET_PLAYER_TECH_GOAL] = (void *(*)(struct connection *)) receive_packet_player_tech_goal_100;
    phandlers->receive[PACKET_UNIT_TYPE_UPGRADE] = (void *(*)(struct connection *)) receive_packet_unit_type_upgrade_100;
    phandlers->receive[PACKET_DIPLOMACY_INIT_MEETING_REQ] = (void *(*)(struct connection *)) receive_packet_diplomacy_init_meeting_req_100;
    phandlers->receive[PACKET_DIPLOMACY_CANCEL_MEETING_REQ] = (void *(*)(struct connection *)) receive_packet_diplomacy_cancel_meeting_req_100;
    phandlers->receive[PACKET_DIPLOMACY_CREATE_CLAUSE_REQ] = (void *(*)(struct connection *)) receive_packet_diplomacy_create_clause_req_100;
    phandlers->receive[PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ] = (void *(*)(struct connection *)) receive_packet_diplomacy_remove_clause_req_100;
    phandlers->receive[PACKET_DIPLOMACY_ACCEPT_TREATY_REQ] = (void *(*)(struct connection *)) receive_packet_diplomacy_accept_treaty_req_100;
    phandlers->receive[PACKET_DIPLOMACY_CANCEL_PACT] = (void *(*)(struct connection *)) receive_packet_diplomacy_cancel_pact_100;
    phandlers->receive[PACKET_REPORT_REQ] = (void *(*)(struct connection *)) receive_packet_report_req_100;
    phandlers->receive[PACKET_CONN_PONG] = (void *(*)(struct connection *)) receive_packet_conn_pong_100;
    phandlers->receive[PACKET_CLIENT_HEARTBEAT] = (void *(*)(struct connection *)) receive_packet_client_heartbeat_100;
    phandlers->receive[PACKET_CLIENT_INFO] = (void *(*)(struct connection *)) receive_packet_client_info_100;
    phandlers->receive[PACKET_SPACESHIP_LAUNCH] = (void *(*)(struct connection *)) receive_packet_spaceship_launch_100;
    phandlers->receive[PACKET_SPACESHIP_PLACE] = (void *(*)(struct connection *)) receive_packet_spaceship_place_100;
    phandlers->receive[PACKET_SINGLE_WANT_HACK_REQ] = (void *(*)(struct connection *)) receive_packet_single_want_hack_req_100;
    phandlers->receive[PACKET_SAVE_SCENARIO] = (void *(*)(struct connection *)) receive_packet_save_scenario_100;
    phandlers->receive[PACKET_VOTE_SUBMIT] = (void *(*)(struct connection *)) receive_packet_vote_submit_100;
    phandlers->receive[PACKET_EDIT_MODE] = (void *(*)(struct connection *)) receive_packet_edit_mode_100;
    phandlers->receive[PACKET_EDIT_RECALCULATE_BORDERS] = (void *(*)(struct connection *)) receive_packet_edit_recalculate_borders_100;
    phandlers->receive[PACKET_EDIT_CHECK_TILES] = (void *(*)(struct connection *)) receive_packet_edit_check_tiles_100;
    phandlers->receive[PACKET_EDIT_TOGGLE_FOGOFWAR] = (void *(*)(struct connection *)) receive_packet_edit_toggle_fogofwar_100;
    phandlers->receive[PACKET_EDIT_TILE_TERRAIN] = (void *(*)(struct connection *)) receive_packet_edit_tile_terrain_100;
    phandlers->receive[PACKET_EDIT_TILE_EXTRA] = (void *(*)(struct connection *)) receive_packet_edit_tile_extra_100;
    phandlers->receive[PACKET_EDIT_TILE] = (void *(*)(struct connection *)) receive_packet_edit_tile_100;
    phandlers->receive[PACKET_EDIT_UNIT_CREATE] = (void *(*)(struct connection *)) receive_packet_edit_unit_create_100;
    phandlers->receive[PACKET_EDIT_UNIT_REMOVE] = (void *(*)(struct connection *)) receive_packet_edit_unit_remove_100;
    phandlers->receive[PACKET_EDIT_CITY_CREATE] = (void *(*)(struct connection *)) receive_packet_edit_city_create_100;
    phandlers->receive[PACKET_EDIT_PLAYER_CREATE] = (void *(*)(struct connection *)) receive_packet_edit_player_create_100;
    phandlers->receive[PACKET_EDIT_PLAYER_REMOVE] = (void *(*)(struct connection *)) receive_packet_edit_player_remove_100;
    phandlers->receive[PACKET_EDIT_PLAYER] = (void *(*)(struct connection *)) receive_packet_edit_player_100;
    phandlers->receive[PACKET_EDIT_PLAYER_VISION] = (void *(*)(struct connection *)) receive_packet_edit_player_vision_100;
    phandlers->receive[PACKET_EDIT_GAME] = (void *(*)(struct connection *)) receive_packet_edit_game_100;
    phandlers->receive[PACKET_EDIT_SCENARIO_DESC] = (void *(*)(struct connection *)) receive_packet_edit_scenario_desc_100;
  } else {
    phandlers->send[PACKET_SERVER_JOIN_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_server_join_req_100;
    phandlers->send[PACKET_AUTHENTICATION_REPLY].packet = (int(*)(struct connection *, const void *)) send_packet_authentication_reply_100;
    phandlers->send[PACKET_NATION_SELECT_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_nation_select_req_100;
    phandlers->send[PACKET_PLAYER_READY].packet = (int(*)(struct connection *, const void *)) send_packet_player_ready_100;
    phandlers->send[PACKET_CHAT_MSG_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_chat_msg_req_100;
    phandlers->send[PACKET_PLAYER_PHASE_DONE].packet = (int(*)(struct connection *, const void *)) send_packet_player_phase_done_100;
    phandlers->send[PACKET_PLAYER_RATES].packet = (int(*)(struct connection *, const void *)) send_packet_player_rates_100;
    phandlers->send[PACKET_PLAYER_CHANGE_GOVERNMENT].packet = (int(*)(struct connection *, const void *)) send_packet_player_change_government_100;
    phandlers->send[PACKET_PLAYER_PLACE_INFRA].packet = (int(*)(struct connection *, const void *)) send_packet_player_place_infra_100;
    phandlers->send[PACKET_PLAYER_ATTRIBUTE_BLOCK].no_packet = (int(*)(struct connection *)) send_packet_player_attribute_block_100;
    phandlers->send[PACKET_PLAYER_MULTIPLIER].packet = (int(*)(struct connection *, const void *)) send_packet_player_multiplier_100;
    phandlers->send[PACKET_PLAYER_RESEARCH].packet = (int(*)(struct connection *, const void *)) send_packet_player_research_100;
    phandlers->send[PACKET_PLAYER_TECH_GOAL].packet = (int(*)(struct connection *, const void *)) send_packet_player_tech_goal_100;
    phandlers->send[PACKET_UNIT_TYPE_UPGRADE].packet = (int(*)(struct connection *, const void *)) send_packet_unit_type_upgrade_100;
    phandlers->send[PACKET_DIPLOMACY_INIT_MEETING_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_init_meeting_req_100;
    phandlers->send[PACKET_DIPLOMACY_CANCEL_MEETING_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_cancel_meeting_req_100;
    phandlers->send[PACKET_DIPLOMACY_CREATE_CLAUSE_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_create_clause_req_100;
    phandlers->send[PACKET_DIPLOMACY_REMOVE_CLAUSE_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_remove_clause_req_100;
    phandlers->send[PACKET_DIPLOMACY_ACCEPT_TREATY_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_accept_treaty_req_100;
    phandlers->send[PACKET_DIPLOMACY_CANCEL_PACT].packet = (int(*)(struct connection *, const void *)) send_packet_diplomacy_cancel_pact_100;
    phandlers->send[PACKET_REPORT_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_report_req_100;
    phandlers->send[PACKET_CONN_PONG].no_packet = (int(*)(struct connection *)) send_packet_conn_pong_100;
    phandlers->send[PACKET_CLIENT_HEARTBEAT].no_packet = (int(*)(struct connection *)) send_packet_client_heartbeat_100;
    phandlers->send[PACKET_CLIENT_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_client_info_100;
    phandlers->send[PACKET_SPACESHIP_LAUNCH].no_packet = (int(*)(struct connection *)) send_packet_spaceship_launch_100;
    phandlers->send[PACKET_SPACESHIP_PLACE].packet = (int(*)(struct connection *, const void *)) send_packet_spaceship_place_100;
    phandlers->send[PACKET_SINGLE_WANT_HACK_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_single_want_hack_req_100;
    phandlers->send[PACKET_SAVE_SCENARIO].packet = (int(*)(struct connection *, const void *)) send_packet_save_scenario_100;
    phandlers->send[PACKET_VOTE_SUBMIT].packet = (int(*)(struct connection *, const void *)) send_packet_vote_submit_100;
    phandlers->send[PACKET_EDIT_MODE].packet = (int(*)(struct connection *, const void *)) send_packet_edit_mode_100;
    phandlers->send[PACKET_EDIT_RECALCULATE_BORDERS].no_packet = (int(*)(struct connection *)) send_packet_edit_recalculate_borders_100;
    phandlers->send[PACKET_EDIT_CHECK_TILES].no_packet = (int(*)(struct connection *)) send_packet_edit_check_tiles_100;
    phandlers->send[PACKET_EDIT_TOGGLE_FOGOFWAR].packet = (int(*)(struct connection *, const void *)) send_packet_edit_toggle_fogofwar_100;
    phandlers->send[PACKET_EDIT_TILE_TERRAIN].packet = (int(*)(struct connection *, const void *)) send_packet_edit_tile_terrain_100;
    phandlers->send[PACKET_EDIT_TILE_EXTRA].packet = (int(*)(struct connection *, const void *)) send_packet_edit_tile_extra_100;
    phandlers->send[PACKET_EDIT_TILE].packet = (int(*)(struct connection *, const void *)) send_packet_edit_tile_100;
    phandlers->send[PACKET_EDIT_UNIT_CREATE].packet = (int(*)(struct connection *, const void *)) send_packet_edit_unit_create_100;
    phandlers->send[PACKET_EDIT_UNIT_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_edit_unit_remove_100;
    phandlers->send[PACKET_EDIT_CITY_CREATE].packet = (int(*)(struct connection *, const void *)) send_packet_edit_city_create_100;
    phandlers->send[PACKET_EDIT_PLAYER_CREATE].packet = (int(*)(struct connection *, const void *)) send_packet_edit_player_create_100;
    phandlers->send[PACKET_EDIT_PLAYER_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_edit_player_remove_100;
    phandlers->send[PACKET_EDIT_PLAYER].packet = (int(*)(struct connection *, const void *)) send_packet_edit_player_100;
    phandlers->send[PACKET_EDIT_PLAYER_VISION].packet = (int(*)(struct connection *, const void *)) send_packet_edit_player_vision_100;
    phandlers->send[PACKET_EDIT_GAME].packet = (int(*)(struct connection *, const void *)) send_packet_edit_game_100;
    phandlers->send[PACKET_EDIT_SCENARIO_DESC].packet = (int(*)(struct connection *, const void *)) send_packet_edit_scenario_desc_100;
    phandlers->receive[PACKET_PROCESSING_STARTED] = (void *(*)(struct connection *)) receive_packet_processing_started_100;
    phandlers->receive[PACKET_PROCESSING_FINISHED] = (void *(*)(struct connection *)) receive_packet_processing_finished_100;
    phandlers->receive[PACKET_SERVER_JOIN_REPLY] = (void *(*)(struct connection *)) receive_packet_server_join_reply_100;
    phandlers->receive[PACKET_AUTHENTICATION_REQ] = (void *(*)(struct connection *)) receive_packet_authentication_req_100;
    phandlers->receive[PACKET_SERVER_SHUTDOWN] = (void *(*)(struct connection *)) receive_packet_server_shutdown_100;
    phandlers->receive[PACKET_ENDGAME_REPORT] = (void *(*)(struct connection *)) receive_packet_endgame_report_100;
    phandlers->receive[PACKET_ENDGAME_PLAYER] = (void *(*)(struct connection *)) receive_packet_endgame_player_100;
    phandlers->receive[PACKET_GAME_INFO] = (void *(*)(struct connection *)) receive_packet_game_info_100;
    phandlers->receive[PACKET_CALENDAR_INFO] = (void *(*)(struct connection *)) receive_packet_calendar_info_100;
    phandlers->receive[PACKET_TIMEOUT_INFO] = (void *(*)(struct connection *)) receive_packet_timeout_info_100;
    phandlers->receive[PACKET_MAP_INFO] = (void *(*)(struct connection *)) receive_packet_map_info_100;
    phandlers->receive[PACKET_NUKE_TILE_INFO] = (void *(*)(struct connection *)) receive_packet_nuke_tile_info_100;
    phandlers->receive[PACKET_TEAM_NAME_INFO] = (void *(*)(struct connection *)) receive_packet_team_name_info_100;
    phandlers->receive[PACKET_ACHIEVEMENT_INFO] = (void *(*)(struct connection *)) receive_packet_achievement_info_100;
    phandlers->receive[PACKET_CHAT_MSG] = (void *(*)(struct connection *)) receive_packet_chat_msg_100;
    phandlers->receive[PACKET_EARLY_CHAT_MSG] = (void *(*)(struct connection *)) receive_packet_early_chat_msg_100;
    phandlers->receive[PACKET_CONNECT_MSG] = (void *(*)(struct connection *)) receive_packet_connect_msg_100;
    phandlers->receive[PACKET_SERVER_INFO] = (void *(*)(struct connection *)) receive_packet_server_info_100;
    phandlers->receive[PACKET_PLAYER_REMOVE] = (void *(*)(struct connection *)) receive_packet_player_remove_100;
    phandlers->receive[PACKET_PLAYER_INFO] = (void *(*)(struct connection *)) receive_packet_player_info_100;
    phandlers->receive[PACKET_PLAYER_DIPLSTATE] = (void *(*)(struct connection *)) receive_packet_player_diplstate_100;
    phandlers->receive[PACKET_RESEARCH_INFO] = (void *(*)(struct connection *)) receive_packet_research_info_100;
    phandlers->receive[PACKET_UNKNOWN_RESEARCH] = (void *(*)(struct connection *)) receive_packet_unknown_research_100;
    phandlers->receive[PACKET_DIPLOMACY_INIT_MEETING] = (void *(*)(struct connection *)) receive_packet_diplomacy_init_meeting_100;
    phandlers->receive[PACKET_DIPLOMACY_CANCEL_MEETING] = (void *(*)(struct connection *)) receive_packet_diplomacy_cancel_meeting_100;
    phandlers->receive[PACKET_DIPLOMACY_CREATE_CLAUSE] = (void *(*)(struct connection *)) receive_packet_diplomacy_create_clause_100;
    phandlers->receive[PACKET_DIPLOMACY_REMOVE_CLAUSE] = (void *(*)(struct connection *)) receive_packet_diplomacy_remove_clause_100;
    phandlers->receive[PACKET_DIPLOMACY_ACCEPT_TREATY] = (void *(*)(struct connection *)) receive_packet_diplomacy_accept_treaty_100;
    phandlers->receive[PACKET_PAGE_MSG] = (void *(*)(struct connection *)) receive_packet_page_msg_100;
    phandlers->receive[PACKET_PAGE_MSG_PART] = (void *(*)(struct connection *)) receive_packet_page_msg_part_100;
    phandlers->receive[PACKET_CONN_INFO] = (void *(*)(struct connection *)) receive_packet_conn_info_100;
    phandlers->receive[PACKET_CONN_PING_INFO] = (void *(*)(struct connection *)) receive_packet_conn_ping_info_100;
    phandlers->receive[PACKET_CONN_PING] = (void *(*)(struct connection *)) receive_packet_conn_ping_100;
    phandlers->receive[PACKET_END_PHASE] = (void *(*)(struct connection *)) receive_packet_end_phase_100;
    phandlers->receive[PACKET_START_PHASE] = (void *(*)(struct connection *)) receive_packet_start_phase_100;
    phandlers->receive[PACKET_NEW_YEAR] = (void *(*)(struct connection *)) receive_packet_new_year_100;
    phandlers->receive[PACKET_BEGIN_TURN] = (void *(*)(struct connection *)) receive_packet_begin_turn_100;
    phandlers->receive[PACKET_END_TURN] = (void *(*)(struct connection *)) receive_packet_end_turn_100;
    phandlers->receive[PACKET_FREEZE_CLIENT] = (void *(*)(struct connection *)) receive_packet_freeze_client_100;
    phandlers->receive[PACKET_THAW_CLIENT] = (void *(*)(struct connection *)) receive_packet_thaw_client_100;
    phandlers->receive[PACKET_SPACESHIP_INFO] = (void *(*)(struct connection *)) receive_packet_spaceship_info_100;
    phandlers->receive[PACKET_RULESET_UNIT] = (void *(*)(struct connection *)) receive_packet_ruleset_unit_100;
    phandlers->receive[PACKET_RULESET_UNIT_BONUS] = (void *(*)(struct connection *)) receive_packet_ruleset_unit_bonus_100;
    phandlers->receive[PACKET_RULESET_UNIT_FLAG] = (void *(*)(struct connection *)) receive_packet_ruleset_unit_flag_100;
    phandlers->receive[PACKET_RULESET_UNIT_CLASS_FLAG] = (void *(*)(struct connection *)) receive_packet_ruleset_unit_class_flag_100;
    phandlers->receive[PACKET_RULESET_GAME] = (void *(*)(struct connection *)) receive_packet_ruleset_game_100;
    phandlers->receive[PACKET_RULESET_SPECIALIST] = (void *(*)(struct connection *)) receive_packet_ruleset_specialist_100;
    phandlers->receive[PACKET_RULESET_GOVERNMENT_RULER_TITLE] = (void *(*)(struct connection *)) receive_packet_ruleset_government_ruler_title_100;
    phandlers->receive[PACKET_RULESET_TECH] = (void *(*)(struct connection *)) receive_packet_ruleset_tech_100;
    phandlers->receive[PACKET_RULESET_TECH_CLASS] = (void *(*)(struct connection *)) receive_packet_ruleset_tech_class_100;
    phandlers->receive[PACKET_RULESET_TECH_FLAG] = (void *(*)(struct connection *)) receive_packet_ruleset_tech_flag_100;
    phandlers->receive[PACKET_RULESET_GOVERNMENT] = (void *(*)(struct connection *)) receive_packet_ruleset_government_100;
    phandlers->receive[PACKET_RULESET_TERRAIN_CONTROL] = (void *(*)(struct connection *)) receive_packet_ruleset_terrain_control_100;
    phandlers->receive[PACKET_RULESETS_READY] = (void *(*)(struct connection *)) receive_packet_rulesets_ready_100;
    phandlers->receive[PACKET_RULESET_NATION_SETS] = (void *(*)(struct connection *)) receive_packet_ruleset_nation_sets_100;
    phandlers->receive[PACKET_RULESET_NATION_GROUPS] = (void *(*)(struct connection *)) receive_packet_ruleset_nation_groups_100;
    phandlers->receive[PACKET_RULESET_NATION] = (void *(*)(struct connection *)) receive_packet_ruleset_nation_100;
    phandlers->receive[PACKET_NATION_AVAILABILITY] = (void *(*)(struct connection *)) receive_packet_nation_availability_100;
    phandlers->receive[PACKET_RULESET_STYLE] = (void *(*)(struct connection *)) receive_packet_ruleset_style_100;
    phandlers->receive[PACKET_RULESET_CITY] = (void *(*)(struct connection *)) receive_packet_ruleset_city_100;
    phandlers->receive[PACKET_RULESET_BUILDING] = (void *(*)(struct connection *)) receive_packet_ruleset_building_100;
    phandlers->receive[PACKET_RULESET_TERRAIN] = (void *(*)(struct connection *)) receive_packet_ruleset_terrain_100;
    phandlers->receive[PACKET_RULESET_TERRAIN_FLAG] = (void *(*)(struct connection *)) receive_packet_ruleset_terrain_flag_100;
    phandlers->receive[PACKET_RULESET_UNIT_CLASS] = (void *(*)(struct connection *)) receive_packet_ruleset_unit_class_100;
    phandlers->receive[PACKET_RULESET_EXTRA] = (void *(*)(struct connection *)) receive_packet_ruleset_extra_100;
    phandlers->receive[PACKET_RULESET_EXTRA_FLAG] = (void *(*)(struct connection *)) receive_packet_ruleset_extra_flag_100;
    phandlers->receive[PACKET_RULESET_BASE] = (void *(*)(struct connection *)) receive_packet_ruleset_base_100;
    phandlers->receive[PACKET_RULESET_ROAD] = (void *(*)(struct connection *)) receive_packet_ruleset_road_100;
    phandlers->receive[PACKET_RULESET_GOODS] = (void *(*)(struct connection *)) receive_packet_ruleset_goods_100;
    phandlers->receive[PACKET_RULESET_DISASTER] = (void *(*)(struct connection *)) receive_packet_ruleset_disaster_100;
    phandlers->receive[PACKET_RULESET_ACHIEVEMENT] = (void *(*)(struct connection *)) receive_packet_ruleset_achievement_100;
    phandlers->receive[PACKET_RULESET_TRADE] = (void *(*)(struct connection *)) receive_packet_ruleset_trade_100;
    phandlers->receive[PACKET_RULESET_ACTION] = (void *(*)(struct connection *)) receive_packet_ruleset_action_100;
    phandlers->receive[PACKET_RULESET_ACTION_ENABLER] = (void *(*)(struct connection *)) receive_packet_ruleset_action_enabler_100;
    phandlers->receive[PACKET_RULESET_ACTION_AUTO] = (void *(*)(struct connection *)) receive_packet_ruleset_action_auto_100;
    phandlers->receive[PACKET_RULESET_MUSIC] = (void *(*)(struct connection *)) receive_packet_ruleset_music_100;
    phandlers->receive[PACKET_RULESET_MULTIPLIER] = (void *(*)(struct connection *)) receive_packet_ruleset_multiplier_100;
    phandlers->receive[PACKET_RULESET_CLAUSE] = (void *(*)(struct connection *)) receive_packet_ruleset_clause_100;
    phandlers->receive[PACKET_RULESET_SUMMARY] = (void *(*)(struct connection *)) receive_packet_ruleset_summary_100;
    phandlers->receive[PACKET_RULESET_DESCRIPTION_PART] = (void *(*)(struct connection *)) receive_packet_ruleset_description_part_100;
    phandlers->receive[PACKET_SINGLE_WANT_HACK_REPLY] = (void *(*)(struct connection *)) receive_packet_single_want_hack_reply_100;
    phandlers->receive[PACKET_RULESET_CHOICES] = (void *(*)(struct connection *)) receive_packet_ruleset_choices_100;
    phandlers->receive[PACKET_GAME_LOAD] = (void *(*)(struct connection *)) receive_packet_game_load_100;
    phandlers->receive[PACKET_SERVER_SETTING_CONTROL] = (void *(*)(struct connection *)) receive_packet_server_setting_control_100;
    phandlers->receive[PACKET_SERVER_SETTING_CONST] = (void *(*)(struct connection *)) receive_packet_server_setting_const_100;
    phandlers->receive[PACKET_SERVER_SETTING_BOOL] = (void *(*)(struct connection *)) receive_packet_server_setting_bool_100;
    phandlers->receive[PACKET_SERVER_SETTING_INT] = (void *(*)(struct connection *)) receive_packet_server_setting_int_100;
    phandlers->receive[PACKET_SERVER_SETTING_STR] = (void *(*)(struct connection *)) receive_packet_server_setting_str_100;
    phandlers->receive[PACKET_SERVER_SETTING_ENUM] = (void *(*)(struct connection *)) receive_packet_server_setting_enum_100;
    phandlers->receive[PACKET_SERVER_SETTING_BITWISE] = (void *(*)(struct connection *)) receive_packet_server_setting_bitwise_100;
    phandlers->receive[PACKET_SET_TOPOLOGY] = (void *(*)(struct connection *)) receive_packet_set_topology_100;
    phandlers->receive[PACKET_RULESET_EFFECT] = (void *(*)(struct connection *)) receive_packet_ruleset_effect_100;
    phandlers->receive[PACKET_RULESET_RESOURCE] = (void *(*)(struct connection *)) receive_packet_ruleset_resource_100;
    phandlers->receive[PACKET_SCENARIO_INFO] = (void *(*)(struct connection *)) receive_packet_scenario_info_100;
    phandlers->receive[PACKET_SCENARIO_DESCRIPTION] = (void *(*)(struct connection *)) receive_packet_scenario_description_100;
    phandlers->receive[PACKET_VOTE_NEW] = (void *(*)(struct connection *)) receive_packet_vote_new_100;
    phandlers->receive[PACKET_VOTE_UPDATE] = (void *(*)(struct connection *)) receive_packet_vote_update_100;
    phandlers->receive[PACKET_VOTE_REMOVE] = (void *(*)(struct connection *)) receive_packet_vote_remove_100;
    phandlers->receive[PACKET_VOTE_RESOLVE] = (void *(*)(struct connection *)) receive_packet_vote_resolve_100;
    phandlers->receive[PACKET_EDIT_OBJECT_CREATED] = (void *(*)(struct connection *)) receive_packet_edit_object_created_100;
    phandlers->receive[PACKET_PLAY_MUSIC] = (void *(*)(struct connection *)) receive_packet_play_music_100;
    phandlers->receive[PACKET_WEB_PLAYER_INFO_ADDITION] = (void *(*)(struct connection *)) receive_packet_web_player_info_addition_100;
    phandlers->receive[PACKET_WEB_RULESET_UNIT_ADDITION] = (void *(*)(struct connection *)) receive_packet_web_ruleset_unit_addition_100;
  }
}

void packet_handlers_fill_capability(struct packet_handlers *phandlers,
                                     const char *capability)
{
  if (has_capability("ids32", capability)) {
    log_packet_detailed("PACKET_CITY_RALLY_POINT: using variant=100 cap=%s", capability);
    phandlers->send[PACKET_CITY_RALLY_POINT].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_city_rally_point_100;
    phandlers->receive[PACKET_CITY_RALLY_POINT] = (void *(*)(struct connection *)) receive_packet_city_rally_point_100;
  } else if (!has_capability("ids32", capability)) {
    log_packet_detailed("PACKET_CITY_RALLY_POINT: using variant=101 cap=%s", capability);
    phandlers->send[PACKET_CITY_RALLY_POINT].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_city_rally_point_101;
    phandlers->receive[PACKET_CITY_RALLY_POINT] = (void *(*)(struct connection *)) receive_packet_city_rally_point_101;
  } else {
    log_error("Unknown PACKET_CITY_RALLY_POINT variant for cap %s", capability);
  }
  if (has_capability("ids32", capability)) {
    log_packet_detailed("PACKET_WORKER_TASK: using variant=100 cap=%s", capability);
    phandlers->send[PACKET_WORKER_TASK].packet = (int(*)(struct connection *, const void *)) send_packet_worker_task_100;
    phandlers->receive[PACKET_WORKER_TASK] = (void *(*)(struct connection *)) receive_packet_worker_task_100;
  } else if (!has_capability("ids32", capability)) {
    log_packet_detailed("PACKET_WORKER_TASK: using variant=101 cap=%s", capability);
    phandlers->send[PACKET_WORKER_TASK].packet = (int(*)(struct connection *, const void *)) send_packet_worker_task_101;
    phandlers->receive[PACKET_WORKER_TASK] = (void *(*)(struct connection *)) receive_packet_worker_task_101;
  } else {
    log_error("Unknown PACKET_WORKER_TASK variant for cap %s", capability);
  }
  if (is_server()) {
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_INVESTIGATE_STARTED: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_INVESTIGATE_STARTED].packet = (int(*)(struct connection *, const void *)) send_packet_investigate_started_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_INVESTIGATE_STARTED: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_INVESTIGATE_STARTED].packet = (int(*)(struct connection *, const void *)) send_packet_investigate_started_101;
    } else {
      log_error("Unknown PACKET_INVESTIGATE_STARTED variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_INVESTIGATE_FINISHED: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_INVESTIGATE_FINISHED].packet = (int(*)(struct connection *, const void *)) send_packet_investigate_finished_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_INVESTIGATE_FINISHED: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_INVESTIGATE_FINISHED].packet = (int(*)(struct connection *, const void *)) send_packet_investigate_finished_101;
    } else {
      log_error("Unknown PACKET_INVESTIGATE_FINISHED variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_TILE_INFO: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_TILE_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_tile_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_TILE_INFO: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_TILE_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_tile_info_101;
    } else {
      log_error("Unknown PACKET_TILE_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_REMOVE: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_city_remove_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_REMOVE: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_city_remove_101;
    } else {
      log_error("Unknown PACKET_CITY_REMOVE variant for cap %s", capability);
    }
    if (has_capability("ids32", capability) && has_capability("city-original", capability)) {
      log_packet_detailed("PACKET_CITY_INFO: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_INFO].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_city_info_100;
    } else if (has_capability("ids32", capability) && !has_capability("city-original", capability)) {
      log_packet_detailed("PACKET_CITY_INFO: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_INFO].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_city_info_101;
    } else if (has_capability("city-original", capability) && !has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_INFO: using variant=102 cap=%s", capability);
      phandlers->send[PACKET_CITY_INFO].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_city_info_102;
    } else if (!has_capability("ids32", capability) && !has_capability("city-original", capability)) {
      log_packet_detailed("PACKET_CITY_INFO: using variant=103 cap=%s", capability);
      phandlers->send[PACKET_CITY_INFO].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_city_info_103;
    } else {
      log_error("Unknown PACKET_CITY_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NATIONALITIES: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_NATIONALITIES].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_city_nationalities_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NATIONALITIES: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_NATIONALITIES].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_city_nationalities_101;
    } else {
      log_error("Unknown PACKET_CITY_NATIONALITIES variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SHORT_INFO: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_SHORT_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_city_short_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SHORT_INFO: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_SHORT_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_city_short_info_101;
    } else {
      log_error("Unknown PACKET_CITY_SHORT_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_TRADE_ROUTE_INFO: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_TRADE_ROUTE_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_trade_route_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_TRADE_ROUTE_INFO: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_TRADE_ROUTE_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_trade_route_info_101;
    } else {
      log_error("Unknown PACKET_TRADE_ROUTE_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NAME_SUGGESTION_INFO: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_NAME_SUGGESTION_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_city_name_suggestion_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NAME_SUGGESTION_INFO: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_NAME_SUGGESTION_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_city_name_suggestion_info_101;
    } else {
      log_error("Unknown PACKET_CITY_NAME_SUGGESTION_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SABOTAGE_LIST: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_SABOTAGE_LIST].packet = (int(*)(struct connection *, const void *)) send_packet_city_sabotage_list_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SABOTAGE_LIST: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_SABOTAGE_LIST].packet = (int(*)(struct connection *, const void *)) send_packet_city_sabotage_list_101;
    } else {
      log_error("Unknown PACKET_CITY_SABOTAGE_LIST variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_REMOVE: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_unit_remove_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_REMOVE: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_unit_remove_101;
    } else {
      log_error("Unknown PACKET_UNIT_REMOVE variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_INFO: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_unit_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_INFO: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_unit_info_101;
    } else {
      log_error("Unknown PACKET_UNIT_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SHORT_INFO: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_SHORT_INFO].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_unit_short_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SHORT_INFO: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_SHORT_INFO].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_unit_short_info_101;
    } else {
      log_error("Unknown PACKET_UNIT_SHORT_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_COMBAT_INFO: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_COMBAT_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_unit_combat_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_COMBAT_INFO: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_COMBAT_INFO].packet = (int(*)(struct connection *, const void *)) send_packet_unit_combat_info_101;
    } else {
      log_error("Unknown PACKET_UNIT_COMBAT_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTION_ANSWER: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_ACTION_ANSWER].packet = (int(*)(struct connection *, const void *)) send_packet_unit_action_answer_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTION_ANSWER: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_ACTION_ANSWER].packet = (int(*)(struct connection *, const void *)) send_packet_unit_action_answer_101;
    } else {
      log_error("Unknown PACKET_UNIT_ACTION_ANSWER variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTIONS: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_ACTIONS].packet = (int(*)(struct connection *, const void *)) send_packet_unit_actions_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTIONS: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_ACTIONS].packet = (int(*)(struct connection *, const void *)) send_packet_unit_actions_101;
    } else {
      log_error("Unknown PACKET_UNIT_ACTIONS variant for cap %s", capability);
    }
    if (has_capability("rsdesc32", capability)) {
      log_packet_detailed("PACKET_RULESET_CONTROL: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_RULESET_CONTROL].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_control_100;
    } else if (!has_capability("rsdesc32", capability)) {
      log_packet_detailed("PACKET_RULESET_CONTROL: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_RULESET_CONTROL].packet = (int(*)(struct connection *, const void *)) send_packet_ruleset_control_101;
    } else {
      log_error("Unknown PACKET_RULESET_CONTROL variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_WEB_CITY_INFO_ADDITION: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_WEB_CITY_INFO_ADDITION].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_web_city_info_addition_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_WEB_CITY_INFO_ADDITION: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_WEB_CITY_INFO_ADDITION].force_to_send = (int(*)(struct connection *, const void *, bool)) send_packet_web_city_info_addition_101;
    } else {
      log_error("Unknown PACKET_WEB_CITY_INFO_ADDITION variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SELL: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_SELL] = (void *(*)(struct connection *)) receive_packet_city_sell_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SELL: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_SELL] = (void *(*)(struct connection *)) receive_packet_city_sell_101;
    } else {
      log_error("Unknown PACKET_CITY_SELL variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_BUY: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_BUY] = (void *(*)(struct connection *)) receive_packet_city_buy_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_BUY: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_BUY] = (void *(*)(struct connection *)) receive_packet_city_buy_101;
    } else {
      log_error("Unknown PACKET_CITY_BUY variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_CHANGE: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_CHANGE] = (void *(*)(struct connection *)) receive_packet_city_change_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_CHANGE: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_CHANGE] = (void *(*)(struct connection *)) receive_packet_city_change_101;
    } else {
      log_error("Unknown PACKET_CITY_CHANGE variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_WORKLIST: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_WORKLIST] = (void *(*)(struct connection *)) receive_packet_city_worklist_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_WORKLIST: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_WORKLIST] = (void *(*)(struct connection *)) receive_packet_city_worklist_101;
    } else {
      log_error("Unknown PACKET_CITY_WORKLIST variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_MAKE_SPECIALIST: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_MAKE_SPECIALIST] = (void *(*)(struct connection *)) receive_packet_city_make_specialist_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_MAKE_SPECIALIST: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_MAKE_SPECIALIST] = (void *(*)(struct connection *)) receive_packet_city_make_specialist_101;
    } else {
      log_error("Unknown PACKET_CITY_MAKE_SPECIALIST variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_MAKE_WORKER: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_MAKE_WORKER] = (void *(*)(struct connection *)) receive_packet_city_make_worker_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_MAKE_WORKER: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_MAKE_WORKER] = (void *(*)(struct connection *)) receive_packet_city_make_worker_101;
    } else {
      log_error("Unknown PACKET_CITY_MAKE_WORKER variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_CHANGE_SPECIALIST: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_CHANGE_SPECIALIST] = (void *(*)(struct connection *)) receive_packet_city_change_specialist_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_CHANGE_SPECIALIST: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_CHANGE_SPECIALIST] = (void *(*)(struct connection *)) receive_packet_city_change_specialist_101;
    } else {
      log_error("Unknown PACKET_CITY_CHANGE_SPECIALIST variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_RENAME: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_RENAME] = (void *(*)(struct connection *)) receive_packet_city_rename_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_RENAME: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_RENAME] = (void *(*)(struct connection *)) receive_packet_city_rename_101;
    } else {
      log_error("Unknown PACKET_CITY_RENAME variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_OPTIONS_REQ: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_OPTIONS_REQ] = (void *(*)(struct connection *)) receive_packet_city_options_req_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_OPTIONS_REQ: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_OPTIONS_REQ] = (void *(*)(struct connection *)) receive_packet_city_options_req_101;
    } else {
      log_error("Unknown PACKET_CITY_OPTIONS_REQ variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_REFRESH: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_REFRESH] = (void *(*)(struct connection *)) receive_packet_city_refresh_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_REFRESH: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_REFRESH] = (void *(*)(struct connection *)) receive_packet_city_refresh_101;
    } else {
      log_error("Unknown PACKET_CITY_REFRESH variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NAME_SUGGESTION_REQ: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_NAME_SUGGESTION_REQ] = (void *(*)(struct connection *)) receive_packet_city_name_suggestion_req_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NAME_SUGGESTION_REQ: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_NAME_SUGGESTION_REQ] = (void *(*)(struct connection *)) receive_packet_city_name_suggestion_req_101;
    } else {
      log_error("Unknown PACKET_CITY_NAME_SUGGESTION_REQ variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SSCS_SET: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_SSCS_SET] = (void *(*)(struct connection *)) receive_packet_unit_sscs_set_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SSCS_SET: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_SSCS_SET] = (void *(*)(struct connection *)) receive_packet_unit_sscs_set_101;
    } else {
      log_error("Unknown PACKET_UNIT_SSCS_SET variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ORDERS: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_ORDERS] = (void *(*)(struct connection *)) receive_packet_unit_orders_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ORDERS: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_ORDERS] = (void *(*)(struct connection *)) receive_packet_unit_orders_101;
    } else {
      log_error("Unknown PACKET_UNIT_ORDERS variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SERVER_SIDE_AGENT_SET: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_SERVER_SIDE_AGENT_SET] = (void *(*)(struct connection *)) receive_packet_unit_server_side_agent_set_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SERVER_SIDE_AGENT_SET: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_SERVER_SIDE_AGENT_SET] = (void *(*)(struct connection *)) receive_packet_unit_server_side_agent_set_101;
    } else {
      log_error("Unknown PACKET_UNIT_SERVER_SIDE_AGENT_SET variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTION_QUERY: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_ACTION_QUERY] = (void *(*)(struct connection *)) receive_packet_unit_action_query_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTION_QUERY: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_ACTION_QUERY] = (void *(*)(struct connection *)) receive_packet_unit_action_query_101;
    } else {
      log_error("Unknown PACKET_UNIT_ACTION_QUERY variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_DO_ACTION: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_DO_ACTION] = (void *(*)(struct connection *)) receive_packet_unit_do_action_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_DO_ACTION: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_DO_ACTION] = (void *(*)(struct connection *)) receive_packet_unit_do_action_101;
    } else {
      log_error("Unknown PACKET_UNIT_DO_ACTION variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_GET_ACTIONS: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_GET_ACTIONS] = (void *(*)(struct connection *)) receive_packet_unit_get_actions_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_GET_ACTIONS: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_GET_ACTIONS] = (void *(*)(struct connection *)) receive_packet_unit_get_actions_101;
    } else {
      log_error("Unknown PACKET_UNIT_GET_ACTIONS variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_CHANGE_ACTIVITY: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_CHANGE_ACTIVITY] = (void *(*)(struct connection *)) receive_packet_unit_change_activity_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_CHANGE_ACTIVITY: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_CHANGE_ACTIVITY] = (void *(*)(struct connection *)) receive_packet_unit_change_activity_101;
    } else {
      log_error("Unknown PACKET_UNIT_CHANGE_ACTIVITY variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_UNIT_REMOVE_BY_ID: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_EDIT_UNIT_REMOVE_BY_ID] = (void *(*)(struct connection *)) receive_packet_edit_unit_remove_by_id_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_UNIT_REMOVE_BY_ID: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_EDIT_UNIT_REMOVE_BY_ID] = (void *(*)(struct connection *)) receive_packet_edit_unit_remove_by_id_101;
    } else {
      log_error("Unknown PACKET_EDIT_UNIT_REMOVE_BY_ID variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_UNIT: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_EDIT_UNIT] = (void *(*)(struct connection *)) receive_packet_edit_unit_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_UNIT: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_EDIT_UNIT] = (void *(*)(struct connection *)) receive_packet_edit_unit_101;
    } else {
      log_error("Unknown PACKET_EDIT_UNIT variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_CITY_REMOVE: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_EDIT_CITY_REMOVE] = (void *(*)(struct connection *)) receive_packet_edit_city_remove_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_CITY_REMOVE: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_EDIT_CITY_REMOVE] = (void *(*)(struct connection *)) receive_packet_edit_city_remove_101;
    } else {
      log_error("Unknown PACKET_EDIT_CITY_REMOVE variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_CITY: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_EDIT_CITY] = (void *(*)(struct connection *)) receive_packet_edit_city_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_CITY: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_EDIT_CITY] = (void *(*)(struct connection *)) receive_packet_edit_city_101;
    } else {
      log_error("Unknown PACKET_EDIT_CITY variant for cap %s", capability);
    }
  } else {
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SELL: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_SELL].packet = (int(*)(struct connection *, const void *)) send_packet_city_sell_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SELL: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_SELL].packet = (int(*)(struct connection *, const void *)) send_packet_city_sell_101;
    } else {
      log_error("Unknown PACKET_CITY_SELL variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_BUY: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_BUY].packet = (int(*)(struct connection *, const void *)) send_packet_city_buy_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_BUY: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_BUY].packet = (int(*)(struct connection *, const void *)) send_packet_city_buy_101;
    } else {
      log_error("Unknown PACKET_CITY_BUY variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_CHANGE: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_CHANGE].packet = (int(*)(struct connection *, const void *)) send_packet_city_change_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_CHANGE: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_CHANGE].packet = (int(*)(struct connection *, const void *)) send_packet_city_change_101;
    } else {
      log_error("Unknown PACKET_CITY_CHANGE variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_WORKLIST: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_WORKLIST].packet = (int(*)(struct connection *, const void *)) send_packet_city_worklist_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_WORKLIST: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_WORKLIST].packet = (int(*)(struct connection *, const void *)) send_packet_city_worklist_101;
    } else {
      log_error("Unknown PACKET_CITY_WORKLIST variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_MAKE_SPECIALIST: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_MAKE_SPECIALIST].packet = (int(*)(struct connection *, const void *)) send_packet_city_make_specialist_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_MAKE_SPECIALIST: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_MAKE_SPECIALIST].packet = (int(*)(struct connection *, const void *)) send_packet_city_make_specialist_101;
    } else {
      log_error("Unknown PACKET_CITY_MAKE_SPECIALIST variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_MAKE_WORKER: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_MAKE_WORKER].packet = (int(*)(struct connection *, const void *)) send_packet_city_make_worker_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_MAKE_WORKER: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_MAKE_WORKER].packet = (int(*)(struct connection *, const void *)) send_packet_city_make_worker_101;
    } else {
      log_error("Unknown PACKET_CITY_MAKE_WORKER variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_CHANGE_SPECIALIST: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_CHANGE_SPECIALIST].packet = (int(*)(struct connection *, const void *)) send_packet_city_change_specialist_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_CHANGE_SPECIALIST: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_CHANGE_SPECIALIST].packet = (int(*)(struct connection *, const void *)) send_packet_city_change_specialist_101;
    } else {
      log_error("Unknown PACKET_CITY_CHANGE_SPECIALIST variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_RENAME: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_RENAME].packet = (int(*)(struct connection *, const void *)) send_packet_city_rename_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_RENAME: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_RENAME].packet = (int(*)(struct connection *, const void *)) send_packet_city_rename_101;
    } else {
      log_error("Unknown PACKET_CITY_RENAME variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_OPTIONS_REQ: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_OPTIONS_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_city_options_req_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_OPTIONS_REQ: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_OPTIONS_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_city_options_req_101;
    } else {
      log_error("Unknown PACKET_CITY_OPTIONS_REQ variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_REFRESH: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_REFRESH].packet = (int(*)(struct connection *, const void *)) send_packet_city_refresh_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_REFRESH: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_REFRESH].packet = (int(*)(struct connection *, const void *)) send_packet_city_refresh_101;
    } else {
      log_error("Unknown PACKET_CITY_REFRESH variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NAME_SUGGESTION_REQ: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_CITY_NAME_SUGGESTION_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_city_name_suggestion_req_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NAME_SUGGESTION_REQ: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_CITY_NAME_SUGGESTION_REQ].packet = (int(*)(struct connection *, const void *)) send_packet_city_name_suggestion_req_101;
    } else {
      log_error("Unknown PACKET_CITY_NAME_SUGGESTION_REQ variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SSCS_SET: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_SSCS_SET].packet = (int(*)(struct connection *, const void *)) send_packet_unit_sscs_set_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SSCS_SET: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_SSCS_SET].packet = (int(*)(struct connection *, const void *)) send_packet_unit_sscs_set_101;
    } else {
      log_error("Unknown PACKET_UNIT_SSCS_SET variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ORDERS: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_ORDERS].packet = (int(*)(struct connection *, const void *)) send_packet_unit_orders_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ORDERS: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_ORDERS].packet = (int(*)(struct connection *, const void *)) send_packet_unit_orders_101;
    } else {
      log_error("Unknown PACKET_UNIT_ORDERS variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SERVER_SIDE_AGENT_SET: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_SERVER_SIDE_AGENT_SET].packet = (int(*)(struct connection *, const void *)) send_packet_unit_server_side_agent_set_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SERVER_SIDE_AGENT_SET: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_SERVER_SIDE_AGENT_SET].packet = (int(*)(struct connection *, const void *)) send_packet_unit_server_side_agent_set_101;
    } else {
      log_error("Unknown PACKET_UNIT_SERVER_SIDE_AGENT_SET variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTION_QUERY: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_ACTION_QUERY].packet = (int(*)(struct connection *, const void *)) send_packet_unit_action_query_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTION_QUERY: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_ACTION_QUERY].packet = (int(*)(struct connection *, const void *)) send_packet_unit_action_query_101;
    } else {
      log_error("Unknown PACKET_UNIT_ACTION_QUERY variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_DO_ACTION: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_DO_ACTION].packet = (int(*)(struct connection *, const void *)) send_packet_unit_do_action_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_DO_ACTION: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_DO_ACTION].packet = (int(*)(struct connection *, const void *)) send_packet_unit_do_action_101;
    } else {
      log_error("Unknown PACKET_UNIT_DO_ACTION variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_GET_ACTIONS: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_GET_ACTIONS].packet = (int(*)(struct connection *, const void *)) send_packet_unit_get_actions_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_GET_ACTIONS: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_GET_ACTIONS].packet = (int(*)(struct connection *, const void *)) send_packet_unit_get_actions_101;
    } else {
      log_error("Unknown PACKET_UNIT_GET_ACTIONS variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_CHANGE_ACTIVITY: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_UNIT_CHANGE_ACTIVITY].packet = (int(*)(struct connection *, const void *)) send_packet_unit_change_activity_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_CHANGE_ACTIVITY: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_UNIT_CHANGE_ACTIVITY].packet = (int(*)(struct connection *, const void *)) send_packet_unit_change_activity_101;
    } else {
      log_error("Unknown PACKET_UNIT_CHANGE_ACTIVITY variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_UNIT_REMOVE_BY_ID: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_EDIT_UNIT_REMOVE_BY_ID].packet = (int(*)(struct connection *, const void *)) send_packet_edit_unit_remove_by_id_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_UNIT_REMOVE_BY_ID: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_EDIT_UNIT_REMOVE_BY_ID].packet = (int(*)(struct connection *, const void *)) send_packet_edit_unit_remove_by_id_101;
    } else {
      log_error("Unknown PACKET_EDIT_UNIT_REMOVE_BY_ID variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_UNIT: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_EDIT_UNIT].packet = (int(*)(struct connection *, const void *)) send_packet_edit_unit_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_UNIT: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_EDIT_UNIT].packet = (int(*)(struct connection *, const void *)) send_packet_edit_unit_101;
    } else {
      log_error("Unknown PACKET_EDIT_UNIT variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_CITY_REMOVE: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_EDIT_CITY_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_edit_city_remove_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_CITY_REMOVE: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_EDIT_CITY_REMOVE].packet = (int(*)(struct connection *, const void *)) send_packet_edit_city_remove_101;
    } else {
      log_error("Unknown PACKET_EDIT_CITY_REMOVE variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_CITY: using variant=100 cap=%s", capability);
      phandlers->send[PACKET_EDIT_CITY].packet = (int(*)(struct connection *, const void *)) send_packet_edit_city_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_EDIT_CITY: using variant=101 cap=%s", capability);
      phandlers->send[PACKET_EDIT_CITY].packet = (int(*)(struct connection *, const void *)) send_packet_edit_city_101;
    } else {
      log_error("Unknown PACKET_EDIT_CITY variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_INVESTIGATE_STARTED: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_INVESTIGATE_STARTED] = (void *(*)(struct connection *)) receive_packet_investigate_started_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_INVESTIGATE_STARTED: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_INVESTIGATE_STARTED] = (void *(*)(struct connection *)) receive_packet_investigate_started_101;
    } else {
      log_error("Unknown PACKET_INVESTIGATE_STARTED variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_INVESTIGATE_FINISHED: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_INVESTIGATE_FINISHED] = (void *(*)(struct connection *)) receive_packet_investigate_finished_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_INVESTIGATE_FINISHED: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_INVESTIGATE_FINISHED] = (void *(*)(struct connection *)) receive_packet_investigate_finished_101;
    } else {
      log_error("Unknown PACKET_INVESTIGATE_FINISHED variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_TILE_INFO: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_TILE_INFO] = (void *(*)(struct connection *)) receive_packet_tile_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_TILE_INFO: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_TILE_INFO] = (void *(*)(struct connection *)) receive_packet_tile_info_101;
    } else {
      log_error("Unknown PACKET_TILE_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_REMOVE: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_REMOVE] = (void *(*)(struct connection *)) receive_packet_city_remove_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_REMOVE: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_REMOVE] = (void *(*)(struct connection *)) receive_packet_city_remove_101;
    } else {
      log_error("Unknown PACKET_CITY_REMOVE variant for cap %s", capability);
    }
    if (has_capability("ids32", capability) && has_capability("city-original", capability)) {
      log_packet_detailed("PACKET_CITY_INFO: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_INFO] = (void *(*)(struct connection *)) receive_packet_city_info_100;
    } else if (has_capability("ids32", capability) && !has_capability("city-original", capability)) {
      log_packet_detailed("PACKET_CITY_INFO: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_INFO] = (void *(*)(struct connection *)) receive_packet_city_info_101;
    } else if (has_capability("city-original", capability) && !has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_INFO: using variant=102 cap=%s", capability);
      phandlers->receive[PACKET_CITY_INFO] = (void *(*)(struct connection *)) receive_packet_city_info_102;
    } else if (!has_capability("ids32", capability) && !has_capability("city-original", capability)) {
      log_packet_detailed("PACKET_CITY_INFO: using variant=103 cap=%s", capability);
      phandlers->receive[PACKET_CITY_INFO] = (void *(*)(struct connection *)) receive_packet_city_info_103;
    } else {
      log_error("Unknown PACKET_CITY_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NATIONALITIES: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_NATIONALITIES] = (void *(*)(struct connection *)) receive_packet_city_nationalities_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NATIONALITIES: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_NATIONALITIES] = (void *(*)(struct connection *)) receive_packet_city_nationalities_101;
    } else {
      log_error("Unknown PACKET_CITY_NATIONALITIES variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SHORT_INFO: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_SHORT_INFO] = (void *(*)(struct connection *)) receive_packet_city_short_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SHORT_INFO: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_SHORT_INFO] = (void *(*)(struct connection *)) receive_packet_city_short_info_101;
    } else {
      log_error("Unknown PACKET_CITY_SHORT_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_TRADE_ROUTE_INFO: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_TRADE_ROUTE_INFO] = (void *(*)(struct connection *)) receive_packet_trade_route_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_TRADE_ROUTE_INFO: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_TRADE_ROUTE_INFO] = (void *(*)(struct connection *)) receive_packet_trade_route_info_101;
    } else {
      log_error("Unknown PACKET_TRADE_ROUTE_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NAME_SUGGESTION_INFO: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_NAME_SUGGESTION_INFO] = (void *(*)(struct connection *)) receive_packet_city_name_suggestion_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_NAME_SUGGESTION_INFO: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_NAME_SUGGESTION_INFO] = (void *(*)(struct connection *)) receive_packet_city_name_suggestion_info_101;
    } else {
      log_error("Unknown PACKET_CITY_NAME_SUGGESTION_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SABOTAGE_LIST: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_CITY_SABOTAGE_LIST] = (void *(*)(struct connection *)) receive_packet_city_sabotage_list_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_CITY_SABOTAGE_LIST: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_CITY_SABOTAGE_LIST] = (void *(*)(struct connection *)) receive_packet_city_sabotage_list_101;
    } else {
      log_error("Unknown PACKET_CITY_SABOTAGE_LIST variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_REMOVE: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_REMOVE] = (void *(*)(struct connection *)) receive_packet_unit_remove_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_REMOVE: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_REMOVE] = (void *(*)(struct connection *)) receive_packet_unit_remove_101;
    } else {
      log_error("Unknown PACKET_UNIT_REMOVE variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_INFO: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_INFO] = (void *(*)(struct connection *)) receive_packet_unit_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_INFO: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_INFO] = (void *(*)(struct connection *)) receive_packet_unit_info_101;
    } else {
      log_error("Unknown PACKET_UNIT_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SHORT_INFO: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_SHORT_INFO] = (void *(*)(struct connection *)) receive_packet_unit_short_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_SHORT_INFO: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_SHORT_INFO] = (void *(*)(struct connection *)) receive_packet_unit_short_info_101;
    } else {
      log_error("Unknown PACKET_UNIT_SHORT_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_COMBAT_INFO: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_COMBAT_INFO] = (void *(*)(struct connection *)) receive_packet_unit_combat_info_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_COMBAT_INFO: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_COMBAT_INFO] = (void *(*)(struct connection *)) receive_packet_unit_combat_info_101;
    } else {
      log_error("Unknown PACKET_UNIT_COMBAT_INFO variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTION_ANSWER: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_ACTION_ANSWER] = (void *(*)(struct connection *)) receive_packet_unit_action_answer_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTION_ANSWER: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_ACTION_ANSWER] = (void *(*)(struct connection *)) receive_packet_unit_action_answer_101;
    } else {
      log_error("Unknown PACKET_UNIT_ACTION_ANSWER variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTIONS: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_ACTIONS] = (void *(*)(struct connection *)) receive_packet_unit_actions_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_UNIT_ACTIONS: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_UNIT_ACTIONS] = (void *(*)(struct connection *)) receive_packet_unit_actions_101;
    } else {
      log_error("Unknown PACKET_UNIT_ACTIONS variant for cap %s", capability);
    }
    if (has_capability("rsdesc32", capability)) {
      log_packet_detailed("PACKET_RULESET_CONTROL: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_RULESET_CONTROL] = (void *(*)(struct connection *)) receive_packet_ruleset_control_100;
    } else if (!has_capability("rsdesc32", capability)) {
      log_packet_detailed("PACKET_RULESET_CONTROL: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_RULESET_CONTROL] = (void *(*)(struct connection *)) receive_packet_ruleset_control_101;
    } else {
      log_error("Unknown PACKET_RULESET_CONTROL variant for cap %s", capability);
    }
    if (has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_WEB_CITY_INFO_ADDITION: using variant=100 cap=%s", capability);
      phandlers->receive[PACKET_WEB_CITY_INFO_ADDITION] = (void *(*)(struct connection *)) receive_packet_web_city_info_addition_100;
    } else if (!has_capability("ids32", capability)) {
      log_packet_detailed("PACKET_WEB_CITY_INFO_ADDITION: using variant=101 cap=%s", capability);
      phandlers->receive[PACKET_WEB_CITY_INFO_ADDITION] = (void *(*)(struct connection *)) receive_packet_web_city_info_addition_101;
    } else {
      log_error("Unknown PACKET_WEB_CITY_INFO_ADDITION variant for cap %s", capability);
    }
  }
}
